<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wuwenbang.github.io</id>
    <title>核动力实验室</title>
    <updated>2022-03-17T22:04:26.895Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wuwenbang.github.io"/>
    <link rel="self" href="https://wuwenbang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wuwenbang.github.io/images/avatar.png</logo>
    <icon>https://wuwenbang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 核动力实验室</rights>
    <entry>
        <title type="html"><![CDATA[React Hooks 性能优化]]></title>
        <id>https://wuwenbang.github.io/post/react-hooks-xing-neng-you-hua/</id>
        <link href="https://wuwenbang.github.io/post/react-hooks-xing-neng-you-hua/">
        </link>
        <updated>2022-03-17T17:27:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>现在越来越多人开始使用 React Hooks + 函数组件的方式构筑页面。函数组件简洁且优雅，通过 Hooks 可以让函数组件拥有内部的状态和副作用（生命周期），弥补了函数组件的不足。</p>
<p>但同时函数组件的使用也带来了一些额外的问题：由于函数式组件内部的状态更新时，会重新执行一遍函数，那么就有可能造成以下两点性能问题：</p>
<ol>
<li>造成子组件的非必要重新渲染</li>
<li>造成组件内部某些代码（计算）的重复执行</li>
</ol>
<p>好在 React 团队也意识到函数组件可能发生的性能问题，并提供了 <code>React.memo</code>、<code>useMemo</code>、<code>useCallback</code> 这些 API 帮助开发者去优化他们的 React 代码。在使用它们进行优化之前，我想我们需要明确我们使用它们的目的：</p>
<ol>
<li>减少组件的非必要重新渲染</li>
<li>减少组件内部的重复计算</li>
</ol>
<h1 id="1-使用-reactmemo-避免组件的重复渲染">1 使用 React.memo 避免组件的重复渲染</h1>
<p>在讲述 <code>React.memo</code> 的作用之前，我们先来思考一个问题：什么情况下需要重新渲染组件？</p>
<p>一般来讲以下三种情况需要重新渲染组件：</p>
<ol>
<li>组件内部 <code>state</code> 发生变化时</li>
<li>组件内部使用的 <code>context</code> 发生变化时</li>
<li>组件外部传递的 <code>props</code> 发生变化时</li>
</ol>
<p>现在我们先只关注第 3 点：<code>props</code> 发生变化时重新渲染，这种情况是一种理想情况。因为如果一个父组件重新渲染，即使其子组件的 <code>props</code> 没有发生任何变化，这个子组件也会重新渲染，我们称这种渲染为<strong>非必要的重新渲染</strong>。这时 <code>React.memo</code> 就可以派上用场了。</p>
<p>首先 <code>React.memo</code> 是一个<strong>高阶组件</strong>。</p>
<blockquote>
<p>高阶组件（Higher Order Component）类似一个工厂：将一个组件丢进去，然后返回一个被加工过的组件。</p>
</blockquote>
<p>被 <code>React.memo</code> 包裹的组件在渲染前，会对新旧 <code>props</code> 进行<strong>浅比较</strong>：</p>
<ul>
<li>如果新旧 <code>props</code> 浅比较相等，则不进行重新渲染（使用缓存的组件）。</li>
<li>如果新旧 <code>props</code> 浅比较不相等，则进行重新渲染（重新渲染的组件）。</li>
</ul>
<p>上述的解释可能会比较抽象，我们来看一个具体的例子：</p>
<pre><code class="language-tsx">import React, { useState } from 'react';

const Child = () =&gt; {
  console.log('Child 渲染了');
  return &lt;div&gt;Child&lt;/div&gt;;
};

const MemoChild = React.memo(() =&gt; {
  console.log('MemoChild 渲染了');
  return &lt;div&gt;MemoChild&lt;/div&gt;;
});

function App() {
  const [isUpdate, setIsUpdate] = useState(true);
  const onClick = () =&gt; {
    setIsUpdate(!isUpdate);
    console.log('点击了按钮');
  };
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;Child /&gt;
      &lt;MemoChild /&gt;
      &lt;button onClick={onClick}&gt;刷新 App &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>上例中：<code>Child</code> 是一个普通的组件，<code>MemoChild</code> 是一个被 <code>React.memo</code> 包裹的组件。</p>
<p>当我点击 <code>button</code> 按钮时，调用 <code>setIsUpdate</code> 触发 App 组件重新渲染（re-render）。</p>
<p>控制台结果如下：</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/qpeoct"><img src="https://s1.ax1x.com/2022/03/16/qpeoct.png" alt="qpeoct.png" loading="lazy"></a></figure>
<p>如上图：<br>
首次渲染时，<code>Child</code> 和 <code>MemoChild</code> 都会被渲染，控制台打印 <code>Child 渲染了</code> 和 <code>memoChild</code> 渲染了。</p>
<p>而当我点击按钮触发重新渲染后，<code>Child</code> 依旧会重新渲染，而 <code>MemoChild</code> 则会进行新旧 <code>props</code> 的判断，由于 <code>memoChild</code> 没有 <code>props</code>，即新旧 <code>props</code> 相等（都为空），则 <code>memoChild</code> 使用之前的渲染结果（缓存），避免了重新渲染。</p>
<p>由此可见，在没有任何优化的情况下，React 中某一组件重新渲染，会导致其全部的<strong>子组件重新渲染</strong>。即通过 <code>React.memo</code> 的包裹，在其父组件重新渲染时，可以避免这个组件的非必要重新渲染。</p>
<p>需要注意的是：上文中的【渲染】指的是 React 执行函数组件并生成或更新虚拟 DOM 树（Fiber 树）的过程。在渲染真实 DOM （Commit 阶段）前还有 DOM Diff 的过程，会比对虚拟 DOM 之间的差异，再去渲染变化的 DOM 。不然如果每次更改状态都会重新渲染真实 DOM，那么 React 的性能真就爆炸了（笑）。</p>
<h1 id="2-使用-usememo-避免重复计算">2 使用 useMemo 避免重复计算</h1>
<p><code>const memolized = useMemo(fn,deps)</code></p>
<p>React 的 useMemo 把【计算函数 <code>fn</code>】和【依赖项数组 <code>deps</code>】作为参数，useMemo 会执行 <code>fn</code> 并返回一个【缓存值 <code>memolized</code>】，它仅会在某个依赖项改变时才重新计算 <code>memolized</code>。这种优化有助于避免在每次渲染时都进行高开销的计算。具体使用场景可以参考下例：</p>
<pre><code class="language-tsx">import React, { useMemo, useState } from 'react';

function App() {
  const [list] = useState([1, 2, 3, 4]);
  const [isUpdate, setIsUpdate] = useState(true);
  const onClick = () =&gt; {
    setIsUpdate(!isUpdate);
    console.log('点击了按钮');
  };

  // 普通计算 list 的和
  console.log('普通计算');
  const sum = list.reduce((previous, current) =&gt; previous + current);

  // 缓存计算 list 的和
  const memoSum = useMemo(() =&gt; {
    console.log('useMemo 计算');
    return list.reduce((previous, current) =&gt; previous + current);
  }, [list]);

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;div&gt; sum:{sum}&lt;/div&gt;
      &lt;div&gt; memoSum:{memoSum}&lt;/div&gt;
      &lt;button onClick={onClick}&gt;重新渲染 App&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>上例中：<code>sum</code> 是一个根据 <code>list</code> 得到的普通计算值，<code>memoSum</code> 是一个通过 <code>useMemo</code> 得到的 momelized 值（缓存值），并且依赖项为 <code>list</code>。</p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/qpR3CT"><img src="https://s1.ax1x.com/2022/03/16/qpR3CT.png" alt="qpR3CT.png" loading="lazy"></a></figure>
<p>如上图控制台中 log 所示：首次渲染，<code>sum</code> 和 <code>memoSum</code> 都会根据 <code>list</code> 的值进行计算；</p>
<p>当点击 【重新渲染 App】按钮后，虽然 <code>list</code> 没有改变，但是 <code>sum</code> 的值进行了重新计算，而 <code>memoSum</code> 的值则没有重新计算，使用了上一次的计算结果（memolized）。</p>
<p>当点击 【往 List 添加一个数字】按钮后，<code>list</code> 的值发生改变，<code>sum</code> 和 <code>memoSum</code> 的值都进行重新计算。</p>
<p>总结：在函数组件内部，一些基于 State 的衍生值和一些复杂的计算可以通过 useMemo 进行性能优化。</p>
<h1 id="3-使用-usecallback-避免子组件的重复渲染">3 使用 useCallback 避免子组件的重复渲染</h1>
<p><code>const memolizedCallback = useCallback(fn, deps);</code></p>
<p>React 的 useCallback 把【回调函数 <code>fn</code>】和【依赖项数组 <code>deps</code>】作为参数，并返回一个【缓存的回调函数 <code>memolizedCallback</code>】（本质上是一个引用），它仅会在某个依赖项改变时才重新生成 <code>memolizedCallback</code>。当你把 <code>memolizedCallback</code> 作为参数传递给子组件（被 React.memo 包裹过的）时，它可以避免非必要的子组件重新渲染。</p>
<h2 id="usecallback-与-usememo-异同">useCallback 与 useMemo 异同</h2>
<p><code>useCallback</code> 与 <code>useMemo</code> 都会缓存对应的值，并且只有在依赖变动的时候才会更新缓存，区别在于：</p>
<ul>
<li><code>useMemo</code> 会执行传入的回调函数，返回的是函数执行的结果</li>
<li><code>useCallback</code> 不会执行传入的回调函数，返回的是函数的引用</li>
</ul>
<h2 id="usecallback-使用误区">useCallback 使用误区</h2>
<p>有很多初学者（包括以前的我）会有这样一个误区：在函数组件内部声明的函数全部都用 <code>useCallback</code> 包裹一层，以为这样可以通过避免函数的重复生成优化性能，实则不然：</p>
<ol>
<li>首先，在 JS 内部函数创建是非常快的，这点性能问题不是个问题（参考：<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render">React 官方文档：Hook 会因为在渲染时创建函数而变慢吗？</a>）</li>
<li>其次，使用 <code>useCallback</code> 会造成额外的性能损耗，因为增加了额外的 <code>deps</code> 变化判断。</li>
<li>每个函数用 <code>useCallback</code> 包一层，不仅显得臃肿，而且还需要手写 <code>deps</code> 数组，额外增加心智负担。</li>
</ol>
<h2 id="usecallback-正确的使用场景">useCallback 正确的使用场景</h2>
<ol>
<li>函数组件内部定义的函数需要作为其他 Hooks 的依赖。</li>
<li>函数组件内部定义的函数需要传递给其子组件，并且子组件由 <code>React.memo</code> 包裹。</li>
</ol>
<p>场景 1：<code>useCallback</code> 主要是为了避免当组件重新渲染时，函数引用变动所导致其它 Hooks 的重新执行，更为甚者可能造成组件的无限渲染：</p>
<pre><code class="language-tsx">import React, { useEffect, useState } from 'react';

function App() {
  const [count, setCount] = useState(1);
  const add = () =&gt; {
    setCount((count) =&gt; count + 1);
  };
  useEffect(() =&gt; {
    add();
  }, [add]);
  return &lt;div className=&quot;App&quot;&gt;count: {count}&lt;/div&gt;;
}

export default App;
</code></pre>
<p>上例中，<code>useEffect</code> 会执行 <code>add</code> 函数从而触发组件的重新渲染，函数的重新渲染会重新生成 <code>add</code> 的引用，从而触发 <code>useEffect</code> 的重新执行，然后再执行 <code>add</code> 函数触发组件的重新渲染... ，从而导致无限循环：</p>
<p><code>useEffect</code> 执行 -&gt; <code>add</code> 执行 -&gt; <code>setCount</code> 执行 -&gt; <code>App</code> 重新渲染 -&gt; <code>add</code> 重新生成 -&gt; <code>useEffect</code> 执行 -&gt; <code>add</code> 执行 -&gt; ...</p>
<p>为了避免上述的情况，我们给 <code>add</code> 函数套一层 <code>useCallback</code> 避免函数引用的变动，就可以解决无限循环的问题：</p>
<pre><code class="language-tsx">import React, { useCallback, useEffect, useState } from 'react';

function App() {
  const [count, setCount] = useState(1);
  // 用 useCallback 包裹 add ，只会在组件第一次渲染生成函数引用，之后组件重新渲染时，add 会复用第一次生成的引用。
  const add = useCallback(() =&gt; {
    setCount((count) =&gt; count + 1);
  }, []);
  useEffect(() =&gt; {
    add();
  }, [add]);
  return &lt;div className=&quot;App&quot;&gt;count: {count}&lt;/div&gt;;
}

export default App;
</code></pre>
<p>场景 2：<code>useCallback</code> 是为了避免由于回调函数引用变动，所导致的子组件非必要重新渲染。（这个子组件有两个前提：首先是接收回调函数作为 <code>props</code>，其次是被 <code>React.memo</code> 所包裹。）</p>
<pre><code class="language-js">const Child = React.memo(({ onClick }) =&gt; {
  console.log(`Button render`);
  return (
    &lt;div&gt;
      &lt;button onClick={onClick}&gt;child button&lt;/button&gt;
    &lt;/div&gt;
  );
});

function App() {
  const [countA, setCountA] = useState(0);
  const [countB, setCountB] = useState(0);
  // 情况1：未包裹 useCallback
  const onClick = () =&gt; {
    setCountA(countA + 1);
  };
  // 情况2：包裹 useCallback
  const onClick = useCallback(() =&gt; {
    setCountA(countA + 1);
  }, []);
  return (
    &lt;div&gt;
      &lt;div&gt;countA:{countA}&lt;/div&gt;
      &lt;div&gt;countB:{countB}&lt;/div&gt;
      &lt;Child onClick={onClick1} /&gt;
      &lt;button onClick={() =&gt; setCountB(countB + 1)}&gt;App button&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>上例中，<code>Child</code> 子组件由 <code>React.memo</code> 包裹，接收 <code>onClick</code> 函数作为 <code>props</code> 参数。</p>
<ul>
<li>情况 1：<code>onClick</code> 未包裹 <code>useCallback</code> ，当点击 <code>app button</code> 时，触发重新渲染，<code>onClick</code> <strong>重新生成函数引用</strong>，导致 <code>Child</code> 子组件重新渲染。</li>
<li>情况 2：<code>onClick</code> 包裹 <code>useCallback</code> ，当点击 <code>app button</code> 时，触发重新渲染，<code>onClick</code> <strong>不会生成新的引用</strong>，避免了 <code>Child</code> 子组件重新渲染。</li>
</ul>
<h1 id="4-总结">4 总结</h1>
<p>上文叙述中，我们通过 <code>React.memo</code>、<code>useMemo</code>、<code>useCallback</code> 这些 API 避免了在使用函数组件的过程中可能触发的性能问题，总结为一下三点：</p>
<ul>
<li>通过 <code>React.memo</code> 包裹组件，可以避免组件的非必要重新渲染。</li>
<li>通过 <code>useMemo</code>，可以避免组件更新时所引发的重复计算。</li>
<li>通过 <code>useCallback</code>，可以避免由于函数引用变动所导致的组件重复渲染。</li>
</ul>
<h1 id="参考文章">参考文章</h1>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#performance-optimizations">React 官方文档</a></li>
<li><a href="https://segmentfault.com/a/1190000022988054">Segmentfault 一直以来<code>useCallback</code>的使用姿势都不对</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack Plugin 浅析]]></title>
        <id>https://wuwenbang.github.io/post/webpack-plugin-qian-xi/</id>
        <link href="https://wuwenbang.github.io/post/webpack-plugin-qian-xi/">
        </link>
        <updated>2022-03-09T20:21:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="plugin-是什么">Plugin 是什么</h1>
<p>Plugin 是 Webpack 中的扩展器，在 Webpack 运行的生命周期中会广播出许多钩子事件，Plugin 可以监听这些事件，并挂载自己的任务，也就是注册事件。当 Webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行了。</p>
<h2 id="plugin-与-loader-的区别">Plugin 与 Loader 的区别</h2>
<h3 id="plugin-与-loader-功能不同">Plugin 与 Loader 功能不同</h3>
<ul>
<li>Loader 是一个转换器：能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中。</li>
<li>Plugin 是一个扩展器：赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事。</li>
</ul>
<h3 id="plugin-与-loader-运行时机不同">Plugin 与 Loader 运行时机不同</h3>
<p><img src="https://static.vue-js.com/9a04ec40-a7c2-11eb-ab90-d9ae814b240d.png" alt="image" loading="lazy"><br>
可以看到，两者在运行时机上的区别：</p>
<ul>
<li>Loader 运行在打包文件之前</li>
<li>Plugin 在整个编译周期都起作用</li>
</ul>
<h1 id="plugin-的使用">Plugin 的使用</h1>
<h2 id="plugin-配置方式">Plugin 配置方式</h2>
<p>在 <code>webpack.config.js</code> 文件中，通过 Webpack 配置对象的 <code>plugins</code> 属性进行配置，<code>plugins</code> 为一个数组，其元素要求为插件对象 Plugin 的实例，配置参数可以通过 Plugin 在实例化时的构造参数进行传递，例如配置 <code>html-webpack-plugin</code> 如下：</p>
<pre><code class="language-js">const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = = {
  entry: './index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'}),
  ],
};
</code></pre>
<h2 id="常见的-plugin">常见的 Plugin</h2>
<h3 id="1-html-webpack-pluginhtml-文件生成插件">1 html-webpack-plugin（HTML 文件生成插件）</h3>
<ul>
<li>背景：多入口时，当你的 <code>index.html</code> 引入多个 <code>js</code> 文件，如果这些生成的 <code>js</code> 名称构成有 <code>[hash]</code> ，那么每次打包后的文件名都是变化的。</li>
<li>作用：可以用于自动重新生成一个 <code>index.html</code> ，并帮你把所有生产的 <code>js</code> 文件引入到 <code>html</code> 中，最终生成到 <code>output</code> 目录。</li>
<li>安装：</li>
</ul>
<pre><code class="language-sh">yarn add --dev html-webpack-plugin
</code></pre>
<ul>
<li>配置：</li>
</ul>
<pre><code class="language-js">//引入
const HtmlWebpackPlugin = require('html-webpack-plugin');
//配置
module.exports = = {
  // ...
  plugins: [
    new HtmlWebpackPlugin(),
  ],
};
</code></pre>
<h3 id="2-mini-css-extract-plugincss-提取插件">2 mini-css-extract-plugin（css 提取插件）</h3>
<ul>
<li>背景：在进行打包时，CSS 代码会打包到 JS 中，不利于文件缓存。</li>
<li>作用：依据每个 entry 生成单个 CSS 文件（将 CSS 从 JS 中提取出来）。</li>
<li>安装：</li>
</ul>
<pre><code class="language-sh">yarn add --dev mini-css-extract-plugin
</code></pre>
<ul>
<li>配置：</li>
</ul>
<pre><code class="language-js">const MiniCssExtractPlugin  = require('mini-css-extract-plugin');
module.exports = = {
  // ...
  plugins: [
    new MiniCssExtractPlugin(),
  ],
};

</code></pre>
<h3 id="3-imagemin-webpack-plugin图片压缩插件">3 imagemin-webpack-plugin（图片压缩插件）</h3>
<ul>
<li>背景：图片过大，加载速度慢，浪费存储空间。</li>
<li>作用：批量压缩图片。</li>
<li>安装：</li>
</ul>
<pre><code class="language-sh">yarn add --dev imagemin-webpack-plugin
</code></pre>
<ul>
<li>配置：</li>
</ul>
<pre><code class="language-js">const ImageminPlugin = require('imagemin-webpack-plugin').default;
module.exports = {
  // ...
  plugins: [
    new ImageminPlugin({
      disable: process.env.NODE_ENV !== 'production', // 开发时不启用
      pngquant: {
        //图片质量
        quality: '95-100',
      },
    }),
  ],
};
</code></pre>
<h3 id="4-clean-webpack-plugin清空文件夹插件">4 clean-webpack-plugin（清空文件夹插件）</h3>
<ul>
<li>背景：每次进行打包需要手动清空目标文件夹。</li>
<li>作用：每次打包时先清空 <code>output</code> 文件夹。</li>
<li>安装：</li>
</ul>
<pre><code class="language-sh">yarn add --dev clean-webpack-plugin
</code></pre>
<ul>
<li>配置：</li>
</ul>
<pre><code class="language-js">const CleanWebpackPlugin = require('clean-webpack-plugin');
module.exports = {
  // ...
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  // 自动清空 dist 文件夹
  plugins: [new CleanWebpackPlugin(['dist'])],
};
</code></pre>
<h3 id="5-copy-webpack-plugin文件复制插件">5 copy-webpack-plugin（文件复制插件）</h3>
<ul>
<li>背景：一些静态资源（图片、字体等），在编译时，需要拷贝到输出文件夹。</li>
<li>作用：用来复制文件或文件夹。</li>
<li>安装：</li>
</ul>
<pre><code class="language-sh">yarn add --dev copy-webpack-plugin
</code></pre>
<ul>
<li>配置：</li>
</ul>
<pre><code class="language-js">// 引入
const CopyPlugin = require('copy-webpack-plugin');

module.exports = {
  // ...
  plugins: [
    new CopyPlugin([
      { from: 'assets', to: 'dist' },
      { from: 'images/xxx.png', to: 'dist' },
    ]),
  ],
};
</code></pre>
<h3 id="6-compression-webpack-plugingzip-压缩插件">6 compression-webpack-plugin（gzip 压缩插件）</h3>
<ul>
<li>背景：所有现代浏览器都支持 <code>gzip</code> 压缩，启用 <code>gzip</code> 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。</li>
<li>作用：用来对一些文本文件（JS CSS HTML）文件进行 <code>gzip</code> 压缩。</li>
<li>安装：</li>
</ul>
<pre><code class="language-sh">yarn add --dev compression-webpack-plugin
</code></pre>
<ul>
<li>配置：</li>
</ul>
<pre><code class="language-js">// 引入
const CompressionPlugin = require('compression-webpack-plugin');

module.exports = {
  // ...
  plugins: [
    new CompressionPlugin({
      // gzip压缩配置
      test: /\.js$|\.html$|\.css/, // 匹配文件名
      threshold: 10240, // 对超过10kb的数据进行压缩
      deleteOriginalAssets: false, // 是否删除原文件
    }),
  ],
};
</code></pre>
<h1 id="参考文档">参考文档</h1>
<ul>
<li><a href="https://webpack.js.org/concepts/plugin/">Webpack 官方文档 Plugin</a></li>
<li><a href="https://juejin.cn/post/6844903918862860301">webpack 常用插件</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack Loader 浅析]]></title>
        <id>https://wuwenbang.github.io/post/webpack-loader-qian-xi/</id>
        <link href="https://wuwenbang.github.io/post/webpack-loader-qian-xi/">
        </link>
        <updated>2022-03-09T20:17:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-loader-是什么">1 Loader 是什么</h1>
<p>Loader 是 Webpack 中的文件加载器。</p>
<h2 id="loader-的作用">Loader 的作用</h2>
<p>Webpack 是一个模块化打包工具，但是其只能直接处理 JavaScript 格式的代码。任何非 JavaScript 文件（例如 TypeScript CSS SASS JSX）都必须被预先处理转换为 JavaScript 代码，才可以参与打包。而 Loader 文件加载器，能够加载资源文件，并对这些文件进行特定的处理，然后打包的指定文件中。</p>
<p>例如 <code>ts-loader</code> 可以将 TypeScript 转换为 JavaScript 代码：</p>
<p>TypeScript -&gt; (ts-loader) -&gt; JavaScript</p>
<h2 id="loader-的本质">Loader 的本质</h2>
<p>Loader 本质上是导出函数的 JavaScript 模块：</p>
<pre><code class="language-js">/**
 * @param {string|Buffer} content 源文件的内容
 * @param {object} [map]  SourceMap 数据，用于定位源码
 * @param {any} [meta] meta 数据，可以是任何内容
 */
function webpackLoader(content, map, meta) {
  // 你的webpack loader代码
}
module.exports = webpackLoader;
</code></pre>
<p>基于所导出的函数，我们可以实现对源文件内容 <code>content</code> 的转换：函数 <code>return</code> 的就是转换的结果。</p>
<h1 id="2-loader-使用方式">2 Loader 使用方式</h1>
<h2 id="loader-三种使用方式">Loader 三种使用方式</h2>
<ol>
<li>配置（推荐）：在 <code>webpack.config.js</code> 文件中指定 loader。</li>
</ol>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          { loader: 'style-loader' },
          {
            loader: 'css-loader',
            options: {
              modules: true,
            },
          },
        ],
      },
    ],
  },
};
</code></pre>
<ol start="2">
<li>内联：在每个 import 语句中显式指定 loader。<br>
可以在 <code>import</code> 语句或任何等效于 &quot;import&quot; 的方式中指定 loader。使用 <code>!</code> 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。</li>
</ol>
<pre><code class="language-js">import Styles from 'style-loader!css-loader?modules!./styles.css';
</code></pre>
<ol start="3">
<li>命令行：在 shell 命令中指定它们。</li>
</ol>
<pre><code class="language-sh">webpack --module-bind 'css=style-loader!css-loader'
</code></pre>
<p>这样会对 <code>.css</code> 文件使用 <code>style-loader</code> 和 <code>css-loader</code>。</p>
<h2 id="loader-执行顺序">Loader 执行顺序</h2>
<p>Loader 遵循如下规则执行：从右到左，从下到上。</p>
<p>例如上述 Loader 的执行顺序就是： css-loader -&gt; style-loader。</p>
<h1 id="3-webpack-常用-loader">3 Webpack 常用 Loader</h1>
<ul>
<li>样式：style-loader、css-loader、sass-loader 等</li>
<li>文件：raw-loader、file-loader、url-loader 等</li>
<li>编译：babel-loader、vue-loader、ts-loader 等</li>
<li>校验测试：eslint-loader、mocha-loader 等</li>
</ul>
<h2 id="样式-loader">样式 Loader</h2>
<p>例如我们需要处理 <code>.sass</code> 文件，则需要经历一下三个 Loader ：</p>
<ol>
<li>sass-loader: 将 <code>.sass</code> 文件转换为 <code>.css</code> 文件</li>
<li>css-loader: 将<code>.css</code> 文件内容转换为 JS 的字符串并作为 JS 模块导出</li>
<li>style-loader: 将 <code>css</code> 字符串以 <code>style</code> 标签的方式插入 DOM 树中</li>
</ol>
<p>实现以上三个 Loader 的配置如下：</p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      {
        test: /\.s[ca]ss$/,
        use: ['style-loader', 'css-loader', 'sass-loader'],
      },
    ],
  },
};
</code></pre>
<h2 id="文件-loader">文件 Loader</h2>
<ul>
<li>raw-loader：加载文件原始内容（utf-8），返回 <code>JSON.stringify</code> 后的内容。</li>
<li>file-loader：主要作用是将指定文件拷贝到输出文件夹。</li>
<li>url-loader：url-loader 在 file-loader 的基础上加了一个 <code>data URL</code> 的功能。传给 url-loader 一个限制值，如果处理的文件小于这个值，loader 将会把文件转化为 <code>base64</code> 的 <code>data URL</code> 输出。大于限制的文件则交给引入的 file-loader 处理。</li>
</ul>
<h2 id="编译-loader">编译 Loader</h2>
<ul>
<li>babel-loader：默认用来处理 ES6 语法，将其编译为浏览器可以执行的 JS 语法。</li>
<li>vue-loader：用来将 <code>.vue</code> 文件处理为 JS 可以识别的模块。</li>
<li>ts-loader：用来将 <code>.ts</code> 文件处理为 JS 可以识别的语法。</li>
</ul>
<h2 id="校验测试-loader">校验测试 Loader</h2>
<ul>
<li>eslint-loader：允许 Eslitn 对 JS 文件做语法检查。</li>
<li>mocha-loader：允许通过 Webpack 加载和运行 <code>Mocha Test</code>。</li>
</ul>
<h1 id="参考文档">参考文档</h1>
<ul>
<li><a href="https://webpack.js.org/concepts/loaders/">Webpack 官方文档 Loaders</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reack Hooks 从函数的角度去理解]]></title>
        <id>https://wuwenbang.github.io/post/reack-hooks-cong-han-shu-de-jiao-du-qu-li-jie/</id>
        <link href="https://wuwenbang.github.io/post/reack-hooks-cong-han-shu-de-jiao-du-qu-li-jie/">
        </link>
        <updated>2022-02-26T08:17:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-react-核心公式">1. React 核心公式</h1>
<p>当我们在使用 React 函数组件构筑视图的时候，我们到底在干什么呢？<br>
大部分时间我们其实是在定义函数（函数组件），然后把写好的函数丢进 <code>ReactDOM.render()</code> 里去渲染，就像这样：</p>
<pre><code class="language-js">// 定义函数组件
function App() {
  return &lt;div&gt;Hello World!&lt;/div&gt;;
}
// 渲染函数组件
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p>然后 React 帮助我们将函数执行的结果（在函数内部 return 的 HTML 内容）渲染到视图上，所以 React 的核心功能可以用一个简单的公式概括：</p>
<p><code>UI = f()</code></p>
<p>即视图等于一个函数执行的结果。</p>
<p>再介绍后续 Hooks 相关内容之前，首先介绍两个概念：纯函数和副作用函数。</p>
<ul>
<li>纯函数（ Pure Function ）：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，这样的函数被称为纯函数。</li>
<li>副作用函数（ Side effect Function ）：如果一个函数在运行的过程中，除了返回函数值，还对主调用函数产生附加的影响（例如访问外部变量，发起 HTTP 请求，操作 DOM 等等），这样的函数被称为副作用函数。</li>
</ul>
<p>在没有引入 Hooks 之前，函数式组件还是一个纯函数（相同的输入永远获得相同的输出），我们称这样的函数组件为<strong>纯函数组件</strong>。</p>
<h1 id="2-状态-usestate">2. 状态 useState</h1>
<p>现在我们已经可以通过 React 渲染一个页面了，然而他就岁月尽好的躺在那，但是如果我想来点动静：比如添加一个计数器——一个数字和一个按钮，每次点击就 +1 ，这个时候我们就需要组件自己的状态了：用 <code>useState</code> 创建状态。先看一个例子：</p>
<pre><code class="language-jsx">function App() {
  const [count, setCount] = useState(0);
  const add = () =&gt; {
    setCount(count + 1);
  };
  return (
    &lt;div&gt;
      &lt;div&gt;count:{count}&lt;/div&gt;
      &lt;button onClick={add}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p>我们来具体聊一下上述代码中我们到底做了哪些事情：</p>
<ol>
<li>首先，我们调用 <code>useState</code> 函数并传入初始值 <code>0</code>，<code>useState</code> 函数返回一个包含 <strong>状态（state）</strong> 和 <strong>改变状态的方法（setState）</strong> 的元组，最后我们对元组用解构赋值：将状态赋值给 <code>count</code> 常量，改变状态的方法赋值给 <code>setCount</code> 常量。</li>
<li>然后我们定义 <code>add</code> 函数：调用 <code>setCount</code> 方法并传入 <code>count + 1</code> 的值。</li>
<li>接着我们在 <code>return</code> 的 <code>div</code> 元素内渲染 <code>count</code>，同时将函数 <code>add</code> 绑定在 <code>button</code> 元素的 <code>onClick</code> 事件上。</li>
</ol>
<p>运行这段代码：初次渲染 <code>count</code> 的值为 <code>0</code>，每次点击 +1 按钮后，页面中 <code>count</code> 的值 +1。</p>
<p>那么问题来了，页面中渲染的 <code>count</code> 是怎么改变的呢？我们来详细解析一下：</p>
<ol>
<li>第一次渲染：
<ol>
<li>初始化 <code>useState</code> 中的 <code>state</code> 为初始值 <code>0</code>，然后将其解构赋值给 <code>count</code>。</li>
<li>渲染 <code>count</code> 的值 <code>0</code> 到页面中。</li>
</ol>
</li>
<li>点击 +1 按钮：
<ol>
<li>调用 <code>add</code> 方法，从而调用 <code>setCount</code> 方法并传入新的状态 <code>count + 1</code> 即 <code>1</code>。</li>
<li>将新的状态 <code>1</code> 更新给 <code>useState</code> 中的 <code>state</code>，随后<strong>触发重新渲染</strong>。</li>
</ol>
</li>
<li>第二次渲染：
<ol>
<li>从 <code>useState</code> 获取中的 <code>state</code>（此时 <code>state</code> 已更新为 <code>1</code>），将其解构赋值给 <code>count</code>。</li>
<li>渲染 <code>count</code> 的值 <code>1</code> 到页面中。</li>
</ol>
</li>
</ol>
<blockquote>
<p>根据上述分析我们可以得出 <code>useState</code> 中的 <code>setState</code> 有两个作用：</p>
<ol>
<li>更新内部 <code>state</code>；</li>
<li>触发重新渲染。</li>
</ol>
</blockquote>
<p>可以看到，我们渲染的 UI 随着 <code>state</code> 的变化而变化，所以我们需要更新一下我们的核心公式为 <code>UI = f(state)</code>。</p>
<p>同时我们可以看到，在每次点击 +1 按钮后，执行相同的 <code>App</code> 函数会得到不同的结果（count 渲染的值每次都变动了），这是因为通过 <code>useState</code> 访问的 <code>state</code> 其实存储在函数组件外部的 <code>React Fiber</code> 对象上的，此时组件已经不是纯函数组件了，而是<strong>带有副作用的函数组件</strong>。</p>
<h1 id="3-参数-props">3. 参数 Props</h1>
<p>既然函数式组件本质为函数，那么我们理应可以给它传入参数，一般将其称为 <code>props</code> 即外部参数。<code>props</code> 常常用于父子组件之间状态的传递，先看一个例子：</p>
<pre><code class="language-jsx">function Child(props) {
  return &lt;div&gt;child:{props.value}&lt;/div&gt;;
}

function App() {
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      &lt;Child value={count} /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p>上述代码中：我们先是定义一个函数子组件 <code>Child</code>，声明参数 <code>props</code>，然后在返回的 HTML 中渲染 <code>props.value</code>。在父函数组件 <code>App</code> 中，我们调用 <code>Child</code> 组件，并将 <code>count</code> 的值传给 <code>value</code>，写法为：<code>&lt;Child value={count} /&gt;</code>。<br>
可以看到：在父函数传入的 <code>value</code> 属性，它会挂载在一个对象上（<code>props</code>），在子函数中我们通过 <code>props.value</code> 拿到。</p>
<p>当我们点击 +1 按钮时，<code>count</code> 的值发生改变并触发重新渲染，<code>&lt;Child value={count} /&gt;</code>也随之重新渲染， <code>props.value</code> 也随 <code>count</code> 的改变而改变。</p>
<p>至此我可以得知：<code>props</code> 的改变也会间接导致函数组件重新渲染，核心公式更改为： <code>UI = f(state,props)</code>。</p>
<h1 id="4-上下文-usecontext">4. 上下文 useContext</h1>
<p>通过 <code>useState</code> 我们可以使函数式组件拥有自己的内部状态，通过 <code>props</code> 我们可以使得状态在父子组件之间传递。对于组件树中相对位置较远的组件亦或兄弟组件之间，我们可以使用 <code>context</code> 去共享状态，先看一个例子：</p>
<pre><code class="language-jsx">// 创建 Context
const countContext = createContext(0);
// 子组件 A
function ChildA() {
  const count = useContext(countContext);
  return &lt;div&gt;child A:{count}&lt;/div&gt;;
}
// 子组件 B
function ChildB() {
  const count = useContext(countContext);
  return &lt;div&gt;child B:{count}&lt;/div&gt;;
}
// 父组件
function App() {
  const [count, setCount] = useState(0);
  const add = () =&gt; {
    setCount(count + 1);
  };
  return (
    &lt;countContext.Provider value={count}&gt;
      &lt;ChildA /&gt;
      &lt;ChildB /&gt;
      &lt;button onClick={add}&gt;+1&lt;/button&gt;
    &lt;/countContext.Provider&gt;
  );
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<ol>
<li>首先，调用 <code>createContext</code> 创建一个 <code>countContext</code> 上下文。</li>
<li>在父组件 <code>App</code> 中，我们使用 <code>&lt;countContext.Provider value={count}&gt;</code> ，将 <code>count</code> 作为 <code>context</code> 的内容，然后通过 <code>Provider</code> 对包裹在其内部的组件<strong>提供 <code>context</code></strong>。</li>
<li>在子组件 <code>ChildA</code>、<code>ChildB</code> 中我们使用 <code>useContext(countContext)</code> 去<strong>消费 <code>context</code></strong>，此时子组件 <code>count</code> 就是通过 <code>context</code> 共享的父组件的 <code>count</code>。</li>
</ol>
<p>当我们点击 +1 按钮时，<code>App</code> 中 <code>count</code> 的值发生改变，<code>countContext</code> 值随之改变，并触发重新渲染，<code>ChildA</code>、<code>ChildB</code> 中 <code>count</code> 的值随着 <code>countContext</code> 改变而改变。</p>
<p>至此我可以得知：<code>context</code> 的改变也会间接导致函数组件重新渲染，核心公式更改为： <code>UI = f(state,props,context)</code>。</p>
<p>核心公式中 <code>state</code>、<code>props</code>、<code>context</code> 的变动都会更新视图 UI，但其实仔细思考一下就能发现：<code>props</code> 和 <code>context</code> 只不过是充当了 <code>state</code> 的媒介（帮助 <code>state</code> 在组件之间传递和共享），真正意义上 UI 更新还是由 <code>state</code> 的变动引起的。更为切确的说是： <strong><code>setState</code> 在变更 <code>state</code> 的同时触发了重新渲染 <code>re-render</code>（重新执行函数组件）进而导致 UI 视图的变更</strong>。这一点对于理解 Hooks 的作用机制来说非常重要。</p>
<h1 id="5-引用-useref">5. 引用 useRef</h1>
<p><code>useRef(initialValue)</code></p>
<p><code>useRef</code> 返回一个可变的 <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 <code>ref</code> 对象在组件的整个生命周期内保持不变。</p>
<p><code>useRef</code> 和 <code>useState</code> 都可以在函数组件内部存储值（状态），相较于 <code>useState</code> , <code>useRef</code> 可以在函数组件内部更新值而不触发重新渲染。或者你可以简单的将 <code>useRef</code> 理解为变更不触发重新渲染的 <code>useState</code>。我们来看一个例子：</p>
<pre><code class="language-js">function App() {
  const [count, setCount] = useState(0);
  const countRef = useRef(0);

  return (
    &lt;div&gt;
      &lt;div&gt;countRef:{countRef.current}&lt;/div&gt;
      &lt;div&gt;countState:{count}&lt;/div&gt;
      &lt;button onClick={() =&gt; countRef.current++}&gt;change count ref&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;change count state&lt;/button&gt;
    &lt;/div&gt;
  );
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p>上述例子中：</p>
<ul>
<li>当点击 <code>change count ref</code> 按钮时，页面上没有任何变化；</li>
<li>当点击 <code>change count state</code> 按钮时，页面上 <code>countState</code> 的值 +1 ，并且 <code>countRef</code> 的值也发生了变动。</li>
</ul>
<p>值得注意的是：在 <code>countState</code> 变动并且重新渲染的同时，也会把 <code>countRef</code> 当前的值渲染出来。（这里再次解释一下：所谓重新渲染就是再次执行一遍函数（例子中<code>App</code>），在本例中会重新读取 <code>countRef.current</code> 的值然后渲染再页面中。）</p>
<h1 id="6-副作用-useeffect">6. 副作用 useEffect</h1>
<p><code>useEffect</code> 可以让你在函数组件中执行副作用操作。</p>
<h2 id="useeffect-执行顺序">useEffect 执行顺序</h2>
<p><code>useEffect(effect, deps)</code></p>
<p><code>useEffect</code> 的第一个参数为一个函数（我们暂时称其为 <code>effect</code> 函数），<code>effect</code> 函数会在函数组件 <code>App</code> 每次渲染后异步执行，同时 <code>effect</code> 函数可以再返回一个函数（我们一般叫它 <code>cleanup</code> 函数），其将在下一次 <code>effect</code> 函数执行前执行。<code>cleanup</code> 函数一般用于清除 <code>effect</code> 残留的副作用，。</p>
<p><code>useEffect</code> 的执行顺序可以参考下面这个例子：</p>
<pre><code class="language-js">function App() {
  const [count, setCount] = useState(0);
  useEffect(() =&gt; {
    console.log('effect 执行了');
    return () =&gt; {
      console.log('cleanup 执行了');
    };
  });
  const add = () =&gt; {
    console.log('点击按钮');
    setCount(count + 1);
  };
  console.log(`App函数组件 执行了`);
  return (
    &lt;div&gt;
      &lt;div&gt;count:{count}&lt;/div&gt;
      &lt;button onClick={add}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p>控制台打印如下：<br>
<a href="https://imgtu.com/i/HgL5Ed"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a131e00a1b5a47528deabace98200739~tplv-k3u1fbpfcp-zoom-1.image" alt="HgL5Ed.png" loading="lazy"></a><br>
根据打印信息可以得到：</p>
<ul>
<li>第一次渲染时，执行了 <code>effect</code> 函数；</li>
<li>当点击按钮后，触发第二次渲染，先执行 <code>cleanup</code> 函数（第一次渲染 <code>effect</code> 函数返回的函数），再执行 <code>effect</code> 函数。</li>
</ul>
<h2 id="useeffect-依赖数组">useEffect 依赖数组</h2>
<p><code>useEffect</code> 的第二个参数是个依赖数组（<code>deps</code>），在每次渲染后 React 会根据依赖数组来判断是否应该执行 <code>effect</code> 函数。依赖数组 <code>deps</code> 分为一下三种情况讨论：</p>
<ul>
<li><code>deps</code> 为空（不填），每次函数组件渲染都会执行 <code>effect</code> 函数；</li>
<li><code>deps</code> 为 <code>[]</code>，只有在首次函数组件渲染才会执行 <code>effect</code> 函数；</li>
<li><code>deps</code> 为 <code>[dep1,dep2,...]</code>，在首次函数组件渲染，或者任意依赖项（<code>dep1,dep2,...</code>）变动的情况下会执行 <code>effect</code> 函数。</li>
</ul>
<h1 id="7-缓存-usememo-usecallback">7. 缓存 useMemo useCallback</h1>
<p><code>useMemo</code> 和 <code>useCallback</code> 用于 React 的性能优化，通过合理的使用可以避免多余的计算和渲染。</p>
<h2 id="usememo">useMemo</h2>
<p><code>useMemo(fn, deps)</code></p>
<p><code>useMemo</code> 的参数分别是一个创建函数 <code>fn</code> 和一个依赖数组 <code>deps</code>，创建函数需要一个返回值，只有在依赖项发生改变的时候，才会重新调用此函数返回一个新的值。</p>
<p>如果使用过 Vue 的小伙伴肯定知道计算属性 <code>computed</code>，<code>useMemo</code> 的作用与其类似，主要用于缓存需要计算的值（<code>state</code> 的衍生值）。举一个例子：</p>
<pre><code class="language-js">function App() {
  const [list, setList] = useState([1, 1, 1]);
  const listLength = useMemo(() =&gt; {
    return list.length;
  }, [list]);
  return (
    &lt;div&gt;
      &lt;div&gt;{list.map((item) =&gt; item)}&lt;/div&gt;
      &lt;div&gt;listLength:{listLength}&lt;/div&gt;
      &lt;button onClick={() =&gt; setList([...list, 1])}&gt;push&lt;/button&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p><code>listLength</code> 依赖于 <code>list</code> 计算 <code>list</code> 的长度（是状态 <code>list</code> 的衍生值），每次当且仅当 <code>list</code> 变动时，会重新调用 <code>useMemo</code> 的创建函数，返回一个新的 <code>length</code>。</p>
<p>当每次点击 <code>push</code> 时，会调用 <code>setList</code> 导致 <code>list</code> 发生变化，<code>list</code> 的变化导致 <code>listLength</code> 重新计算，所以可以看到 <code>listLength</code> 的值随着 <code>list</code> 同步变化。</p>
<h2 id="usecallback">useCallback</h2>
<p><code>useCallback(fn, deps)</code></p>
<p><code>useCallback</code> 的参数分别是一个创建函数 <code>fn</code> 和一个依赖数组 <code>deps</code>，返回值是创建函数的引用，只有当依赖项变化发生改变的时候，<code>useCallback</code> 才会重新创建函数并返回一个新的引用。</p>
<blockquote>
<p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code></p>
</blockquote>
<p><code>useCallback</code> 最主要的作用就是用于缓存函数的引用，从而避免函数创建时，引用变化所带来的非必要渲染。</p>
<p>千万不要滥用 <code>useCallback</code>，一般来说 <code>useCallback</code> 的应用场景主要有二：</p>
<ol>
<li>函数组件内部定义的函数需要作为其他 Hooks 的依赖。</li>
<li>父组件内部定义的函数需要传递给子组件，并且子组件由<code>React.memo</code>包裹。</li>
</ol>
<blockquote>
<p><code>React.memo</code> 会检查 <code>props</code> 变更，如果 <code>props</code> 未变动，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p>
</blockquote>
<p>场景 1 应该很容易理解，我们主要解释一下场景 2，例子如下：</p>
<pre><code class="language-js">const Child = React.memo(({ onClick }) =&gt; {
  console.log(`Button render`);
  return (
    &lt;div&gt;
      &lt;button onClick={onClick}&gt;child button&lt;/button&gt;
    &lt;/div&gt;
  );
});

function App() {
  const [countA, setCountA] = useState(0);
  const [countB, setCountB] = useState(0);
  // 情况1：未包裹 useCallback
  const onClick = () =&gt; {
    setCountA(countA + 1);
  };
  // 情况2：包裹 useCallback
  const onClick = useCallback(() =&gt; {
    setCountA(countA + 1);
  }, []);
  return (
    &lt;div&gt;
      &lt;div&gt;countA:{countA}&lt;/div&gt;
      &lt;div&gt;countB:{countB}&lt;/div&gt;
      &lt;Child onClick={onClick1} /&gt;
      &lt;button onClick={() =&gt; setCountB(countB + 1)}&gt;App button&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>上例中，<code>Child</code> 子组件由 <code>React.memo</code> 包裹，接收 <code>onClick</code> 函数作为参数。</p>
<ul>
<li>情况 1：<code>onClick</code> 未包裹 <code>useCallback</code> ，当点击 <code>app button</code> 时，触发重新渲染，<code>onClick</code> 重新生成函数引用，导致 <code>Child</code> 子组件重新渲染。</li>
<li>情况 2：<code>onClick</code> 包裹 <code>useCallback</code> ，当点击 <code>app button</code> 时，触发重新渲染，<code>onClick</code> 不会生成新的引用，避免了 <code>Child</code> 子组件重新渲染。</li>
</ul>
<h1 id="参考文档">参考文档</h1>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/getting-started.html">React 官方文档</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker 学习笔记]]></title>
        <id>https://wuwenbang.github.io/post/docker-xue-xi-bi-ji/</id>
        <link href="https://wuwenbang.github.io/post/docker-xue-xi-bi-ji/">
        </link>
        <updated>2022-01-05T08:16:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-docker-初见">1 Docker 初见</h2>
<h3 id="11-docker-是什么">1.1 Docker 是什么</h3>
<ul>
<li>Docker 可以理解成一个超轻量级的虚拟机，专业的说法叫应用<strong>容器</strong>，它是在 LCX（linux 容器）基础上进行的封装。</li>
<li>Docker 和传统虚拟化方式的不同之处在于容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</li>
<li>相较于传统的 VM 虚拟化方法，Docker 的好处是启动速度快，资源利用率高，性能开销小。</li>
</ul>
<h3 id="12docker-的三个概念">1.2.Docker 的三个概念</h3>
<ol>
<li>镜像（Image）：<strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。</li>
<li>容器（Container）：Docker <strong>镜像</strong> 和 <strong>容器</strong> 的关系，就像是面向对象程序设计中的 <strong>类</strong> 和 <strong>实例</strong> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <strong>命名空间</strong>。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。</li>
<li>仓库（Repository）：类似于代码仓库，这里是镜像仓库，是 Docker 用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用 tag 进行区分，比如 Ubuntu 仓库存放有多个版本（12.04、14.04 等）的 Ubuntu 镜像。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://docs.docker.com/engine/images/architecture.svg" alt="Docker Architecture" loading="lazy"></figure>
<h3 id="13-docker-安装">1.3 Docker 安装</h3>
<p>不同系统的 Docker 安装方法可以直接参考 Docker 官方安装教程：<a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a></p>
<h2 id="2-docker-容器">2 Docker 容器</h2>
<h3 id="21-容器-操作命令">2.1 容器 操作命令</h3>
<h4 id="创建容器">创建容器</h4>
<p>首先让我们来创建一个新容器，创建容器的命令是：</p>
<pre><code>docker run &lt; image_name &gt;
</code></pre>
<p><code>image_name</code> 代表一个镜像名称，例如你可以创建一个 nginx 容器，就像这样：</p>
<pre><code>docker run nginx
</code></pre>
<p>输入完成后，直接回车。如果系统中没有这个镜像，Docker 会自动去 Docker Hub 上拉取对应的镜像（最新版本）到本地，然后执行对应的 Shell 脚本，脚本会把镜像自动安装到 Docker 容器里，并最终启动对于的镜像服务（注意，这时候容器是在前台运行的）。</p>
<blockquote>
<p>Docker Hub 是 Docker 官方的镜像和社区，里边有很多开发者制作好的镜像，我们可以直接使用这些镜像。如果你有能力，也可以制作镜像，并上传到 Docker Hub。</p>
</blockquote>
<h4 id="查看容器">查看容器</h4>
<p>创建完容器后，如果想查看这个容器的信息和状态，你可以再打开一个新的终端，然后可以使用下面的命令：</p>
<pre><code>docker ps
</code></pre>
<p>然后你就可以看到如下信息：</p>
<pre><code>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
4b2410514c51   nginx     &quot;/docker-entrypoint.…&quot;   8 seconds ago   Up 7 seconds   80/tcp    nice_ritchie
</code></pre>
<p>这些信息对应的含义如下表：</p>
<table>
<thead>
<tr>
<th>信息</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONTAINER ID</td>
<td>容器对应的唯一 ID</td>
</tr>
<tr>
<td>IMAGE</td>
<td>镜像名称</td>
</tr>
<tr>
<td>COMMAND</td>
<td>执行的相关命令</td>
</tr>
<tr>
<td>CREATED</td>
<td>创建的时间</td>
</tr>
<tr>
<td>STATUS</td>
<td>当前镜像的状态（Up 为运行中，Exited 为退出）</td>
</tr>
<tr>
<td>PORTS</td>
<td>协议和端口</td>
</tr>
<tr>
<td>NAMES</td>
<td>容器的名称（不指定的话 Docker 会随机生成）</td>
</tr>
</tbody>
</table>
<h4 id="停止容器">停止容器</h4>
<p>如果你想停止掉一个正在运行的容器，可以使用下面的命令：</p>
<pre><code>docker stop &lt;container_id&gt;
</code></pre>
<p>当容器停止后，再使用查看命令进行查看，你会发现没有任何容器。</p>
<pre><code>docker ps
</code></pre>
<p>这是因为普通的 <code>ps</code> 指令只会查看正在运行的容器，这时候你要查看你所有容器，包含已经停止的容器，可以加一个 <code>-a</code> 参数。</p>
<pre><code>docker ps -a
</code></pre>
<h4 id="删除容器">删除容器</h4>
<p>当我们停止容器之后，容器并没有删除，而只是停止掉了。这时候你可以使用下面的命令删除容器。</p>
<pre><code>docker rm &lt;container_id&gt;
</code></pre>
<p>正在运行的容器是无法直接删除的，你可以是强制删除指令进行删除：</p>
<pre><code>docker rm -f &lt;container_id&gt;
</code></pre>
<h3 id="22-容器-attached-和-detached-模式">2.2 容器 attached 和 detached 模式</h3>
<p>两种模式最简单的对比理解就是：<code>attached</code> 模式在<strong>前台运行</strong><code>，detached</code> 模式在<strong>后台运行</strong>。</p>
<h4 id="attached-模式">attached 模式</h4>
<p>我们现在先用 Docker 创建一个 Nginx 容器，并把它映射在服务器的 80 端口，运行如下命令：</p>
<pre><code>docker run nginx
</code></pre>
<p>这个时候你会发现你的命令行（Terminal）上打印出了相关的日志（log）。也就是说 Docker 容器的日志会实时的展现到窗口并且占用此端口。这种模式叫做 <code>attached</code> 模式。</p>
<p>如果这时候你按 Ctrl+C ，就会停止掉 Docker 服务。也就是在 Linux 上你的操作命令，会直接传递给 Docker 容器。这个缺点就是很容易误操作，你随便 Ctrl+C 一下整个服务就崩掉了。</p>
<p>所以我们需要一个更好的，更稳定的模式。也就是 <code>detached</code> 模式。<code>attached</code> 模式更适用于容器和程序的调试阶段。</p>
<h4 id="detached-模式">detached 模式</h4>
<p><code>detached</code> 模式的开启方法，就是加一个参数 <code>-d</code> 或者 <code>--detach</code>。</p>
<pre><code>docker run -d nginx
</code></pre>
<p>这次你会看到，和 <code>attached</code> 模式不同的是，这次输入完命令后，只显示出了容器的编号，并且可以再输入任何命令。就算我们关掉窗口，容器依然运行，也就是他是在系统后台进行运行的。我们可以通过输入命令 <code>docker ps</code> 查看，发现刚刚启动的 Nginx 服务正在后台运行中。</p>
<p>这种就比较适合在生产环境中运行，停掉和删除容器都需要使用 Shell 脚本的形式。减少了很多误操作。</p>
<p>如果你想在 <code>detached</code> 模式下查看日志，你可以使用以下命令：</p>
<pre><code>docker container logs &lt;container_id&gt;
</code></pre>
<h4 id="detached-模式转换-attached-模式">detached 模式转换 attached 模式</h4>
<p>在运行之后，也有需要调试的时候，Docker 提供了两个模式间的转换。比如现在要把 <code>detached</code> 模式的容器，改为 <code>attached</code> 模式。我们可以输入一下命令：</p>
<pre><code>docker logs &lt;container_id&gt;
</code></pre>
<p>虽然日志在窗口中出现了，但只打印一次 logs，如果想动态一直跟踪日志，可以在命令上加入一个 <code>-f</code>。</p>
<pre><code>docker logs -f &lt;container_id&gt;
</code></pre>
<h4 id="docker-端口映射">Docker 端口映射</h4>
<p>如果想在浏览器上访问刚刚启动的 Nginx 服务，我们就需要做端口映射，在开启端口映射之前，你首先要之道 Docker 对应的容器端口是多少。比如 Nginx 镜像的端口是 80。知道这个端口后，就可以在启动容器的时候，用<code>-p &lt;port:port&gt;</code> 的形式，启用映射了。</p>
<pre><code>docker run -p 80:80 nginx
</code></pre>
<p>等待项目启动后，打开浏览器窗口，在地址栏输入 127.0.0.1 或 localhost（默认指向 80 端口），就可以打开 Nginx 的默认网址。</p>
<p>第一个端口是映射到服务器本机的端口; 第二个端口是 Docker 容器使用的端口。 比如你想把 Docker 的 80 端口，映射到服务器的 90 端口。</p>
<pre><code>docker container run -p 90:80 nginx
</code></pre>
<h3 id="23-容器-交互模式">2.3 容器 交互模式</h3>
<p>有时候容器的镜像不是简单的一个服务，而是需要交互的操作系统。例如创建一个 Ubuntu 系统，然后需要到系统里输入各种 Shell 命令和系统进行交互。这时候 attached 模式和 detached 模式就不能满足要求了。需要使用交互模式。</p>
<h4 id="使用-ubuntu-镜像并开启交互模式">使用 Ubuntu 镜像并开启交互模式</h4>
<pre><code>docker run -it ubuntu sh
</code></pre>
<p><code>-it</code> 代表启用交互模式，<code>sh</code> 代表可以使用 Shell 脚本。当你输入玩这个脚本后，Docker 就会进入到交互模式。可以使用 <code>ls</code> 来得到目录下的文件。</p>
<p>这时候你想退出容器和交互模式可以输入 <code>exit</code> 命令。需要重点说明的是，随着命令退出后，容器也会跟着退出，变成 <code>Exited</code> 模式。</p>
<h4 id="detached-模式下的交互">detached 模式下的交互</h4>
<p>如果我们想退出交互，但是并不想停止容器。可以先开启 detached 模式，然后通过命令进入交互模式。</p>
<p>先用 <code>detached</code> 模式创建一个 nginx 镜像的容器。</p>
<pre><code>docker run -d -p 80:80 nginx
</code></pre>
<p>然后直接通过下面的命令就可以进入到交互模式下了（这是我们以后要经常使用的一个命令）。</p>
<pre><code>docker exec -it &lt;container_id&gt; sh

</code></pre>
<p><code>exec</code> 是执行的意思，<code>-it</code>交互模式， <code>sh</code> 交互的方式，用 shell 脚本进行交互。<br>
整个命令的意思是：用 shell 脚本的方式执行交互模式。</p>
<p>进入后可以使用 <code>ls</code> 来查看容器的文件系统。</p>
<p>这种模式的优点是，再使用 exit（或者 Ctrl+D）退出后，服务并不会停止，而只是退出了交互模式。可以自己尝试一下退出，然后使用 <code>docker container ls -a</code> 来查看一下容器的状态，你会发现依然是 <code>up</code> 状态。</p>
<h2 id="3-docker-镜像">3 Docker 镜像</h2>
<p>镜像是 Docker 里最重要的一个知识点，如果你只会创建容器和使用官方的镜像，并不能算是 Docker 的高手或者是专业选手，只能说会使用 Docker。而制作镜像文件，并让广大网友使用，才是每个 Docker 人的追求。</p>
<h3 id="31-镜像-基本操作">3.1 镜像 基本操作</h3>
<h4 id="获取镜像的三种方式">获取镜像的三种方式</h4>
<ol>
<li>从网络社区直接拉取，在 Docker 里这种社区叫做 Registry（登记处）。</li>
<li>从 Dockerfile 构建一个镜像，这种像是 DIY 一个镜像，但是整个构建过程是需要联网，因为需要西在基础镜像，然后根据基础镜像进行构建（build from Dockerfile）。</li>
<li>自有文件的导入，可以从本地导入已经构建好的镜像文件，在没有网络的时候可以用。这个文件是通过 已有的镜像导出来的压缩包，然后就可以进行使用了。</li>
</ol>
<h4 id="镜像社区image-registry">镜像社区（Image registry）</h4>
<p>镜像社区也叫做 Image registry（镜像登记处），是拉取和下载镜像的网站，你也可以通过 Dockerfile 制作镜像，让所有人使用，类似 Docker Image 专属的简单版 GitHub。</p>
<ul>
<li>dockerhub：网址- https://hub.docker.com/ ,Docker 官方社区，在使用 Docker 时默认的拉取网站。</li>
</ul>
<h4 id="拉取镜像">拉取镜像</h4>
<p>我们先尝试从 Dockerhub 上拉取 nginx 镜像：</p>
<pre><code class="language-bash">docker image pull nginx
# 可以简写为：
docker pull nginx
</code></pre>
<p>如果是第一次拉取镜像，则需要下载很多依赖的基础镜像。具体快慢会和网速有关。这里给出第一次拉取 nginx 的日志信息。</p>
<pre><code class="language-bash">% docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
5eb5b503b376: Pull complete
1ae07ab881bd: Pull complete
78091884b7be: Pull complete
091c283c6a66: Pull complete
55de5851019b: Pull complete
b559bad762be: Pull complete
Digest: sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest

</code></pre>
<p>上面命令的第二行 tag 的意思就是版本,latest 代表的是最新版。因为这里并没有给版本号，你可以加入版本号进行下载的。到 dockerhub 上可以找到对应的版本号。比如我们要下载 wordpress 1.20 版本，就可以输入下面的命令。</p>
<pre><code class="language-bash">docker pull nginx:1.20
</code></pre>
<h4 id="查看镜像">查看镜像</h4>
<ul>
<li>查看镜像列表</li>
</ul>
<pre><code class="language-bash">docker image ls
</code></pre>
<p>通过这条命令就可以查看 Docker 中有的镜像和相关信息。</p>
<ul>
<li>查看具体镜像信息</li>
</ul>
<pre><code class="language-bash">docker image inspech &lt;image_id&gt;
</code></pre>
<p>通过这条命令就可以查看具体某个镜像的详细信息。</p>
<h4 id="删除镜像">删除镜像</h4>
<ul>
<li>删除单个镜像</li>
</ul>
<pre><code class="language-bash">docker image rm &lt;image_id&gt;
</code></pre>
<p>需要注意的是，当有容器在使用镜像时，是没有办法被删除的。即使容器是停止掉的，依然是没办法删除的。</p>
<ul>
<li>删除所有未被容器使用的镜像</li>
</ul>
<pre><code class="language-bash">docker image prune -a
</code></pre>
<p>prune（修剪） 命令用来删除不再使用的 docker 对象。</p>
<h4 id="导出镜像">导出镜像</h4>
<pre><code class="language-bash">docker image save
</code></pre>
<p>在导出之前，你最好到一个好找的路径下面（比如 Desktop 目录），使用 mkdir 命令创建一个文件夹，进入文件后输入下面的命令。比如现在要导出镜像中的 nginx 镜像，可以这样写命令。</p>
<pre><code class="language-bash">docker image save nginx:latest -o my_nginx.image
</code></pre>
<p>解读上面的命令：<code>save</code> 是导出/保存的意思，<code>nginx:latest</code> 是镜像名称+版本号， <code>-o</code> 代表输出，<code>my_nginx.image</code> 是导出后镜像的名字。</p>
<p>命令执行完成后，可以看到在执行命令所在的目录下就会多出一个 <code>my_nginx.image</code> 的文件，这就是刚才导出的镜像了。</p>
<h4 id="导入镜像">导入镜像</h4>
<p>先删除掉本机已有的 <code>nginx</code> 镜像。</p>
<pre><code class="language-bash">docker image rm nginx
</code></pre>
<p>删除后直接导入镜像。</p>
<pre><code class="language-bash">docker image load -i .\my_nginx.image
</code></pre>
<p>执行完命令之后，再使用 <code>docker image ls</code> 命令查看，<code>nginx</code> 镜像已经回来了。</p>
<h3 id="32-镜像-dockerfile-构筑镜像">3.2 镜像 Dockerfile 构筑镜像</h3>
<h4 id="初识-dockerfile">初识 Dockerfile</h4>
<p>已经讲了两种获取 Docker 镜像的方式，第一种是直接从 Registry 中拉去，第二种是自己导入导出镜像。接下来是第三种获得镜像的方法：通过 <code>Dockerfile</code> 来 DIY 制作镜像。</p>
<p>通过 Dockerfile 构建镜像虽然比较麻烦，这是最常使用的一种方式，必须掌握。它的知识点非常多，后期准备专门出一篇文章来讲解这个 Dockerfile 的使用、语法和注意问题。</p>
<p>什么是 Dockerfile ？</p>
<blockquote>
<p>Dockerfile 是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker 通过读取 Dockerfile 中的指令自动生成映像。</p>
</blockquote>
<p>可以简单总结为下面三点：</p>
<ul>
<li>Dockerfile 是用于构建 <code>docker镜像</code> 的文件。</li>
<li>Dockerfile 里包含了构建镜像所需的<strong>指令</strong>。</li>
<li>Dockerfile 有其特定的<strong>语法规则</strong>（重要学习）。</li>
</ul>
<h4 id="第一个-dockerfile-demo">第一个 Dockerfile Demo</h4>
<p>有这样一个需求：制作一个镜像。镜像拥有一个 <code>nodejs</code> 环境，然后在系统上运行 <code>hello.js</code> 程序。JS 程序的内容非常简单，只要打印出 <code>Hello Docker!</code>，就可以了。这个需求可以分为一下几个步骤去实现：</p>
<ol>
<li>第一步，下载一个 Node 环境。</li>
<li>第二步，准备 <code>hello.js</code> 文件。我们可以在 <code>Desktop</code> 目录下新建一个 <code>DockerTest</code> 文件夹，然后在文件夹中新建一个 <code>hello.js</code> 文件，然后编写下面的文件。</li>
</ol>
<pre><code class="language-js">console.log('Hello Docker!');
</code></pre>
<ol start="3">
<li>第三步，运行 <code>hello.js</code>。</li>
</ol>
<pre><code class="language-bash">node hello.js
Hello Docker!
</code></pre>
<p>有了以上的步骤，我们就可以开始编写 <code>Dockerfile</code> 文件了：</p>
<pre><code class="language-dockerfile">FROM node
ADD hello.js /
CMD [&quot;node&quot;,&quot;hello.js&quot;]
</code></pre>
<p>这算是最简单的一个 <code>Dockerfile</code> 文件的编写，有了这个文件之后，就可以通过 <code>Dockerfile</code> 来构建一个镜像了。</p>
<p>当有了 <code>Dockerfile</code> 和 <code>hello.js</code> 文件以后，通过命令行进入 <code>DockerTest</code> 文件夹。通过 Docker 命令就可以完成镜像的构建：</p>
<pre><code class="language-bash">docker image build -t &lt;name:tag&gt; &lt;file_path&gt;
</code></pre>
<p>例如现在要通过已经写好的 <code>Dockerfile</code>，构建一个 <code>hello</code> 的镜像，就可以使用下面的命令构建。</p>
<pre><code class="language-bash">docker image build -t hello .
</code></pre>
<p>（注意命令最后是有一个<code>.</code>的），如果你是第一次执行打包，这个过程还是需要 2-3 分钟的，当出现 <code>FINISHED</code> 后，说明打包完成了。</p>
<p>打包完成后，可以通过 <code>docker image ls</code> 命令来查看现在拥有的镜像列表。如果一切正常，你应该可以看到名字为 <code>hello</code> 的镜像已经存在了。</p>
<p>可以执行容器，验证一下自己 DIY 的镜像是否可用。</p>
<pre><code class="language-bash">docker run node

</code></pre>
<p>镜像如果正常，应该正确现实出 <code>Hello Docker</code> 字样，然后就直接退出容器了。这是跟我们写的 <code>Dockerfile</code> 有关的。</p>
<h3 id="33-镜像-dockerhub-分享镜像">3.3 镜像 Dockerhub 分享镜像</h3>
<p>这一章节我们要把镜像 <code>push</code> 到 <code>dockerhub</code> 上去，这样就可以让所有人进行使用了。想要分享镜像，需要做到一下几步：</p>
<p>第一步，申请了一个账号，例如账号名为 <code>prayx</code> ，所以在点开 <code>Profile</code> 时是没有任何镜像的。</p>
<p>第二步，如果你想上传属于自己的镜像，需要遵守社区规则，就是 <code>用户ID/镜像名称</code>。可以最简单的方法，就是重新 build 一个镜像，镜像名称符合社区规则就可以了。</p>
<pre><code class="language-bash">docker image build -t prayx/hello .
</code></pre>
<p>这时候就会生成一下新的镜像，但是 <code>Image ID</code> 是一摸一样的。</p>
<p>也可以通过 <code>docker image tag</code> 命令，具体语法如下：</p>
<pre><code class="language-bash">docker image tag &lt;old_image_name&gt; &lt;new_iamge_name&gt;

</code></pre>
<p>例如把 hello 这个镜像，改为 prayx/hello 镜像,命令可以如下：</p>
<pre><code class="language-bash">docker image tag hello prayx/hello
</code></pre>
<p>在推送前，需要先登录 Dockerhub 账号,登录命令如下：</p>
<pre><code class="language-bash">docker login
</code></pre>
<p>执行命令好，会要求输入 <code>Username</code>，也就你 <code>Dockerhub ID</code>，还需要输入密码。如果输入正确，并出现 <code>Login Succeeded</code> 就证明登录成功了。</p>
<pre><code class="language-bash">docker image push Name[:TAG]
</code></pre>
<p>比如就是把刚才的 <code>prayx/hello</code> 镜像 <code>push</code> 到社区，就可以使用下面的命令。</p>
<pre><code class="language-bash">docker image push prayx/hello
</code></pre>
<p>输入完命令，就会给我们进行 <code>push</code> 到 <code>Dockerhub</code> 上了。这时候你可以到 <code>Dockerhub</code> 的 <code>profile</code> 页面，刷新一下，就可以看到刚刚 <code>push</code> 上去的镜像。</p>
<h2 id="4-dockerfile">4 Dockerfile</h2>
<h3 id="41-dockerfile-from-指令">4.1 Dockerfile FROM 指令</h3>
<p>还记得上一章节，我们写的 Dockerfile 文件吗？</p>
<pre><code class="language-dockerfile">FROM node
ADD hello.js /
CMD [&quot;node&quot;,&quot;hello.js&quot;]
</code></pre>
<p>第一句就是 <code>FROM node</code>，它的意思是选择一个基础镜像，我这里选择的是带最新版本 Node 的 Linux 系统。等价于 <code>FROM node:latest</code>。如果想选择固定版本的只需要在<code>:</code>后面加上版本号：<code>FROM node:16</code>。</p>
<p>使用 <code>Dockerfile</code> 定制镜像，就需要是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>node</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 基础镜像，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。<br>
在 <code>Docker Hub</code> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>httpd</code>、<code>php</code>、<code>tomcat</code> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如<code>node</code>、<code>openjdk</code>、<code>python</code>、<code>ruby</code>、<code>golang</code> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。<br>
如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <code>ubuntu</code>、<code>debian</code>、<code>centos</code>、<code>alpine</code> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。<br>
除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<pre><code class="language-Dockerfile">FROM scratch
...
</code></pre>
<h4 id="选择基础镜像的三个原则">选择基础镜像的三个原则</h4>
<ol>
<li>官方镜像优于非官方的镜像。</li>
<li>固定版本的 Tag，而不是每次都使用 latest。</li>
<li>功能满足的前提下，选择体积小的镜像。</li>
</ol>
<h3 id="42-dockerfile-run-指令">4.2 Dockerfile RUN 指令</h3>
<p><code>RUN</code> 是 Dockerfile 中一个重要的指令，它可以执行 <code>Shell</code> 指令，包括下载文件、安装软件、配置环境.....都是可以的。</p>
<p>例如我们先选定 <code>Ubuntu</code> 作为我们基础镜像，纯净的 <code>Ubuntu</code> 系统是没有 <code>ipinfo</code> 命令的，在安装完系统后，都会安装 <code>ipinfo</code> 命令。步骤如下：</p>
<pre><code class="language-bash">$ apt-get update
$ apt-get install wget
$ wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz
$ tar zxf ipinfo_2.0.1_linux_amd64.tar.gz
$ mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo
$ rm -rf ipinfo_2.0.1_linux_amd64.tar.gz
</code></pre>
<blockquote>
<p>上面这段代码需要你会一些 Linux 的基本操作，其实就是安装，解压和删除下载文件的一个过程。</p>
</blockquote>
<h4 id="不建议的-dockerfile-写法">不建议的 Dockerfile 写法</h4>
<p>如果用 <code>RUN</code> 命令来编写，直接可以写成下面的样子。</p>
<pre><code class="language-Dockerfile">FROM ubuntu:latest
RUN apt-get update
RUN apt-get install -y wget
RUN wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz
RUN tar zxf ipinfo_2.0.1_linux_amd64.tar.gz
RUN mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo
RUN rm -rf ipinfo_2.0.1_linux_amd64.tar.gz
</code></pre>
<p>Dockerfile 中每一个指令都会建立一层（image layer），<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>上面的这种写法，创建了 6 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>
<h4 id="建议的-dockerfile-写法">建议的 Dockerfile 写法</h4>
<p>把所有执行命令放到一个 <code>RUN</code> 里，并用<code>&amp;&amp; \</code>进行连接。就可以把很多命令写到一个 <code>RUN</code> 里边了。</p>
<pre><code class="language-Dockerfile">FROM ubuntu:latest
RUN apt-get update &amp;&amp; \
    apt-get install -y wget &amp;&amp; \
    wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \
    tar zxf ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \
    mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo &amp;&amp; \
    rm -rf ipinfo_2.0.1_linux_amd64.tar.gz
</code></pre>
<p>这样所有的 <code>RUN</code> 命令只生成一层 <code>image layer</code>。打包出来的镜像也没有那么大了。</p>
<h3 id="43-dockerfile-文件操作">4.3 Dockerfile 文件操作</h3>
<p>制作镜像的时候，经常需要向镜像里添加文件。在 <code>Dockerfile</code> 中有两个命令可以向镜像中添加文件 <code>COPY</code> 和 <code>ADD</code>。这节我们聊一下这两个命令，并重点了解一下两个命令的不同。</p>
<h4 id="用-copy-命令构建镜像">用 COPY 命令构建镜像</h4>
<p>现在我们写一个 <code>Dockerfile</code>，里边的内容是用基础 <code>Node</code> 镜像，然后拷贝一个 <code>index.js</code> 文件进去。</p>
<p>Dockerfile.copy 内容如下:</p>
<pre><code class="language-Dockerfile">FROM node:16
COPY index.js  /app/index.js
</code></pre>
<p>引用 <code>node</code> 16 版本，然后把 <code>index.js</code> 文件，拷贝到 <code>app</code> 目录下面。</p>
<p><code>index.js</code> 文件如下。代码是我们在 3000 端口上，开启了一个最简单 web 服务，然后返回了 <code>Hello Nodejs</code> 两个单词。</p>
<pre><code class="language-js">//1. 导入 http 模块
const http = require('http');
//2. 创建服务器对象
const server = http.createServer();
//3. 开启服务器
server.listen(3000, () =&gt; {
  console.log('Server is running...');
});
//4. 监听浏览器请求并进行处理
server.on('request', (req, res) =&gt; {
  // end方法能够将数据返回给浏览器，浏览器会显示该字符串
  res.end('Hello Nodejs');
});
</code></pre>
<p>两个文件准备好以后，用 <code>build</code> 命令进行构建。</p>
<pre><code class="language-Dockerfile">docker image build -f Dockerfile.copy -t hello-copy .
</code></pre>
<p>构建完成后，可以使用 <code>docerk image ls</code> 命令进行查询。生成成功后，可以启用交互模式，再加上映射端口的形式，运行容器。</p>
<pre><code class="language-bash">docker container run -it -p 3000:3000 hello-copy sh
</code></pre>
<p>这里映射了 <code>3000</code> 端口，这样我们就可以用 <code>127.0.0.1:3000</code> 进行访问了。</p>
<h4 id="用-add-构筑镜像">用 ADD 构筑镜像</h4>
<p><code>ADD</code> 构建镜像和 <code>COPY</code> 最直观的一点不同，是 <code>ADD</code> 命令可以直接解压 <code>gzip</code> 压缩文件，这当我们有很多文件要上传操作的时候，就会变的简单很多。</p>
<p>Dockerfile.add 文件内容：</p>
<pre><code class="language-Dockerfile">FROM node:alpine3.14
ADD index.tar  /app/
</code></pre>
<p>用 <code>ADD</code> 命令进行打包镜像</p>
<pre><code class="language-bash">docker image build -f Dockerfile.add -t hello-gzip .
</code></pre>
<p>打包好以后使用交互模式，开启容器。</p>
<pre><code class="language-bash">docker container run -it -p 3000:3000 hello-gzip sh
</code></pre>
<p>再进入 <code>app</code> 路径下面，可以看到下面自动给我们解压了 <code>index.tar</code> 文件。</p>
<h4 id="workdir-切换工作目录">WORKDIR 切换工作目录</h4>
<p>在写 <code>Dockerfile</code> 文件时，默认的操作目录，是镜像的根目录。但有时候需要拷贝很多内容到镜像里是二级目录，就可以使用 <code>WORKDIR</code> 命令。把工作目录切换到二级，<code>WORKDIR</code> 命令像我们操作 <code>linux</code> 下的 <code>cd</code> 命令。</p>
<p>比如还是刚才的 <code>Dockerfile.add</code> 文件，我们可以使用 WORKDIR 命令，改成下面的形式。</p>
<pre><code class="language-Dockerfile">FROM node:alpine3.14
WORKDIR /app
ADD index.tar index.js
</code></pre>
<p>这时候进入系统后的工作目录，就是在 <code>/app</code> 下面了。</p>
<h3 id="44-dockerfile-arg-与-env-指令">4.4 Dockerfile ARG 与 ENV 指令</h3>
<p><code>ARG</code> 和 <code>ENV</code> 是经常容易被混淆的两个 <code>Dockerfile</code> 语法，它们都可以用来设置一个【变量】。但其实两个语法在细节上有很多不同。</p>
<p>还记得之前我们写过一个默认安装 <code>ipinfo</code> 的 <code>ubuntu</code> 系统吗，其 Dockerfile 文件如下：</p>
<pre><code class="language-Dockerfile">FROM ubuntu:latest
RUN apt-get update &amp;&amp; \
    apt-get install -y wget &amp;&amp; \
    wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \
    tar zxf ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \
    mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo &amp;&amp; \
    rm -rf ipinfo_2.0.1_linux_amd64.tar.gz
</code></pre>
<p>这段文件里有 <code>ipinfo</code> 的版本是 <code>ipinfo-2.0.1</code>,这个版本是有可能改变的。文件里一共出现了 5 次 <code>2.0.1</code>，修改起来已经比较麻烦了，如果出现更多次，几乎变的不可维护。所以这时候就需要定义一个变量，方便日后的维护。</p>
<h4 id="env-定义变量">ENV 定义变量</h4>
<p>先用 <code>ENV</code> 的形式来修改变量，把上面的 <code>Dockerfile.ENV</code> 文件修改为下面的形式（这里有个小坑需要给大家说一下，就是注意在写变量时，值不要有任何的空格，否则在打包时会失败。）</p>
<pre><code class="language-Dockerfile">FROM ubuntu:latest
ENV VERSION=2.0.1
RUN apt-get update &amp;&amp; \
    apt-get install -y wget &amp;&amp; \
    wget https://github.com/ipinfo/cli/releases/download/ipinfo-${VERSION}/ipinfo_${VERSION}_linux_amd64.tar.gz &amp;&amp; \
    tar zxf ipinfo_${VERSION}_linux_amd64.tar.gz &amp;&amp; \
    mv ipinfo_${VERSION}_linux_amd64 /usr/bin/ipinfo &amp;&amp; \
    rm -rf ipinfo_${VERSION}_linux_amd64.tar.gz
</code></pre>
<p>这样写之后，如果以后版本改变了，我们只要修改一处，就可以完成所有的修改了。</p>
<p>我们现在来构建一下这个 ENV 的镜像。</p>
<pre><code class="language-bash">docker image build -f Dockerfile.ENV -t ipinfo-env .
</code></pre>
<h4 id="arg-定义变量">ARG 定义变量</h4>
<p>跟上面的方法一样用 <code>ARG</code> 定义变量效果是一样。只是把 <code>ENV</code> 换成了 <code>ARG</code>。这个文件是 <code>Dockerfile.ARG</code>，内容如下：</p>
<pre><code class="language-Dockerfile">FROM ubuntu:latest
ARG VERSION=2.0.1
RUN apt-get update &amp;&amp; \
    apt-get install -y wget &amp;&amp; \
    wget https://github.com/ipinfo/cli/releases/download/ipinfo-${VERSION}/ipinfo_${VERSION}_linux_amd64.tar.gz &amp;&amp; \
    tar zxf ipinfo_${VERSION}_linux_amd64.tar.gz &amp;&amp; \
    mv ipinfo_${VERSION}_linux_amd64 /usr/bin/ipinfo &amp;&amp; \
    rm -rf ipinfo_${VERSION}_linux_amd64.tar.gz
</code></pre>
<p>我们可以通过命令来构建一下 <code>ARG</code> 的镜像：</p>
<pre><code class="language-bash">docker image build -f `Dockerfile.ARG -t` ipinfo-arg .
</code></pre>
<h4 id="env-和-arg-的不同点">ENV 和 ARG 的不同点</h4>
<p>总的来说 ARG 和 ENV 有两点不同，第一点是声明变量的作用域不同，第二点是 ARG 声明后，可以在构建时修改变量。</p>
<ol>
<li>ARG 是构建环境，ENV 可带到镜像中</li>
</ol>
<p>用交互模式进入到 ipconfig-env 镜像中，然后输入 env 可以看到当前镜像的信息。</p>
<pre><code class="language-bash">docker container run -it ipinfo-env
</code></pre>
<p>然后输入 <code>env</code>，可以看到里边是会有 <code>VERSION</code> 变量的。</p>
<ol start="2">
<li>ARG 可以在构建镜像时改变变量值</li>
</ol>
<p>在构建时，可以使用 <code>—build-arg</code> 参数来更改变量的值，比如现在要把变量 <code>VERSION</code> 的值进行修改,就可以使用下面的命令。</p>
<pre><code class="language-bash">docker image build -f Dockerfile.ARG -t ipinfo-arg-2.0.0 --build-arg VERSION=2.0.0 .
</code></pre>
<p>这时候我们再使用交互模式，开启 <code>ipinfo-arg-2.0.0</code> 容器。</p>
<pre><code class="language-bash">docker container run -it ipinfo-arg-2.0.0

</code></pre>
<p>然后再通过 <code>shell</code> 命令，<code>ipinfo verison</code> 查看 <code>ipinfo</code> 的版本，可以看到版本已经变成了 <code>2.0.0</code> 了。</p>
<h3 id="45-dockerfile-cmd-与-entrypoint-指令">4.5 Dockerfile CMD 与 ENTRYPOINT 指令</h3>
<h4 id="cmd-容器启动命令">CMD 容器启动命令</h4>
<p><code>CMD</code> 指令的格式有一下两种：</p>
<ul>
<li><code>shell</code>格式：<code>CMD &lt;命令&gt;</code></li>
</ul>
<pre><code class="language-Dockerfile">CMD node hello.js
</code></pre>
<ul>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数 1&quot;, &quot;参数 2&quot;...]</code></li>
</ul>
<pre><code class="language-Dockerfile">CMD [&quot;node&quot;,&quot;hello.js&quot;]
</code></pre>
<p><code>CMD</code> 命令在使用时，有三个基本原则需要我们遵守。</p>
<ul>
<li>容器启动时默认执行的命令</li>
<li>如果<code>docker container run</code> 启动容器时指定了其它命令，则 <code>CMD</code> 命令会被忽略</li>
<li>如果定义多个 <code>CMD</code>，只有最后一个 <code>CMD</code> 执行</li>
</ul>
<h4 id="entrypoint-入口点">ENTRYPOINT 入口点</h4>
<p><code>ENTRYPOINT</code> 的格式和 <code>CMD</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，<br>
需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。<br>
当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，<br>
换句话说实际执行时，将变为：</p>
<pre><code class="language-bash">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;
</code></pre>
<h2 id="5-docker-compose">5 Docker Compose</h2>
<h3 id="51-docker-compose-介绍">5.1 Docker Compose 介绍</h3>
<p>熟悉 <code>Linux</code> 都知道，我们可以把很多相关的命令写成一个 <code>xxx.sh</code> 文件，而且这些步骤也是相对固定的。</p>
<p>这样直接运行 <code>sh</code> 文件，就可以逐一执行很多相关的 <code>Docker</code> 命令。这种形式可以减少出错和解决复用问题。<code>Docker</code> 很贴心的为我们准备了一个专门的工具 <code>docker-compose</code>，实现类似 <code>sh</code> 文件的功能。让我们更加轻松的实现多 <code>Docker</code> 命令的操作。</p>
<p>你也可以把 <code>docker-compose</code> 就是把很多 <code>Docker</code> 命令写入一个专属的文件 <code>docker-compose.yml</code>，然后执行这个文件，就可以直接启动我们想要的容器。<code>docker-compose</code> 也为我们提供了对应的操作命令: <code>docker-compose up</code> 、<code>docker-compose stop</code>。</p>
<p>也就是说，操作 <code>docker-compose</code> 会有两个大的部分需要操作:</p>
<ul>
<li>第一部分：编写 <code>docker-compose.yml</code> 文件。</li>
<li>第二部分：输入相关的命令构筑容器。</li>
</ul>
<h3 id="52-docker-compose-文件结构">5.2 Docker Compose 文件结构</h3>
<h4 id="yaml-文件的基础结构">yaml 文件的基础结构</h4>
<p>基本的 <code>docker-compose.yml</code> 文件格式如下：</p>
<pre><code class="language-yml">version: '3.8'

services: # 容器
  servicename: # 服务名字，这个名字也是内部 bridge 网络可以使用的 DNS name
    image: # 镜像的名字
    command: # 可选，如果设置，则会覆盖默认镜像里的 CMD命令
    environment: # 可选，相当于 docker run里的 --env
    volumes: # 可选，相当于docker run里的 -v
    networks: # 可选，相当于 docker run里的 --network
    ports: # 可选，相当于 docker run里的 -p
  servicename2:

volumes: # 可选，相当于 docker volume create

networks: # 可选，相当于 docker network create
</code></pre>
<p>下面我们以一个 <code>wordpress</code> 的镜像为例，制作 <code>yaml</code> 文件。</p>
<ul>
<li>用 <code>Docker</code> 命令的写法：</li>
</ul>
<pre><code class="language-bash">docker container run -d -p 80:80 wordpress
</code></pre>
<ul>
<li>用 <code>yaml</code> 文件的写法：</li>
</ul>
<pre><code class="language-yml">version: '3.8'

services:
  my-wordpress:
    image: wordpress:latest
    ports:
      - 80:80
</code></pre>
<h4 id="docker-compose-版本说明">docker-compose 版本说明</h4>
<blockquote>
<p>https://docs.docker.com/desktop/</p>
</blockquote>
<p>打开这个网址，就会看到 <code>docker-compose</code> 和 <code>Docker</code> 版本的兼容关系表。比如 <code>3.8</code> 版本，要求 <code>Docker Engine</code> 的版本是 <code>19.03.0+</code>。</p>
<p>我们可以使用下面的命令查看当前电脑的版本。</p>
<pre><code class="language-bash">docker --version
Docker version 20.10.10, build b485636
</code></pre>
<p>可以看到，我们现在的 <code>Docker</code> 版本是完全符合 <code>docker-compose</code> 的，所以在 <code>yaml</code> 文件的最开始写 <code>version: '3.8'</code> 是没有问题的。</p>
<p>这里需要说的是: <code>docker-compose</code> 现在有两个主要版本 <code>Version3</code> 和 <code>Version2</code>。这两个版本的 <code>yaml</code> 写法也略有不同，但是基础语法是相同的。</p>
<h3 id="53-docker-compose-基础命令">5.3 Docker Compose 基础命令</h3>
<p><code>docker-compose</code> 的命令我们可以直接在终端输入 <code>docker-compose</code> 查看：</p>
<pre><code class="language-bash">Commands:
  build              Build or rebuild services
  config             Validate and view the Compose file
  create             Create services
  down               Stop and remove resources
  events             Receive real time events from containers
  exec               Execute a command in a running container
  help               Get help on a command
  images             List images
  kill               Kill containers
  logs               View output from containers
  pause              Pause services
  port               Print the public port for a port binding
  ps                 List containers
  pull               Pull service images
  push               Push service images
  restart            Restart services
  rm                 Remove stopped containers
  run                Run a one-off command
  scale              Set number of containers for a service
  start              Start services
  stop               Stop services
  top                Display the running processes
  unpause            Unpause services
  up                 Create and start containers
  version            Show version information and quit

</code></pre>
<h4 id="docker-compose-启动容器">docker-compose 启动容器</h4>
<p>上一节我们配置了一个关于 <code>wordpress</code> 服务的 <code>docker-compose.yml</code> 文件：</p>
<pre><code class="language-yml">version: '3.8'

services:
  my-wordpress:
    image: wordpress:latest
    ports:
      - 80:80
</code></pre>
<p>现在我们打开 <code>VSCode</code> 进入该文件所在的目录，打开终端输入容器启动命令 <code>docker compose up</code>，就可以开启 <code>wordpress</code> 容器了。但这时候的容器开启方式是有日志输出的，并且窗口被占用了。没办法进行其它操作了。可以加入 <code>-d</code> 参数，解决这个问题。</p>
<pre><code class="language-bash">docker compose up -d
</code></pre>
<p>这样就是后台运行模式了，我们就可以继续操作这个终端了，如果你想查看 <code>service</code> 运行情况，可以使用下面的命令：</p>
<pre><code class="language-bash">$ docker-compose ps
       Name                      Command               State                Ports
-----------------------------------------------------------------------------------------------
test_my-wordpress_1   docker-entrypoint.sh apach ...   Up      0.0.0.0:80-&gt;80/tcp,:::80-&gt;80/tcp
</code></pre>
<h4 id="docker-compose-停止和删除容器">docker-compose 停止和删除容器</h4>
<p>当你不在使用这个 <code>service</code> 的时候，就可以使用 <code>stop</code> 命令停止。停止以后，容器就处于 <code>Exited</code> 模式了。容器已经停止，就可以进行清理了。</p>
<pre><code class="language-bash">docker compose stop
</code></pre>
<p><code>rm</code> 命令会删除掉由 docker compose 所建立的容器，但用 docker 命令创建的容器不会被删除，对应的网络也不会被删除。</p>
<pre><code class="language-bash">docker compose rm
</code></pre>
<h4 id="docker-compose-命名规则">docker-compose 命名规则</h4>
<p>用 <code>docker-compose</code> 创建的容器，名字都会加入一个对应文件夹的名字，比如我在的文件夹叫做 <code>test</code> ，而我在 <code>yaml</code> 文件中起的名字是 <code>my-wordpress</code>，最终容器的名字就是 <code>test_my-wordpress_1</code>。</p>
<p>如果你想更改容器的名字，你可以在 <code>yaml</code> 文件里使用 <code>contaner_name: wordpress-demo</code>指定这个名字：</p>
<pre><code class="language-yml">version: '3.8'

services:
  my-wordpress:
    container_name: wordpress-demo
    image: wordpress:latest
    ports:
      - 80:80
</code></pre>
<h3 id="54-docker-compose-自定义镜像构筑">5.4 Docker Compose 自定义镜像构筑</h3>
<p>如果我们想使用自己的 <code>Dockerfile</code> 去启动自定义的镜像容器，我们可以按以下步骤：</p>
<ol>
<li>先创建一个 <code>Dockerfile</code> 文件</li>
</ol>
<pre><code class="language-Dockerfile">FROM node:latest
CMD []
</code></pre>
<ol start="2">
<li>在相同目录下创建 <code>docker-compose.yml</code> 文件</li>
</ol>
<pre><code class="language-yml">version: '3.8'

services:
  my-node:
    build: .
    container_name: 'my-node'
</code></pre>
<p>这里的 <code>build: .</code> 意思是：根据当前目录下 <code>Dockerfile</code> 文件构筑镜像，再启动容器。</p>
<ol start="3">
<li>执行 <code>docker-compose up -d</code></li>
</ol>
<p>容器启动之后，你再使用 <code>docker image ls</code> 会看到自定义镜像。</p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://docs.docker.com/">Docker Docs</a></li>
<li><a href="https://yeasy.gitbook.io/docker_practice/">Docker -- 从入门到实践</a></li>
<li><a href="https://jspang.com/detailed?id=75#toc21">跟胖哥一起学 Docker</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript + React 实践总结]]></title>
        <id>https://wuwenbang.github.io/post/typescript-react-shi-jian-zong-jie/</id>
        <link href="https://wuwenbang.github.io/post/typescript-react-shi-jian-zong-jie/">
        </link>
        <updated>2021-11-16T13:55:35.000Z</updated>
        <content type="html"><![CDATA[<p>本文根据日常的开发实践，参考优秀的文档、文章，总结出一些<code>TypeScript</code>在<code>React</code>开发中实用的技巧和经验。<br>
由于日常开发中已全面拥抱函数式组件和 <code>React Hooks</code>，所以 <code>class</code> 类组件的写法这里不提及。</p>
<h1 id="构建项目">构建项目</h1>
<p>markdown</p>
<p>构筑一个<code>React with TypeScript</code>项目最快的方式就是使用 Facebook 官方脚手架<code>create-react-app</code>提供的<code>TypeScript</code>模版。运行以下指令：</p>
<pre><code class="language-bash">$ create-react-app my-app --template typescript
</code></pre>
<p>生成后的项目文件会多有些许不同，主要新增了以下配置：</p>
<ul>
<li><code>.tsx</code>：使用 <code>TypeScript</code> 的 <code>JSX</code> 文件扩展；</li>
<li><code>tsconfig.json</code>：默认的 <code>TypeScript</code> 的配置文件；</li>
<li><code>react-app-env.d.ts</code>：<code>TypeScript</code> 声明文件， 注释的内容会作为编译器指令使用。</li>
</ul>
<h1 id="函数式组件">函数式组件</h1>
<h3 id="普通声明">普通声明</h3>
<pre><code class="language-tsx">interface PropsType {
  value: string
  children: React.ReactNode // 显示声明
}
const MyComponent = ({ title, children }: PropsType) =&gt; {
  return &lt;div title={title}&gt;{children}&lt;/div&gt;
}
</code></pre>
<h3 id="使用-reactfc-声明">使用 React.FC 声明</h3>
<p><code>PropsType</code>作为<code>React.FC</code>的范型参数（推荐方式）</p>
<pre><code class="language-tsx">interface PropsType {
  title: string
}
const MyComponent: React.FC&lt;PropsType&gt; = ({ title, children }) =&gt; {
  return &lt;div title={title}&gt;{children}&lt;/div&gt;
}
</code></pre>
<p>使用 <code>React.FC</code> 声明函数组件与 <code>普通声明</code> 的区别是：</p>
<ul>
<li><code>React.FC</code> 是隐式声明 <code>children</code>（目前存在一些<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/33006">issue</a>） ，而 <code>普通声明</code> 则是显示的声明 <code>children</code> 。</li>
<li><code>React.FC</code> 显式地定义了返回类型，<code>普通声明</code>则是隐式推导的。</li>
<li><code>React.FC</code> 对静态属性：<code>displayName</code>、<code>propTypes</code>、<code>defaultProps</code>提供了类型检查和自动补全。</li>
</ul>
<h1 id="props">Props</h1>
<h3 id="常用的基础-props-类型">常用的基础 Props 类型</h3>
<pre><code class="language-ts">interface PropsType = {

  // 基本类型
  message: string;
  count: number;
  disabled: boolean;

  // 数组
  names: string[];

  // 联合类型
  status: 'waiting' | 'success';

  // 对象
  obj: {
    id: string;
    title: string;
  };

  // 对象数组
  objArr: {
    id: string;
    title: string;
  }[];

  // Map类型
  map1: {
    [key: number]: string;
  };

  // Map类型的另一种实现方式
  map2: Record&lt;number, string&gt;;

  // 没有参数&amp;返回值的函数
  onClick: () =&gt; void;

  // 携带参数的函数
  onChange: (id: number) =&gt; void;

  // 携带点击事件的函数
  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void;

  // 可选的属性
  optional?: OptionalType;

};
</code></pre>
<h3 id="常用的-react-props-类型">常用的 React Props 类型</h3>
<pre><code class="language-ts">export declare interface AppBetterProps {
  children: React.ReactNode // 一般情况下推荐使用，支持所有类型

  functionChildren: (name: string) =&gt; React.ReactNode // 函数组件

  style?: React.CSSProperties // 传递style对象

  onChange?: React.FormEventHandler&lt;HTMLInputElement&gt; //表单事件, 泛型参数是event.target的类型
}
</code></pre>
<h3 id="设置-props-的默认值">设置 Props 的默认值</h3>
<ul>
<li>传递<code>Props</code>时，设置默认值（推荐方式）</li>
</ul>
<pre><code class="language-tsx">interface PropsType {
  text: string
}

// 传递 props 时，设置默认值
const MyComponent: React.FC&lt;PropsType&gt; = ({ text = 'default' }) =&gt; {
  return &lt;div&gt;{text}&lt;/div&gt;
}
</code></pre>
<ul>
<li>通过<code>defaultProps</code>设置默认值</li>
</ul>
<pre><code class="language-tsx">interface PropsType {
  text: string
}

const MyComponent: React.FC&lt;PropsType&gt; = ({ text }) =&gt; {
  return &lt;div&gt;{text}&lt;/div&gt;
}

// 通过 defaultProps 设置默认值
MyComponent.defaultProps = {
  text: 'default',
}
</code></pre>
<h1 id="react-hooks">React Hooks</h1>
<h3 id="usestate">useState</h3>
<ul>
<li>给定初始值的情况下，TypeScript 会做类型推断</li>
</ul>
<pre><code class="language-ts">const [state, setState] = useState(false)
// state 会被自动推断为 boolean 类型
</code></pre>
<ul>
<li>没有初始值或初始值为<code>null</code>时，可以使用联合类型</li>
</ul>
<pre><code class="language-ts">interface DataType {
  message: string
}

const [data, setData] = &lt;DataType | null&gt;useState(null)
// or
const [data, setData] = &lt;DataType | undefined&gt;useState()
</code></pre>
<h3 id="useeffect">useEffect</h3>
<ul>
<li>首先看一下 <code>useEffect</code> 接收<code>第一个参数</code>的类型定义</li>
</ul>
<pre><code class="language-ts">// 1. 是一个函数
// 2. 无参数
// 3. 无返回值 或 返回一个清理函数，该函数类型无参数、无返回值 。
type EffectCallback = () =&gt; void | (() =&gt; void | undefined)
</code></pre>
<ul>
<li>根据定义，<code>useEffect</code>的使用方式为</li>
</ul>
<pre><code class="language-ts">useEffect(() =&gt; {
  // when deps update

  // 可选
  return () =&gt; {
    // when component unmount
  }
}, [deps])
// ✅ 确保函数返回 void 或 一个返回 void|undefined 的清理函数
</code></pre>
<ul>
<li>同理，用 <code>async await</code> 语法处理异步请求，类似传入一个 <code>() =&gt; Promise&lt;void&gt;</code> 函数，与 <code>EffectCallback</code> 类型不匹配。</li>
</ul>
<pre><code class="language-ts">// ❌ error
useEffect(async () =&gt; {
  const { data } = await ajax(params)
  // todo
}, [params])
</code></pre>
<ul>
<li>异步请求的处理方式：</li>
</ul>
<pre><code class="language-ts">// ✅ 立即执行函数
useEffect(() =&gt; {
  ;(async () =&gt; {
    const { data } = await ajax(params)
    // todo
  })()
}, [params])

// ✅ 或者 then 也是可以的
useEffect(() =&gt; {
  ajax(params).then(({ data }) =&gt; {
    // todo
  })
}, [params])
</code></pre>
<h3 id="useref">useRef</h3>
<p><code>useRef</code> 一般用于两种场景</p>
<ol>
<li>引用 <code>DOM</code> 元素；</li>
<li>不想作为其他 <code>hooks</code> 的依赖项，因为 <code>ref</code> 的值引用是不会变的，变的只是 <code>ref.current</code>。</li>
</ol>
<ul>
<li><code>useRef</code> 传递非空初始值的时候可以推断类型，</li>
<li>也可以通过传入第一个泛型参数来定义类型，约束 <code>ref.current</code> 的类型。</li>
</ul>
<pre><code class="language-ts">// 引用DOM
const domRef = React.useRef&lt;HTMLDivElement | null&gt;(null)
// 非依赖项值
const countRef = React.useRef&lt;number&gt;(0)
</code></pre>
<h3 id="usereducer">useReducer</h3>
<p>使用 <code>useReducer</code> 时，多多利用 <code>联合类型</code> 来精确辨识、收窄确定的 <code>type</code> 的 <code>payload</code> 类型。 一般也需要定义 <code>reducer</code> 的返回类型，不然 TS 会自动推导。</p>
<pre><code class="language-tsx">// 使用联合类型约束 Action 的 type 和 payload
type ACTIONTYPE = { type: 'increment'; payload: number } | { type: 'decrement'; payload: string } | { type: 'initial' }

// reducer
function reducer(state: typeof initialState, action: ACTIONTYPE) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + action.payload }
    case 'decrement':
      return { count: state.count - Number(action.payload) }
    case 'initial':
      return { count: initialState.count }
    default:
      throw new Error()
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState)
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button onClick={() =&gt; dispatch({ type: 'decrement', payload: '5' })}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'increment', payload: 5 })}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre>
<h3 id="usecontext">useContext</h3>
<ul>
<li>通过<code>React.createContext&lt;Type&gt;()</code>的范型函数定义共享状态的类型。</li>
<li>下例是 <code>useContext</code> 和 <code>useReducer</code> 结合使用，来管理全局的数据流。</li>
</ul>
<pre><code class="language-tsx">interface AppContextInterface {
  state: typeof initialState
  dispatch: React.Dispatch&lt;ACTIONTYPE&gt;
}
// 通过范型定义 Context 的类型
const AppCtx = React.createContext&lt;AppContextInterface&gt;({
  state: initialState,
  dispatch: (action) =&gt; action,
})
const App = (): React.ReactNode =&gt; {
  const [state, dispatch] = useReducer(reducer, initialState)

  return (
    &lt;AppCtx.Provider value={{ state, dispatch }}&gt;
      &lt;Counter /&gt;
    &lt;/AppCtx.Provider&gt;
  )
}
// 消费 context
function Counter() {
  const { state, dispatch } = React.useContext(AppCtx)
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button onClick={() =&gt; dispatch({ type: 'decrement', payload: '5' })}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'increment', payload: 5 })}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre>
<h1 id="事件处理">事件处理</h1>
<h3 id="事件对象类型">事件对象类型</h3>
<p>在事件处理函数中，我们经常性的需要使用 <code>event</code> 对象，比如获取<code>Input</code>事件的<code>e.target.value</code>，鼠标事件的<code>clientX</code>、<code>clientY</code>。<br>
在刚接触<code>TypeScript</code>开发时，我都是直接把 <code>event</code> 设置为 <code>any</code> 类型，但是这样就失去了<code>TypeScript</code>对代码进行静态检查的意义。</p>
<pre><code class="language-ts">const onChange = (e: any) =&gt; {
  console.log(e.target.value)
}
</code></pre>
<p>幸运的是 <code>React</code> 的声明文件提供了 <code>Event</code> 对象的类型声明，拿最常见的情况之一：<code>Input</code>的<code>onChange</code>事件举例：</p>
<pre><code class="language-tsx">import React from 'react'
const MyInput: React.FC = () =&gt; {
  const [value, setValue] = React.useState('')

  // e 的类型是 ChangeEvent
  // e.target 的类型是 HTMLInputElement
  const onChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue(e.target.value)
  }

  return &lt;input value={value} onChange={onChange} id=&quot;input-example&quot; /&gt;
}

export default MyInput
</code></pre>
<h3 id="常用-event-事件对象类型">常用 Event 事件对象类型</h3>
<ul>
<li><code>ClipboardEvent&lt;T = Element&gt;</code> 剪贴板事件对象</li>
<li><code>DragEvent&lt;T = Element&gt;</code> 拖拽事件对象</li>
<li><code>ChangeEvent&lt;T = Element&gt;</code> Change 事件对象</li>
<li><code>KeyboardEvent&lt;T = Element&gt;</code> 键盘事件对象</li>
<li><code>MouseEvent&lt;T = Element&gt;</code> 鼠标事件对象</li>
<li><code>TouchEvent&lt;T = Element&gt;</code> 触摸事件对象</li>
<li><code>WheelEvent&lt;T = Element&gt;</code> 滚轮事件对象</li>
<li><code>AnimationEvent&lt;T = Element&gt;</code> 动画事件对象</li>
<li><code>TransitionEvent&lt;T = Element&gt;</code> 过渡事件对象</li>
</ul>
<h3 id="事件处理函数类型">事件处理函数类型</h3>
<p>当我们定义事件处理函数时有没有更方便定义其函数类型的方式呢？答案是使用 <code>React</code> 声明文件所提供的 <code>EventHandler</code> 类型别名，通过不同事件的 <code>EventHandler</code> 的类型别名来定义事件处理函数的类型。</p>
<p><code>EventHandler</code> 类型实现源码 <code>node_modules/@types/react/index.d.ts</code> 。</p>
<pre><code class="language-ts">type EventHandler&lt;E extends SyntheticEvent&lt;any&gt;&gt; = { bivarianceHack(event: E): void }['bivarianceHack']
type ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;
type ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;
type DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;
type FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;
type FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;
type ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;
type KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;
type MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;
type TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;
type PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;
type UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;
type WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;
type AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;
type TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;
</code></pre>
<p>实例：</p>
<pre><code class="language-ts">interface PropsType {
  onClick: MouseEventHandler&lt;HTMLDivElement&gt;
  onChange: ChangeEventHandler&lt;HTMLInputElement&gt;
}
</code></pre>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://typescript.bootcss.com/tutorials/react.html">TypeScript 中文手册 React</a></li>
<li><a href="https://juejin.cn/post/6884144754993397767#heading-8">React with TypeScript 最佳实践</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 从集合论的角度理解类型系统]]></title>
        <id>https://wuwenbang.github.io/post/typescript-cong-ji-he-lun-de-jiao-du-li-jie-lei-xing-xi-tong/</id>
        <link href="https://wuwenbang.github.io/post/typescript-cong-ji-he-lun-de-jiao-du-li-jie-lei-xing-xi-tong/">
        </link>
        <updated>2021-09-15T13:50:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0-前言">0. 前言</h2>
<p>在学习和使用 <code>TypeScript</code> 的过程中，有一些问题一直困惑着我：</p>
<ol>
<li>比如说<strong>联合类型</strong>与<strong>交叉类型</strong>在基础类型和对象类型上的不同表现：</li>
</ol>
<ul>
<li>对于基础类型来说，联合类型是类型的并集，交叉类型是类型的交集。</li>
</ul>
<pre><code class="language-ts">// 联合类型
type Union = string | number // Union = string | number
// 交叉类型
type Intersection = string &amp; number // Intersection = never
</code></pre>
<ul>
<li>对于对象类型来说，联合类型是属性的交集（<strong>勘误：只有在被赋值的对象拥有全部属性的情况下，才表现为属性的交集</strong>），交叉类型是属性的并集。</li>
</ul>
<pre><code class="language-ts">interface A {
  x: number
  y: number
}
interface B {
  y: number
  z: number
}
// 联合类型
type Union = A | B
/* 
Union = {
  y: number
}
*/

// 交叉类型
type Intersection = A &amp; B
/* 
Intersection = {
  x: number
  y: number
  z: number
}
*/
</code></pre>
<ol start="2">
<li>再比如说条件类型的 <code>extends</code> 关键字到底是什么意思——可继承？可扩展？还是可赋值？</li>
</ol>
<pre><code class="language-ts">// extends =&gt; 可赋值 ？
type T1 = string extends string | number ? true : false // T1 = true

// extends =&gt; 可继承 ？
interface ObjectA {
  x: string
  y: string
}
interface ObjectB {
  x: string
}
type T2 = ObjectA extends ObjectB ? true : false // T2 = true
</code></pre>
<p>上述的例子确实令人困惑，或许我们应该换个角度去思考：尝试用集合论的角度去思考 <code>TypeScript</code> 的类型系统。</p>
<h2 id="1-类型与集合">1. 类型与集合</h2>
<p>在 <code>JavaScript</code> 里，<strong>类型</strong>是满足某些特征的<strong>值的集合</strong>。例如：</p>
<ul>
<li><code>number</code> 类型是是所有数字的集合。</li>
<li><code>string</code> 类型是所有字符串的集合。</li>
<li><code>bolean</code> 类型是 <code>true</code> 和 <code>false</code> 的集合。</li>
<li><code>undefined</code> 类型是 <code>undefined</code> 的集合。</li>
</ul>
<p>总结一下就是：<strong>类型</strong> 对应集合论里的 <strong>集合</strong>，<strong>值</strong> 对应集合论里的 <strong>元素</strong>。<br><br>
而在 <code>TypeScript</code> 里，我们可以给变量声明类型，并将对应类型的值赋予它。</p>
<pre><code class="language-ts">let str: string = 'xxx'
str = 'yyy'
let num: number = 123
num = 456
</code></pre>
<p>而对于对象的类型，也就是类（Class），集合的概念就非常容易混淆，我们来看下面一个例子：</p>
<pre><code class="language-ts">interface A {
  x: number
}
interface B {
  x: number
  y: number
}
const b: B = {
  x: 1,
  y: 2,
}
const a: A = b // ok
</code></pre>
<p>示例中，对象 <code>b</code> 的类型是 <code>{ x: number, y: number }</code>，但是它却可以赋值给类型为 <code>{ x: number }</code> 的变量 <code>a</code>。这看似不合理的现象，通过集合论的观点便可以解释：<br><br>
我们把类 <code>A</code> 即 <code>{ x: number }</code> 看成<strong>所有拥有属性 <code>x: number</code> 的对象的集合</strong>，也就是说只要拥有属性 <code>x: number</code> 的对象都可以看成集合 <code>A</code> 的一个元素（或者类 <code>A</code> 的实例）。<br><br>
那么因为 <code>b = { x:1, y:2 }</code> 拥有属性 <code>x: number</code> =&gt; 所以对象 <code>b</code> 是类 <code>A</code> 的一个实例 =&gt; 所以 <code>b</code> 可以赋值给类型为 <code>A</code> 的变量 <code>a</code>。<br><br>
关于对象，我们必须清晰地知道：<strong>对象类型（类）是若干对象的集合，而不是属性的集合。只要一个对象具有类所描述的全部属性，那么该对象就是该类的元素（实例）。</strong><br></p>
<h2 id="2-交叉类型与联合类型">2. 交叉类型与联合类型</h2>
<ul>
<li><strong>交叉类型（Intersection Types）</strong> 对应集合论的 <strong>交集（Intersection）</strong><br></li>
<li><strong>联合类型（Union Types）</strong> 对应集合论的 <strong>并集（Union）</strong><br><br>
（PS：从英文原文翻译的角度来看，我认为将 交叉类型与联合类型 翻译成 交集类型和并集类型 可能更加贴切。）<br></li>
</ul>
<h3 id="21-交叉类型与联合类型的简单运算">2.1 交叉类型与联合类型的简单运算</h3>
<p>关于交叉类型 <code>&amp;</code> 和联合类型 <code>|</code> 的运算，我们来看一个简单的例子：</p>
<pre><code class="language-ts">type A = 1 | 2
type B = 2 | 3
// A B 交集
type C = A &amp; B // C = 2
// A B 并集
type D = A | B // D = 1 | 2 | 3
// A number 交集
type E = A &amp; number // E = A = 1 | 2
// A number 并集
type F = A | number // F = number
// 空集 never
type G = number &amp; string // G = never
// 全集 unknown
type H = number | unknown // H = unknown
</code></pre>
<ul>
<li>A - F 符合集合论交集并集的运算规律</li>
<li>G <code>never</code> 意为不会出现的类型，其符合空集的计算规律，遂可以理解为空集。</li>
<li>H <code>unkonwn</code> 意为未知的类型，其符合全集的计算规律，遂可以理解为全集。</li>
</ul>
<p>集合论中交集与并集的运算特性，交叉类型和联合类型也满足：<br><br>
对于交集运算符 <code>&amp;</code>：</p>
<ol>
<li>唯一性: <code>A &amp; A</code> 等价于 <code>A</code>.</li>
<li>满足交换律: <code>A &amp; B</code> 等价于 <code>B &amp; A</code> .</li>
<li>满足结合律: <code>(A &amp; B) &amp; C</code> 等价于 <code>A &amp; (B &amp; C)</code>.</li>
<li>父类型收敛: 当且仅当 <code>B</code> 是 <code>A</code> 的父类型时，<code>A &amp; B</code> 等价于 <code>A</code>.</li>
</ol>
<p>对于并集运算符 <code>|</code>：</p>
<ol>
<li>唯一性: <code>A | A</code> 等价于 <code>A</code>.</li>
<li>满足交换律: <code>A | B</code> 等价于 <code>B | A</code>.</li>
<li>满足结合律: <code>(A | B) | C</code> 等价于 <code>A | (B | C)</code>.</li>
<li>子类型收敛: 当且仅当 <code>B</code> 是 <code>A</code> 的子类型时，<code>A | B</code> 等价于 <code>A</code>.</li>
</ol>
<h3 id="22-交叉类型与联合类型高级运算">2.2 交叉类型与联合类型高级运算</h3>
<p>对于对象类型的交叉类型和联合类型，同样符合集合论的规律：</p>
<h4 id="交叉类型高级运算">交叉类型高级运算</h4>
<pre><code class="language-ts">interface A {
  x: number
  y: number
}
interface B {
  y: number
  z: number
}
// 交叉类型
type Intersection = B &amp; A

const obj1: Intersection = {
  x: 1,
  y: 2,
  z: 3,
}

obj1.x // ok
obj1.y // ok
obj1.z // ok
</code></pre>
<ul>
<li>交叉类型 <code>Intersection</code> 是对象 <code>A</code> 和 <code>B</code> 的交集，是<strong>对象集合的交集</strong>，表现为拥有 <code>A</code> 和 <code>B</code> 的全部属性，是<strong>属性集合的并集</strong>。。</li>
<li>赋值上：只有具有 <code>A</code> 和 <code>B</code> 所有的属性的对象才能赋值给 <code>Intersection</code>。</li>
<li>访问上：交叉类型 <code>Intersection</code> 可以访问 <code>A</code> 和 <code>B</code> 的<strong>所有属性</strong>。</li>
</ul>
<h4 id="联合类型高级运算">联合类型高级运算</h4>
<pre><code class="language-ts">interface A {
  x: number
  y: number
}
interface B {
  y: number
  z: number
}
// 联合类型
type Union = B | A

const obj1: Union = {
  x: 1,
  y: 2,
  z: 3,
}
const obj2: Union = {
  x: 1,
  y: 2,
}
const obj3: Union = {
  y: 2,
  z: 3,
}

obj1.x // error
obj1.y // ok
obj1.z // error
</code></pre>
<ul>
<li>联合类型 <code>Union</code> 是对象 <code>A</code> 和 <code>B</code> 的并集，即<strong>对象集合的并集</strong>。</li>
<li>赋值上：具有 <code>A</code>或<code>B</code>或<code>A &amp; B</code> 的属性的对象能赋值给 <code>Union</code>。</li>
<li>访问上：为了类型安全，当赋值为 <code>A</code> 或 <code>B</code> 时，联合类型 <code>Union</code> 只能访问 <code>A</code> 或 <code>B</code> ；当赋值为 <code>A &amp; B</code> 时（即全部属性），联合类型 <code>Union</code> 只能访问 <code>A</code> 和 <code>B</code> 的<strong>共有属性</strong>。</li>
</ul>
<h2 id="3-extends-关键字">3 extends 关键字</h2>
<p>根据集合论，<code>A extends B</code> 的语意是： <code>A</code> 为 <code>B</code> 的<strong>子集</strong>。</p>
<h3 id="31-extends-用作泛型约束">3.1 extends 用作泛型约束</h3>
<ul>
<li>表达式：<code>T extends U</code></li>
<li>作用：泛型约束用作限制泛型的类型，即<code>泛型T</code>必须是<code>类型U</code>的子集，才能通过编译。</li>
</ul>
<pre><code class="language-ts">function needNumber&lt;T extends number&gt;(value: T): number {
  return value + 1
}
// 满足 number 类型的子集
needNumber(1) //ok
// 不是 number 类型的子集
needNumber('1') //error
</code></pre>
<p>对象类型同理：</p>
<pre><code class="language-ts">interface Point {
  x: number
  y: number
}
function Sum&lt;T extends Point&gt;(value: T): number {
  return value.x + value.y
}
// 满足 Point 类型的子集
Sum({ x: 1, y: 2 }) // ok
Sum({ x: 1, y: 2, z: 3 }) // ok
// 不是 Point 类型的子集
Sum({ x: 1 }) // error
</code></pre>
<h3 id="32-extends-用作条件泛型">3.2 extends 用作条件泛型</h3>
<ul>
<li>表达式：<code>T extends U ? X : Y</code></li>
<li>作用：条件类型是一个三元运算表达式，如果 <code>T</code> 是 <code>U</code> 的子集，则表达式的值为 <code>X</code>，否则为 <code>U</code>。</li>
</ul>
<pre><code class="language-ts">type IsNumber&lt;T&gt; = T extends number ? true : false
type Result1 = IsNumber&lt;1&gt; // true
type Result2 = IsNumber&lt;'1'&gt; // false
</code></pre>
<p>对象类型同理：</p>
<pre><code class="language-ts">interface Point {
  x: number
  y: number
}
type IsPointSubset&lt;T&gt; = T extends Point ? true : false
type Result1 = IsPointSubset&lt;{ x: number; y: number }&gt; // true
type Result2 = IsPointSubset&lt;{ x: number; z: number }&gt; // false
</code></pre>
<h2 id="4-参考资料">4. 参考资料</h2>
<ul>
<li><a href="https://typescript.bootcss.com/">TypeScript 中文手册</a></li>
<li><a href="https://juejin.cn/post/6847902223402270728">Typescript 进击的基础（一）交叉类型和联合类型-集合论角度理解</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 工具类型]]></title>
        <id>https://wuwenbang.github.io/post/typescript-gong-ju-lei-xing/</id>
        <link href="https://wuwenbang.github.io/post/typescript-gong-ju-lei-xing/">
        </link>
        <updated>2021-08-26T13:49:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><code>Typescript</code> 中默认内置了很多工具泛型，通过使用这些工具，可以使得我们定义类型更加灵活，高效。本文将会介绍常用泛型工具的使用技巧，以及对其实现原理进行相应的解析，如果有错误的地方，还望指出。</p>
<h2 id="partialt">Partial&lt;T&gt;</h2>
<p><strong>作用</strong>：将传入对象类型 <code>T</code> 的属性变为<strong>可选属性</strong>。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
}

const tom: Partial&lt;Person&gt; = {
  name: &quot;Tom&quot;,
};
</code></pre>
<p><code>Partial&lt;Person&gt;</code> 等价于</p>
<pre><code class="language-ts">interface Person {
  name?: string;
  age?: number;
}
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过关键字 <code>keyof</code> 将传入对象类型的键值转换为联合类型。</li>
<li>通过关键字 <code>in</code> 遍历联合类型，即遍历对象的键值。</li>
<li>通过类型映射，将对象的属性转换为<strong>可选属性</strong></li>
</ol>
<pre><code class="language-ts">type MyPartial&lt;T&gt; = {
  [P in keyof T]?: T[P];
};
</code></pre>
<h2 id="readonlyt">Readonly&lt;T&gt;</h2>
<p><strong>作用</strong>：把传入对象类型 <code>T</code> 属性变为<strong>只读属性</strong>。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
}

const tom: Readonly&lt;Person&gt; = {
  name: &quot;Tom&quot;,
  age: 18;
};

tom.age = 22 // error
</code></pre>
<p><code>Readonly&lt;Person&gt;</code> 等价于</p>
<pre><code class="language-ts">interface Person {
  readonly name: string;
  readonly age: number;
}
</code></pre>
<p><strong>实现原理</strong>：</p>
<p>与<code>Partial</code>类似：</p>
<ol>
<li>通过关键字 <code>keyof</code> 将传入对象类型的键值转换为联合类型。</li>
<li>通过关键字 <code>in</code> 遍历联合类型，即遍历对象的键值。</li>
<li>通过类型映射，将对象的属性转换为<strong>只读属性</strong></li>
</ol>
<pre><code class="language-ts">type Readonly&lt;T&gt; = {
  readonly [P in keyof T]: T[P];
};
</code></pre>
<h2 id="requiredt">Required&lt;T&gt;</h2>
<p><strong>作用</strong>：把传入对象类型 <code>T</code> 属性变为<strong>必填属性</strong>。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name?: string;
  age?: number;
}

let tom: Required&lt;Person&gt;

tom = {
  name: &quot;Tom&quot;,
  age: 18;
};
// ok

tom = {
  name: &quot;Tom&quot;,
};
// error
</code></pre>
<p><strong>实现原理</strong>：</p>
<p>与<code>Partial</code>类似：</p>
<ol>
<li>通过关键字 <code>keyof</code> 将传入对象的键值转换为枚举类型。</li>
<li>通过关键字 <code>in</code> 遍历枚举类型，即遍历对象的键值。</li>
<li>通过类型映射，再统一通过 <code>-</code> 修饰符移除 <code>?</code> 修饰符，从而转变为<strong>必填状态</strong>。</li>
</ol>
<pre><code class="language-ts">type Required&lt;T&gt; = {
  Required [P in keyof T]: T[P];
};
</code></pre>
<h2 id="recordkt">Record&lt;K,T&gt;</h2>
<p><strong>作用</strong>：它用来生成一个属性名为 <code>K</code>，属性值类型为 <code>T</code> 的对象类型集合。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">// 快速生成一个 Person 对象
type Person = Record&lt;&quot;name&quot; | &quot;country&quot;, string&gt;;

const Tom: Person = { name: &quot;Tom&quot;, country: &quot;America&quot; };
</code></pre>
<p><strong>实现原理</strong>:</p>
<ol>
<li>通过 <code>K extends keyof any</code> 对 <code>K</code> 参数进行约束，将其约束为任意类型 <code>any</code> 的键值。</li>
<li>通过 <code>in</code> 对键值集合 <code>K</code> 进行遍历，然后生成类型为 <code>T</code> 的键值对集合。</li>
</ol>
<pre><code class="language-ts">type MyRecord&lt;K extends keyof any, T&gt; = {
  [P in K]: T;
};
</code></pre>
<h2 id="excludetk">Exclude&lt;T,K&gt;</h2>
<p><strong>作用</strong>：从类型 <code>T</code> 中排除所有可以赋值给类型 <code>U</code> 的类型。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">// 从 &quot;a&quot; | &quot;b&quot; | &quot;c&quot; 中排除掉 &quot;a&quot; 类型
type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;
// T1 = &quot;b&quot; | &quot;c&quot;

// 从 string | number | boolean 中排除掉 string 类型
type T2 = Exclude&lt;string | number | boolean, string&gt;;
// T2 = number | boolean
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过条件类型<code>T extends U ? never : T</code> 对 <code>T</code> 参数进行判别：
<ul>
<li>如果 <code>T</code> 可赋值给 <code>U</code> ，那么返回 <code>never</code>（即排除掉<code>T</code>）。</li>
<li>如果 <code>T</code> 不可赋值给 <code>U</code> ，那么返回 <code>T</code>。</li>
</ul>
</li>
<li>通过<strong>分布式条件类型</strong>，如果 <code>T</code> 为联合类型，则将条件类型的结果分发为<strong>联合类型</strong>。</li>
</ol>
<pre><code class="language-ts">type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre>
<h2 id="extracttk">Extract&lt;T,K&gt;</h2>
<p><strong>作用</strong>：与 <code>Exclude</code> 相反，从类型 <code>T</code> 中提取所有可以赋值给类型 <code>U</code> 的类型。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">// 从 &quot;a&quot; | &quot;b&quot; | &quot;c&quot; 中提取出 &quot;a&quot; 类型
type T1 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;
// T1 = &quot;a&quot;

// 从 string | number | boolean 中提取出 string 类型
type T2 = Extract&lt;string | number | boolean, string&gt;;
// T2 = string

type T3 = Extract&lt;string | (() =&gt; void), Function&gt;;
// 相当于 type T3 = () =&gt; void;
</code></pre>
<p><strong>实现原理</strong>：</p>
<p>与 <code>Exclude</code> 类似：</p>
<ol>
<li>通过条件类型<code>T extends U ? never : T</code> 对 <code>T</code> 参数进行判别：
<ul>
<li>如果 <code>T</code> 可赋值给 <code>U</code> ，那么返回 <code>T</code>。</li>
<li>如果 <code>T</code> 不可赋值给 <code>U</code> ，那么返回 <code>never</code>（即排除掉<code>T</code>）。</li>
</ul>
</li>
<li>通过<strong>分布式条件类型</strong>，如果 <code>T</code> 为联合类型，则将条件类型的结果分发为<strong>联合类型</strong>。</li>
</ol>
<pre><code class="language-ts">type Extract&lt;T, U&gt; = T extends U ? T : never;
</code></pre>
<h2 id="picktk">Pick&lt;T,K&gt;</h2>
<p><strong>作用</strong>：在 <code>T</code> 中，摘选出 <code>K</code> 属性。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
}

// 从 Person 中摘选出 name 属性
type PickPerson = Pick&lt;Person, &quot;name&quot;&gt;;

const tom: PickPerson = {
  name: &quot;Tom&quot;,
};
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过 <code>K extends keyof T</code> 对 <code>K</code> 参数进行约束，将其约束为 <code>T</code> 的键值范围内。</li>
<li>通过 <code>in</code> 对键值集合 <code>K</code> 进行遍历，然后生成类型为 <code>T</code> 的键值对集合。</li>
</ol>
<pre><code class="language-ts">type Pick&lt;T, K extends keyof T&gt; = {
  [P in K]: T[P];
};
</code></pre>
<h2 id="omittk">Omit&lt;T,K&gt;</h2>
<p><strong>作用</strong>：在 <code>T</code> 中，剔除掉 <code>K</code> 属性。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
}

// 从 Person 中剔除掉 name 属性
type OmitPerson = Pick&lt;Person, &quot;name&quot;&gt;;

const tom: PickPerson = {
  age: 18,
};
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过 <code>K extends keyof T</code> 对 <code>K</code> 参数进行约束，将其约束为 <code>T</code> 的键值范围内。</li>
<li>通过 <code>Exclude&lt;keyof T, K&gt;</code> 将类型集合 <code>T</code> 中的 <code>K</code> 类型排除掉。</li>
<li>通过 <code>Pick&lt;T,Exclude&lt;keyof T, K&gt;&gt;</code> 在 <code>T</code> 中摘选出排除掉 <code>K</code> 的 <code>T</code> 的属性。</li>
</ol>
<pre><code class="language-ts">type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;
</code></pre>
<h2 id="returntypet">ReturnType&lt;T&gt;</h2>
<p><strong>作用</strong>：获取函数的返回值类型。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">type Fun = () =&gt; string;

// 获取 Fun 返回值的类型
type T1 = ReturnType&lt;Fun&gt;; // T1 = string

type T2 = ReturnType&lt;() =&gt; { x: number; y: number }&gt;;
// T2 = { x: number, y: number }
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过 <code>extends</code> 对 <code>T</code> 参数进行约束，<code>(...args: any) =&gt; any</code> 表示一个函数类型，即 <code>T</code> 参数的类型必须是一个<strong>函数类型</strong>。</li>
<li><code>T extends U ? X : Y</code> 是条件类型（注意和之前表示约束的 <code>extends</code> 做区分），其中 <code>T</code> 是泛型参数，<code>U</code> 是<strong>条件部分</strong>，<code>X</code> 是符合条件的返回结果，<code>Y</code> 是不符合条件的返回结果。</li>
<li>推断类型 <code>infer</code> 的作用是：在条件类型内部声明一个<strong>类型变量</strong>。<code>(...args: any) =&gt; infer R</code> 是条件类型的<strong>条件部分</strong>，它声明了一个类型变量 <code>R</code> ，用来存储函数的返回类型。</li>
<li><code>T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any</code>表示：
<ul>
<li>如果 <code>T</code> 是函数类型（<code>(...args: any) =&gt; infer R</code>），则返回 <code>R</code> , 即函数的返回类型。</li>
<li>如果 <code>T</code> 不是函数类型（<code>(...args: any) =&gt; infer R</code>），则返回 <code>any</code>。</li>
</ul>
</li>
</ol>
<pre><code class="language-ts">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (
  ...args: any
) =&gt; infer R
  ? R
  : any;
</code></pre>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://typescript.bootcss.com/">TypeScript 中文手册</a></li>
<li><a href="https://github.com/chenxiaochun/blog/issues/67">TypeScript 内置工具泛型</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 泛型总结]]></title>
        <id>https://wuwenbang.github.io/post/typescript-fan-xing-zong-jie/</id>
        <link href="https://wuwenbang.github.io/post/typescript-fan-xing-zong-jie/">
        </link>
        <updated>2021-08-05T13:47:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-泛型是什么">1. 泛型是什么？</h2>
<ul>
<li>
<p>官方的定义是：</p>
<blockquote>
<p>**泛型（Generics）**是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
</blockquote>
</li>
<li>
<p>通俗的解释是：泛型是类型系统中的<strong>参数</strong>，就像函数的参数一样，只不过函数的参数传递的是值，而泛型传递的是<strong>类型</strong>。他只出现在现在<strong>函数</strong>，<strong>接口</strong>，和<strong>类</strong>中，主要作用是为了类型的复用。</p>
</li>
</ul>
<ul>
<li>设计泛型的关键目的：是在成员之间提供有意义的约束，这些成员可以是：函数参数、函数返回值、类的实例成员和类的方法。</li>
</ul>
<p>可能这么讲会有一些抽象，接下来我们以泛型函数为例，举一个简单的例子：</p>
<ol>
<li>首先我们来定义一个通用的 <code>identity</code> 函数，该函数接收一个<code>number</code>类型的参数，并直接返回这个值：</li>
</ol>
<pre><code class="language-ts">function identity(value: number): number {
  return value;
}
identity(1); // ok

identity(&quot;hello&quot;); // error
// 编译器报错： Argument of type 'string' is not assignable to parameter of type 'number'.ts(2345)
</code></pre>
<ol start="2">
<li>现在，<code>identity</code> 函数能且只能传入 <code>number</code> 类型的参数，如果我想传入 <code>string</code> 类型的 <code>TypeScript</code> 编译器会报错，那么该怎么办呢？或许你会想到 <code>any</code> 类型。</li>
</ol>
<pre><code class="language-ts">function identity(value: any) {
  return value;
}
identity(1); // ok
identity(&quot;hello&quot;); // ok
</code></pre>
<ol start="3">
<li>好吧，传入 <code>any</code> 确实可以生效，但我们失去了定义应该返回哪种类型的能力，并且在这个过程中也丧失了 <code>TypeScript</code> 的类型保护作用。</li>
</ol>
<p>我们的目标是让 <code>identity</code> 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用 <strong>泛型函数</strong> 来解决这个问题：</p>
<h2 id="2-泛型函数">2. 泛型函数</h2>
<p>定义泛型函数：</p>
<pre><code class="language-ts">function identity&lt;T&gt;(value: T): T {
  return value;
}
identity&lt;number&gt;(1); // ok
identity&lt;string&gt;(&quot;hello&quot;); // ok
</code></pre>
<p>对于刚接触 <code>TypeScript</code> 泛型的读者来说，首次看到 <code>&lt;T&gt;</code> 语法会感到陌生。但这没什么可担心的，就像传递参数一样，通过参数变量 <code>T</code>，把用户想要传入的类型，链式传递到后面函数的类型定义中去。</p>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2020/6/10/1729b3d9774a21ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="泛型传递" loading="lazy"></figure>
<p>（图片来源：<a href="https://juejin.cn/post/6844904184894980104">掘金阿宝哥</a>）</p>
<p>参考上面的图片，通过 <code>&lt;T&gt;</code> 声明 <strong>类型变量 <code>T</code></strong>，然后在后面的函数参数类型声明、和函数返回值类型声明中使用：<code>(value: T): T</code>。</p>
<p>理论上，<code>&lt; &gt;</code>类可以声明任意字符作为类型变量，但在定义泛型时通常用<code>T</code>作为类型变量名称，其中 <code>T</code> 代表 <code>Type</code>。当然，除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p>
<ul>
<li>K（Key）：表示对象中的键类型。</li>
<li>V（Value）：表示对象中的值类型。</li>
<li>E（Element）：表示元素类型。</li>
<li>U（T 后面的字符）：表示第二个类型参数（以此类推）。</li>
</ul>
<p>很多时候并不是只能定义一个类型变量，我们可以引入更多的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p>
<pre><code class="language-ts">function identity&lt;T, U&gt;(value: T, message: U): T {
  console.log(message);
  return value;
}

console.log(identity&lt;Number, string&gt;(100, &quot;Hello Generics&quot;));
// Hello Generics
// 100
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2020/6/10/1729b3dbccc38ea7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="泛型传递" loading="lazy"></figure>
<p>（图片来源：<a href="https://juejin.cn/post/6844904184894980104">掘金阿宝哥</a>）</p>
<p>除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：</p>
<pre><code class="language-ts">function identity&lt;T, U&gt;(value: T, message: U): T {
  console.log(message);
  return value;
}

console.log(identity(100, &quot;Hello Generics&quot;));
// Hello Generics
// 100
</code></pre>
<h2 id="3-泛型接口">3. 泛型接口</h2>
<p>定义泛型接口：</p>
<pre><code class="language-ts">interface GenericInterface&lt;T&gt; {
  data: T;
}
</code></pre>
<p>接口泛型的使用方式和函数类似，我们可以通过<code>&lt;T&gt;</code>来声明参数变量<code>T</code>，并将其用在后面接口属性的类型定义上。</p>
<p>泛型接口常用于定义那些，需要用户自定义类型的对象上，最常见的就是 网络请求的响应对象了，以<code>Axios</code>为例：<br>
假设我们通过 <code>axios.get</code> 发起网络请求，我们可以通过<code>axios.get&lt;DataType&gt;</code>传入<code>data</code>的类型，最后拿响应 <code>res</code> 时，我们就可以明确的知道<code>data</code>的数据类型 ：</p>
<pre><code class="language-ts">interface DataType {
  id: number;
  message: string;
}
axios.get&lt;DataType&gt;(&quot;https://www.xxx.com&quot;).then((res) =&gt; {
  console.log(res.data.message);
});
</code></pre>
<p>其中<code>axios</code>实例，以及响应<code>res</code>的泛型接口如下定义：</p>
<pre><code class="language-ts">interface AxiosInstance {
  // ...
  get&lt;T = any, R = AxiosResponse&lt;T&gt;&gt;(
    url: string,
    config?: AxiosRequestConfig
  ): Promise&lt;R&gt;;
}

interface AxiosResponse&lt;T = any&gt; {
  data: T;
  status: number;
  statusText: string;
  headers: any;
  config: AxiosRequestConfig;
  request?: any;
}
</code></pre>
<p>其中响应的 <code>data</code> 是 <code>axios</code> 不知道的，所以 <code>axios</code> 通过泛型的方式，将类型<code>T</code>传递给后面的<code>data</code>属性。</p>
<h2 id="4-泛型类">4. 泛型类</h2>
<p>在类中使用泛型也很简单，我们只需要在类名后面，使用 <code>&lt;T, ...&gt;</code> 的语法定义任意多个类型变量。</p>
<p>定义泛型类：</p>
<pre><code class="language-ts">interface GenericInterface&lt;U&gt; {
  value: U;
  getValue: () =&gt; U;
}

class GenericClass&lt;T&gt; implements GenericInterface&lt;T&gt; {
  value: T;

  constructor(value: T) {
    this.value = value;
  }

  getValue(): T {
    return this.value;
  }
}

const myNumberClass = new GenericClass&lt;number&gt;(10);
console.log(myNumberClass.getValue()); // 10

const myStringClass = new GenericClass&lt;string&gt;(&quot;Hello Generics!&quot;);
console.log(myStringClass.getValue()); // Hello Generics!
</code></pre>
<p>接下来我们以实例化 <code>myNumberClass</code> 为例，来分析一下其调用过程：</p>
<ol>
<li>在实例化 <code>GenericClass</code> 对象时，我们传入 <code>number</code> 类型和构造函数参数值 68；</li>
<li>之后在 <code>GenericClass</code> 类中，类型变量 <code>T</code> 的值变成 <code>number</code> 类型；</li>
<li><code>GenericClass</code> 类实现了 <code>GenericInterface&lt;T&gt;</code>，而此时 <code>T</code> 表示 <code>number</code> 类型，因此等价于该类实现了 <code>GenericInterface&lt;number&gt;</code> 接口；</li>
<li>而对于 <code>GenericInterface&lt;U&gt;</code> 接口来说，类型变量 <code>U</code> 也变成了 <code>number</code>。这里我有意使用不同的变量名，以表明类型值沿链向上传播，且与变量名无关。</li>
</ol>
<h2 id="5-泛型约束">5. 泛型约束</h2>
<p>有时候我们希望限制泛型变量接受的类型（比如我只希望接受拥有<code>.length</code>属性的类型），我们就需要<strong>泛型约束</strong>。下面我们来举几个例子，介绍一下如何使用泛型约束。</p>
<h3 id="51-确保属性存在">5.1 确保属性存在</h3>
<p>有时候，我们希望类型变量对应的类型上存在某些属性。这时，除非我们显式地将特定属性定义为类型变量，否则编译器不会知道它们的存在。<br>
一个很好的例子是在处理字符串或数组时，我们会假设 <code>length</code> 属性是可用的。让我们再次使用 <code>identity</code> 函数并尝试输出参数的长度：</p>
<pre><code class="language-ts">function identity&lt;T&gt;(arg: T): T {
  console.log(arg.length); // error: T doesn't have .length
  return arg;
}
</code></pre>
<p>在这种情况下，编译器将不会知道 <code>T</code> 确实含有 <code>length</code> 属性，尤其是在可以将任何类型赋给类型变量 <code>T</code> 的情况下。我们需要做的就是让类型变量 <code>extends</code> 一个含有我们所需属性的接口，比如这样：</p>
<pre><code class="language-ts">interface Length {
  length: number;
}

function identity&lt;T extends Length&gt;(arg: T): T {
  console.log(arg.length); // ok: 可以获取length属性
  return arg;
}
</code></pre>
<p><code>T extends Length</code> 用于告诉编译器，我们支持已经实现 <code>Length</code> 接口的任何类型。</p>
<p>之后，当我们使用不含有 <code>length</code> 属性的对象作为参数调用 <code>identity</code> 函数时，<code>TypeScript</code> 会提示相关的错误信息：</p>
<pre><code class="language-ts">identity(10); // Error
// Argument of type '68' is not assignable to parameter of type 'Length'.(2345)
</code></pre>
<h3 id="52-检查对象上的键是否存在">5.2 检查对象上的键是否存在</h3>
<p>泛型约束的另一个常见的使用场景就是检查对象上的键是否存在。不过在看具体示例之前，我们得来了解一下 <code>keyof</code> 操作符，该操作符可以用于<strong>获取某种类型的所有键</strong>，其返回类型是<strong>联合类型</strong>。我们来举个 <code>keyof</code> 的使用示例：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot; | &quot;location&quot;
type K2 = keyof Person[]; // number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...
</code></pre>
<p>通过 <code>keyof</code> 操作符，我们就可以获取指定类型的所有键，之后我们就可以结合前面介绍的 <code>extends</code> 约束，即限制输入的属性名包含在 <code>keyof</code> 返回的联合类型中。具体的使用方式如下：</p>
<pre><code class="language-ts">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
  return obj[key];
}

const obj = {
  name: &quot;tom&quot;,
};

getProperty(obj, &quot;name&quot;); // ok
getProperty(obj, &quot;age&quot;); // error 属性名 age 不存在 obj 上
</code></pre>
<p>在以上的 <code>getProperty</code> 函数中，我们通过<code>K extends keyof T</code> 确保参数 <code>key</code> 一定是对象中含有的键，这样就不会发生运行时错误。这是一个类型安全的解决方案，与简单调用 <code>let value = obj[key];</code> 不同。</p>
<p>在以上示例中，对于 <code>getProperty(obj, &quot;age&quot;)</code> 这个表达式，<code>TypeScript</code> 编译器会提示以下错误信息：</p>
<pre><code class="language-ts">// 编译器报错：Argument of type '&quot;age&quot;' is not assignable to parameter of type '&quot;name&quot;'.ts(2345)
</code></pre>
<p>很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。</p>
<h2 id="6-泛型参数默认类型">6. 泛型参数默认类型</h2>
<p>我们都知道 <code>JavaScript</code> 的函数参数可以设置初始值（<code>defalut value</code>），类似地，我们也可以为泛型参数设置默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。<br>
泛型参数默认类型与普通函数默认值类似，对应的语法很简单，即 <code>&lt;T=Default Type&gt;</code>，对应的使用示例如下：</p>
<pre><code class="language-ts">interface MyObject&lt;T = string&gt; {
  id: T;
}

const numObject: MyObject = { id: &quot;abc&quot; };
const strObject: MyObject&lt;number&gt; = { id: 123 };
</code></pre>
<p>泛型参数的默认类型遵循以下规则：</p>
<ul>
<li>有默认类型的类型参数被认为是<strong>可选的</strong>。</li>
<li>必选的类型参数不能在可选的类型参数后。</li>
<li>如果类型参数有约束，类型参数的默认类型必须满足这个约束。</li>
<li>当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。</li>
<li>如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。</li>
</ul>
<h2 id="7-泛型条件类型">7. 泛型条件类型</h2>
<p>通过<strong>泛型条件类型</strong>，我们可以根据某些条件得到不同的类型，这里所说的条件是类型兼容性约束。尽管以上代码中使用了 <code>extends</code> 关键字，也不一定要强制满足继承关系，而是检查是否满足结构兼容性。</p>
<p>条件类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：<br>
<code>T extends U ? X : Y</code><br>
以上表达式的意思是：若 <code>T</code> 能够赋值给 <code>U</code>（<code>T</code> 属于与 <code>U</code>的子类），那么类型是 <code>X</code>，否则为 <code>Y</code>。在条件类型表达式中，我们通常还会结合 <code>infer</code> 关键字，实现类型抽取：</p>
<pre><code class="language-ts">interface MyObject&lt;T = any&gt; {
  key: T;
}

type StrObject = MyObject&lt;string&gt;;
type NumObject = MyObject&lt;number&gt;;

type ObjectMember&lt;T&gt; = T extends MyObject&lt;infer V&gt; ? V : never;
type StrObjectMember = ObjectMember&lt;StrObject&gt;; // string
type NumObjectMember = ObjectMember&lt;NumObject&gt;; // number
</code></pre>
<p>在上面示例中，当类型 <code>T</code> 满足 <code>T extends MyObject</code> 约束时，我们会使用 <code>infer</code> 关键字声明了一个类型变量 <code>V</code>，并返回该类型，否则返回 <code>never</code> 类型。</p>
<h2 id="8-参考文章">8. 参考文章</h2>
<ul>
<li><a href="https://typescript.bootcss.com/basic-types.html">TypeScript 中文手册</a></li>
<li><a href="https://juejin.cn/post/6872111128135073806#heading-28">一份不可多得的 TS 学习指南</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 断言总结]]></title>
        <id>https://wuwenbang.github.io/post/typescript-duan-yan-zong-jie/</id>
        <link href="https://wuwenbang.github.io/post/typescript-duan-yan-zong-jie/">
        </link>
        <updated>2021-07-29T13:46:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-类型断言">1. 类型断言</h2>
<p>在使用 <code>TypeScript</code> 的过程中，你可能会遇到这种情况：你比 <code>TypeScript</code> 更加清楚某个值的类型。<br>
比如你从异步请求中拿到一个类型为<code>any</code>的值，但你清楚的知道这个值就是<code>string</code>类型，这个时候你可以通过<strong>类型断言</strong>方式告诉编译器：&quot;嘿！相信我，我知道我在干什么！&quot;。类型断言有点类似于其他语言的类型转换，但它没有运行时的影响，只是在编译阶段起作用。<br>
类型断言有两种形式：</p>
<h3 id="11-尖括号语法">1.1 尖括号语法</h3>
<ul>
<li>形式：<code>&lt;类型&gt;变量名</code></li>
</ul>
<pre><code class="language-ts">let value: any = &quot;this is a string&quot;;
let length: number = (&lt;string&gt;value).length;
</code></pre>
<h3 id="12-as-语法">1.2 as 语法</h3>
<ul>
<li>形式：<code>变量名 as 类型</code></li>
</ul>
<pre><code class="language-ts">let value: any = &quot;this is a string&quot;;
let length: number = (value as string).length;
</code></pre>
<h2 id="2-非空断言">2. 非空断言</h2>
<p>当你明确知道某个值不可能为 <code>undefined</code> 和 <code>null</code> 时，你可以用 在变量后面加上一个 <code>!</code>（非空断言符号）来告诉编译器：&quot;嘿！相信我，我确信这个值不为空！&quot;。<br>
非空断言具体的使用场景如下：</p>
<pre><code class="language-ts">function fun(value: string | undefined | null) {
  const str: string = value; // error value 可能为 undefined 和 null
  const str: string = value!; //ok
  const length: number = value.length; // error value 可能为 undefined 和 null
  const length: number = value!.length; //ok
}
</code></pre>
<h2 id="3-确定赋值断言">3. 确定赋值断言</h2>
<p><code>TypeScript</code> 的确定赋值断言，允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而告诉 <code>TypeScript</code> 该属性会被明确地赋值。</p>
<pre><code class="language-ts">let name!: string;
</code></pre>
<p>上述表达式就是对编译器说：&quot;有一个名为 <code>name</code> 的属性，其类型为 <code>string | undefined</code>。它以值 <code>undefined</code> 开始。但每次获取或设置该属性时，我都希望将其视为类型 <code>string。</code>&quot;</p>
<p>为了更好地理解它的作用，我们来看个具体的例子：</p>
<pre><code class="language-ts">let count: number;
initialize();

// Variable 'count' is used before being assigned.(2454)
console.log(2 * count); // Error

function initialize() {
  count = 10;
}
</code></pre>
<p>很明显该异常信息是说变量 <code>count</code> 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：</p>
<pre><code class="language-ts">let count!: number;
initialize();
console.log(2 * count); // Ok

function initialize() {
  count = 10;
}
</code></pre>
<h2 id="4-参考文章">4. 参考文章</h2>
<ul>
<li><a href="https://typescript.bootcss.com/basic-types.html">TypeScript 中文手册</a></li>
<li><a href="https://juejin.cn/post/6872111128135073806#heading-28">一份不可多得的 TS 学习指南</a></li>
</ul>
]]></content>
    </entry>
</feed>