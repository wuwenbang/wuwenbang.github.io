<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wuwenbang.github.io</id>
    <title>Bang&apos;s Blog</title>
    <updated>2022-02-26T06:12:12.685Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wuwenbang.github.io"/>
    <link rel="self" href="https://wuwenbang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wuwenbang.github.io/images/avatar.png</logo>
    <icon>https://wuwenbang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Bang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[TypeScript + React 实践总结]]></title>
        <id>https://wuwenbang.github.io/post/typescript-react-shi-jian-zong-jie/</id>
        <link href="https://wuwenbang.github.io/post/typescript-react-shi-jian-zong-jie/">
        </link>
        <updated>2022-02-24T13:55:35.000Z</updated>
        <content type="html"><![CDATA[<p>本文根据日常的开发实践，参考优秀的文档、文章，总结出一些<code>TypeScript</code>在<code>React</code>开发中实用的技巧和经验。<br>
由于日常开发中已全面拥抱函数式组件和 <code>React Hooks</code>，所以 <code>class</code> 类组件的写法这里不提及。</p>
<h1 id="构建项目">构建项目</h1>
<p>markdown</p>
<p>构筑一个<code>React with TypeScript</code>项目最快的方式就是使用 Facebook 官方脚手架<code>create-react-app</code>提供的<code>TypeScript</code>模版。运行以下指令：</p>
<pre><code class="language-bash">$ create-react-app my-app --template typescript
</code></pre>
<p>生成后的项目文件会多有些许不同，主要新增了以下配置：</p>
<ul>
<li><code>.tsx</code>：使用 <code>TypeScript</code> 的 <code>JSX</code> 文件扩展；</li>
<li><code>tsconfig.json</code>：默认的 <code>TypeScript</code> 的配置文件；</li>
<li><code>react-app-env.d.ts</code>：<code>TypeScript</code> 声明文件， 注释的内容会作为编译器指令使用。</li>
</ul>
<h1 id="函数式组件">函数式组件</h1>
<h3 id="普通声明">普通声明</h3>
<pre><code class="language-tsx">interface PropsType {
  value: string
  children: React.ReactNode // 显示声明
}
const MyComponent = ({ title, children }: PropsType) =&gt; {
  return &lt;div title={title}&gt;{children}&lt;/div&gt;
}
</code></pre>
<h3 id="使用-reactfc-声明">使用 React.FC 声明</h3>
<p><code>PropsType</code>作为<code>React.FC</code>的范型参数（推荐方式）</p>
<pre><code class="language-tsx">interface PropsType {
  title: string
}
const MyComponent: React.FC&lt;PropsType&gt; = ({ title, children }) =&gt; {
  return &lt;div title={title}&gt;{children}&lt;/div&gt;
}
</code></pre>
<p>使用 <code>React.FC</code> 声明函数组件与 <code>普通声明</code> 的区别是：</p>
<ul>
<li><code>React.FC</code> 是隐式声明 <code>children</code>（目前存在一些<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/33006">issue</a>） ，而 <code>普通声明</code> 则是显示的声明 <code>children</code> 。</li>
<li><code>React.FC</code> 显式地定义了返回类型，<code>普通声明</code>则是隐式推导的。</li>
<li><code>React.FC</code> 对静态属性：<code>displayName</code>、<code>propTypes</code>、<code>defaultProps</code>提供了类型检查和自动补全。</li>
</ul>
<h1 id="props">Props</h1>
<h3 id="常用的基础-props-类型">常用的基础 Props 类型</h3>
<pre><code class="language-ts">interface PropsType = {

  // 基本类型
  message: string;
  count: number;
  disabled: boolean;

  // 数组
  names: string[];

  // 联合类型
  status: 'waiting' | 'success';

  // 对象
  obj: {
    id: string;
    title: string;
  };

  // 对象数组
  objArr: {
    id: string;
    title: string;
  }[];

  // Map类型
  map1: {
    [key: number]: string;
  };

  // Map类型的另一种实现方式
  map2: Record&lt;number, string&gt;;

  // 没有参数&amp;返回值的函数
  onClick: () =&gt; void;

  // 携带参数的函数
  onChange: (id: number) =&gt; void;

  // 携带点击事件的函数
  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void;

  // 可选的属性
  optional?: OptionalType;

};
</code></pre>
<h3 id="常用的-react-props-类型">常用的 React Props 类型</h3>
<pre><code class="language-ts">export declare interface AppBetterProps {
  children: React.ReactNode // 一般情况下推荐使用，支持所有类型

  functionChildren: (name: string) =&gt; React.ReactNode // 函数组件

  style?: React.CSSProperties // 传递style对象

  onChange?: React.FormEventHandler&lt;HTMLInputElement&gt; //表单事件, 泛型参数是event.target的类型
}
</code></pre>
<h3 id="设置-props-的默认值">设置 Props 的默认值</h3>
<ul>
<li>传递<code>Props</code>时，设置默认值（推荐方式）</li>
</ul>
<pre><code class="language-tsx">interface PropsType {
  text: string
}

// 传递 props 时，设置默认值
const MyComponent: React.FC&lt;PropsType&gt; = ({ text = 'default' }) =&gt; {
  return &lt;div&gt;{text}&lt;/div&gt;
}
</code></pre>
<ul>
<li>通过<code>defaultProps</code>设置默认值</li>
</ul>
<pre><code class="language-tsx">interface PropsType {
  text: string
}

const MyComponent: React.FC&lt;PropsType&gt; = ({ text }) =&gt; {
  return &lt;div&gt;{text}&lt;/div&gt;
}

// 通过 defaultProps 设置默认值
MyComponent.defaultProps = {
  text: 'default',
}
</code></pre>
<h1 id="react-hooks">React Hooks</h1>
<h3 id="usestate">useState</h3>
<ul>
<li>给定初始值的情况下，TypeScript 会做类型推断</li>
</ul>
<pre><code class="language-ts">const [state, setState] = useState(false)
// state 会被自动推断为 boolean 类型
</code></pre>
<ul>
<li>没有初始值或初始值为<code>null</code>时，可以使用联合类型</li>
</ul>
<pre><code class="language-ts">interface DataType {
  message: string
}

const [data, setData] = &lt;DataType | null&gt;useState(null)
// or
const [data, setData] = &lt;DataType | undefined&gt;useState()
</code></pre>
<h3 id="useeffect">useEffect</h3>
<ul>
<li>首先看一下 <code>useEffect</code> 接收<code>第一个参数</code>的类型定义</li>
</ul>
<pre><code class="language-ts">// 1. 是一个函数
// 2. 无参数
// 3. 无返回值 或 返回一个清理函数，该函数类型无参数、无返回值 。
type EffectCallback = () =&gt; void | (() =&gt; void | undefined)
</code></pre>
<ul>
<li>根据定义，<code>useEffect</code>的使用方式为</li>
</ul>
<pre><code class="language-ts">useEffect(() =&gt; {
  // when deps update

  // 可选
  return () =&gt; {
    // when component unmount
  }
}, [deps])
// ✅ 确保函数返回 void 或 一个返回 void|undefined 的清理函数
</code></pre>
<ul>
<li>同理，用 <code>async await</code> 语法处理异步请求，类似传入一个 <code>() =&gt; Promise&lt;void&gt;</code> 函数，与 <code>EffectCallback</code> 类型不匹配。</li>
</ul>
<pre><code class="language-ts">// ❌ error
useEffect(async () =&gt; {
  const { data } = await ajax(params)
  // todo
}, [params])
</code></pre>
<ul>
<li>异步请求的处理方式：</li>
</ul>
<pre><code class="language-ts">// ✅ 立即执行函数
useEffect(() =&gt; {
  ;(async () =&gt; {
    const { data } = await ajax(params)
    // todo
  })()
}, [params])

// ✅ 或者 then 也是可以的
useEffect(() =&gt; {
  ajax(params).then(({ data }) =&gt; {
    // todo
  })
}, [params])
</code></pre>
<h3 id="useref">useRef</h3>
<p><code>useRef</code> 一般用于两种场景</p>
<ol>
<li>引用 <code>DOM</code> 元素；</li>
<li>不想作为其他 <code>hooks</code> 的依赖项，因为 <code>ref</code> 的值引用是不会变的，变的只是 <code>ref.current</code>。</li>
</ol>
<ul>
<li><code>useRef</code> 传递非空初始值的时候可以推断类型，</li>
<li>也可以通过传入第一个泛型参数来定义类型，约束 <code>ref.current</code> 的类型。</li>
</ul>
<pre><code class="language-ts">// 引用DOM
const domRef = React.useRef&lt;HTMLDivElement | null&gt;(null)
// 非依赖项值
const countRef = React.useRef&lt;number&gt;(0)
</code></pre>
<h3 id="usereducer">useReducer</h3>
<p>使用 <code>useReducer</code> 时，多多利用 <code>联合类型</code> 来精确辨识、收窄确定的 <code>type</code> 的 <code>payload</code> 类型。 一般也需要定义 <code>reducer</code> 的返回类型，不然 TS 会自动推导。</p>
<pre><code class="language-tsx">// 使用联合类型约束 Action 的 type 和 payload
type ACTIONTYPE = { type: 'increment'; payload: number } | { type: 'decrement'; payload: string } | { type: 'initial' }

// reducer
function reducer(state: typeof initialState, action: ACTIONTYPE) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + action.payload }
    case 'decrement':
      return { count: state.count - Number(action.payload) }
    case 'initial':
      return { count: initialState.count }
    default:
      throw new Error()
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState)
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button onClick={() =&gt; dispatch({ type: 'decrement', payload: '5' })}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'increment', payload: 5 })}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre>
<h3 id="usecontext">useContext</h3>
<ul>
<li>通过<code>React.createContext&lt;Type&gt;()</code>的范型函数定义共享状态的类型。</li>
<li>下例是 <code>useContext</code> 和 <code>useReducer</code> 结合使用，来管理全局的数据流。</li>
</ul>
<pre><code class="language-tsx">interface AppContextInterface {
  state: typeof initialState
  dispatch: React.Dispatch&lt;ACTIONTYPE&gt;
}
// 通过范型定义 Context 的类型
const AppCtx = React.createContext&lt;AppContextInterface&gt;({
  state: initialState,
  dispatch: (action) =&gt; action,
})
const App = (): React.ReactNode =&gt; {
  const [state, dispatch] = useReducer(reducer, initialState)

  return (
    &lt;AppCtx.Provider value={{ state, dispatch }}&gt;
      &lt;Counter /&gt;
    &lt;/AppCtx.Provider&gt;
  )
}
// 消费 context
function Counter() {
  const { state, dispatch } = React.useContext(AppCtx)
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button onClick={() =&gt; dispatch({ type: 'decrement', payload: '5' })}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'increment', payload: 5 })}&gt;+&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></pre>
<h1 id="事件处理">事件处理</h1>
<h3 id="事件对象类型">事件对象类型</h3>
<p>在事件处理函数中，我们经常性的需要使用 <code>event</code> 对象，比如获取<code>Input</code>事件的<code>e.target.value</code>，鼠标事件的<code>clientX</code>、<code>clientY</code>。<br>
在刚接触<code>TypeScript</code>开发时，我都是直接把 <code>event</code> 设置为 <code>any</code> 类型，但是这样就失去了<code>TypeScript</code>对代码进行静态检查的意义。</p>
<pre><code class="language-ts">const onChange = (e: any) =&gt; {
  console.log(e.target.value)
}
</code></pre>
<p>幸运的是 <code>React</code> 的声明文件提供了 <code>Event</code> 对象的类型声明，拿最常见的情况之一：<code>Input</code>的<code>onChange</code>事件举例：</p>
<pre><code class="language-tsx">import React from 'react'
const MyInput: React.FC = () =&gt; {
  const [value, setValue] = React.useState('')

  // e 的类型是 ChangeEvent
  // e.target 的类型是 HTMLInputElement
  const onChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setValue(e.target.value)
  }

  return &lt;input value={value} onChange={onChange} id=&quot;input-example&quot; /&gt;
}

export default MyInput
</code></pre>
<h3 id="常用-event-事件对象类型">常用 Event 事件对象类型</h3>
<ul>
<li><code>ClipboardEvent&lt;T = Element&gt;</code> 剪贴板事件对象</li>
<li><code>DragEvent&lt;T = Element&gt;</code> 拖拽事件对象</li>
<li><code>ChangeEvent&lt;T = Element&gt;</code> Change 事件对象</li>
<li><code>KeyboardEvent&lt;T = Element&gt;</code> 键盘事件对象</li>
<li><code>MouseEvent&lt;T = Element&gt;</code> 鼠标事件对象</li>
<li><code>TouchEvent&lt;T = Element&gt;</code> 触摸事件对象</li>
<li><code>WheelEvent&lt;T = Element&gt;</code> 滚轮事件对象</li>
<li><code>AnimationEvent&lt;T = Element&gt;</code> 动画事件对象</li>
<li><code>TransitionEvent&lt;T = Element&gt;</code> 过渡事件对象</li>
</ul>
<h3 id="事件处理函数类型">事件处理函数类型</h3>
<p>当我们定义事件处理函数时有没有更方便定义其函数类型的方式呢？答案是使用 <code>React</code> 声明文件所提供的 <code>EventHandler</code> 类型别名，通过不同事件的 <code>EventHandler</code> 的类型别名来定义事件处理函数的类型。</p>
<p><code>EventHandler</code> 类型实现源码 <code>node_modules/@types/react/index.d.ts</code> 。</p>
<pre><code class="language-ts">type EventHandler&lt;E extends SyntheticEvent&lt;any&gt;&gt; = { bivarianceHack(event: E): void }['bivarianceHack']
type ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;
type ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;
type DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt;
type FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt;
type FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt;
type ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt;
type KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;
type MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt;
type TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt;
type PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt;
type UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt;
type WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt;
type AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt;
type TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt;
</code></pre>
<p>实例：</p>
<pre><code class="language-ts">interface PropsType {
  onClick: MouseEventHandler&lt;HTMLDivElement&gt;
  onChange: ChangeEventHandler&lt;HTMLInputElement&gt;
}
</code></pre>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://typescript.bootcss.com/tutorials/react.html">TypeScript 中文手册 React</a></li>
<li><a href="https://juejin.cn/post/6884144754993397767#heading-8">React with TypeScript 最佳实践</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 从集合论的角度理解类型系统]]></title>
        <id>https://wuwenbang.github.io/post/typescript-cong-ji-he-lun-de-jiao-du-li-jie-lei-xing-xi-tong/</id>
        <link href="https://wuwenbang.github.io/post/typescript-cong-ji-he-lun-de-jiao-du-li-jie-lei-xing-xi-tong/">
        </link>
        <updated>2022-02-24T13:50:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0-前言">0. 前言</h2>
<p>在学习和使用 <code>TypeScript</code> 的过程中，有一些问题一直困惑着我：</p>
<ol>
<li>比如说<strong>联合类型</strong>与<strong>交叉类型</strong>在基础类型和对象类型上的不同表现：</li>
</ol>
<ul>
<li>对于基础类型来说，联合类型是类型的并集，交叉类型是类型的交集。</li>
</ul>
<pre><code class="language-ts">// 联合类型
type Union = string | number // Union = string | number
// 交叉类型
type Intersection = string &amp; number // Intersection = never
</code></pre>
<ul>
<li>对于对象类型来说，联合类型是属性的交集（<strong>勘误：只有在被赋值的对象拥有全部属性的情况下，才表现为属性的交集</strong>），交叉类型是属性的并集。</li>
</ul>
<pre><code class="language-ts">interface A {
  x: number
  y: number
}
interface B {
  y: number
  z: number
}
// 联合类型
type Union = A | B
/* 
Union = {
  y: number
}
*/

// 交叉类型
type Intersection = A &amp; B
/* 
Intersection = {
  x: number
  y: number
  z: number
}
*/
</code></pre>
<ol start="2">
<li>再比如说条件类型的 <code>extends</code> 关键字到底是什么意思——可继承？可扩展？还是可赋值？</li>
</ol>
<pre><code class="language-ts">// extends =&gt; 可赋值 ？
type T1 = string extends string | number ? true : false // T1 = true

// extends =&gt; 可继承 ？
interface ObjectA {
  x: string
  y: string
}
interface ObjectB {
  x: string
}
type T2 = ObjectA extends ObjectB ? true : false // T2 = true
</code></pre>
<p>上述的例子确实令人困惑，或许我们应该换个角度去思考：尝试用集合论的角度去思考 <code>TypeScript</code> 的类型系统。</p>
<h2 id="1-类型与集合">1. 类型与集合</h2>
<p>在 <code>JavaScript</code> 里，<strong>类型</strong>是满足某些特征的<strong>值的集合</strong>。例如：</p>
<ul>
<li><code>number</code> 类型是是所有数字的集合。</li>
<li><code>string</code> 类型是所有字符串的集合。</li>
<li><code>bolean</code> 类型是 <code>true</code> 和 <code>false</code> 的集合。</li>
<li><code>undefined</code> 类型是 <code>undefined</code> 的集合。</li>
</ul>
<p>总结一下就是：<strong>类型</strong> 对应集合论里的 <strong>集合</strong>，<strong>值</strong> 对应集合论里的 <strong>元素</strong>。<br><br>
而在 <code>TypeScript</code> 里，我们可以给变量声明类型，并将对应类型的值赋予它。</p>
<pre><code class="language-ts">let str: string = 'xxx'
str = 'yyy'
let num: number = 123
num = 456
</code></pre>
<p>而对于对象的类型，也就是类（Class），集合的概念就非常容易混淆，我们来看下面一个例子：</p>
<pre><code class="language-ts">interface A {
  x: number
}
interface B {
  x: number
  y: number
}
const b: B = {
  x: 1,
  y: 2,
}
const a: A = b // ok
</code></pre>
<p>示例中，对象 <code>b</code> 的类型是 <code>{ x: number, y: number }</code>，但是它却可以赋值给类型为 <code>{ x: number }</code> 的变量 <code>a</code>。这看似不合理的现象，通过集合论的观点便可以解释：<br><br>
我们把类 <code>A</code> 即 <code>{ x: number }</code> 看成<strong>所有拥有属性 <code>x: number</code> 的对象的集合</strong>，也就是说只要拥有属性 <code>x: number</code> 的对象都可以看成集合 <code>A</code> 的一个元素（或者类 <code>A</code> 的实例）。<br><br>
那么因为 <code>b = { x:1, y:2 }</code> 拥有属性 <code>x: number</code> =&gt; 所以对象 <code>b</code> 是类 <code>A</code> 的一个实例 =&gt; 所以 <code>b</code> 可以赋值给类型为 <code>A</code> 的变量 <code>a</code>。<br><br>
关于对象，我们必须清晰地知道：<strong>对象类型（类）是若干对象的集合，而不是属性的集合。只要一个对象具有类所描述的全部属性，那么该对象就是该类的元素（实例）。</strong><br></p>
<h2 id="2-交叉类型与联合类型">2. 交叉类型与联合类型</h2>
<ul>
<li><strong>交叉类型（Intersection Types）</strong> 对应集合论的 <strong>交集（Intersection）</strong><br></li>
<li><strong>联合类型（Union Types）</strong> 对应集合论的 <strong>并集（Union）</strong><br><br>
（PS：从英文原文翻译的角度来看，我认为将 交叉类型与联合类型 翻译成 交集类型和并集类型 可能更加贴切。）<br></li>
</ul>
<h3 id="21-交叉类型与联合类型的简单运算">2.1 交叉类型与联合类型的简单运算</h3>
<p>关于交叉类型 <code>&amp;</code> 和联合类型 <code>|</code> 的运算，我们来看一个简单的例子：</p>
<pre><code class="language-ts">type A = 1 | 2
type B = 2 | 3
// A B 交集
type C = A &amp; B // C = 2
// A B 并集
type D = A | B // D = 1 | 2 | 3
// A number 交集
type E = A &amp; number // E = A = 1 | 2
// A number 并集
type F = A | number // F = number
// 空集 never
type G = number &amp; string // G = never
// 全集 unknown
type H = number | unknown // H = unknown
</code></pre>
<ul>
<li>A - F 符合集合论交集并集的运算规律</li>
<li>G <code>never</code> 意为不会出现的类型，其符合空集的计算规律，遂可以理解为空集。</li>
<li>H <code>unkonwn</code> 意为未知的类型，其符合全集的计算规律，遂可以理解为全集。</li>
</ul>
<p>集合论中交集与并集的运算特性，交叉类型和联合类型也满足：<br><br>
对于交集运算符 <code>&amp;</code>：</p>
<ol>
<li>唯一性: <code>A &amp; A</code> 等价于 <code>A</code>.</li>
<li>满足交换律: <code>A &amp; B</code> 等价于 <code>B &amp; A</code> .</li>
<li>满足结合律: <code>(A &amp; B) &amp; C</code> 等价于 <code>A &amp; (B &amp; C)</code>.</li>
<li>父类型收敛: 当且仅当 <code>B</code> 是 <code>A</code> 的父类型时，<code>A &amp; B</code> 等价于 <code>A</code>.</li>
</ol>
<p>对于并集运算符 <code>|</code>：</p>
<ol>
<li>唯一性: <code>A | A</code> 等价于 <code>A</code>.</li>
<li>满足交换律: <code>A | B</code> 等价于 <code>B | A</code>.</li>
<li>满足结合律: <code>(A | B) | C</code> 等价于 <code>A | (B | C)</code>.</li>
<li>子类型收敛: 当且仅当 <code>B</code> 是 <code>A</code> 的子类型时，<code>A | B</code> 等价于 <code>A</code>.</li>
</ol>
<h3 id="22-交叉类型与联合类型高级运算">2.2 交叉类型与联合类型高级运算</h3>
<p>对于对象类型的交叉类型和联合类型，同样符合集合论的规律：</p>
<h4 id="交叉类型高级运算">交叉类型高级运算</h4>
<pre><code class="language-ts">interface A {
  x: number
  y: number
}
interface B {
  y: number
  z: number
}
// 交叉类型
type Intersection = B &amp; A

const obj1: Intersection = {
  x: 1,
  y: 2,
  z: 3,
}

obj1.x // ok
obj1.y // ok
obj1.z // ok
</code></pre>
<ul>
<li>交叉类型 <code>Intersection</code> 是对象 <code>A</code> 和 <code>B</code> 的交集，是<strong>对象集合的交集</strong>，表现为拥有 <code>A</code> 和 <code>B</code> 的全部属性，是<strong>属性集合的并集</strong>。。</li>
<li>赋值上：只有具有 <code>A</code> 和 <code>B</code> 所有的属性的对象才能赋值给 <code>Intersection</code>。</li>
<li>访问上：交叉类型 <code>Intersection</code> 可以访问 <code>A</code> 和 <code>B</code> 的<strong>所有属性</strong>。</li>
</ul>
<h4 id="联合类型高级运算">联合类型高级运算</h4>
<pre><code class="language-ts">interface A {
  x: number
  y: number
}
interface B {
  y: number
  z: number
}
// 联合类型
type Union = B | A

const obj1: Union = {
  x: 1,
  y: 2,
  z: 3,
}
const obj2: Union = {
  x: 1,
  y: 2,
}
const obj3: Union = {
  y: 2,
  z: 3,
}

obj1.x // error
obj1.y // ok
obj1.z // error
</code></pre>
<ul>
<li>联合类型 <code>Union</code> 是对象 <code>A</code> 和 <code>B</code> 的并集，即<strong>对象集合的并集</strong>。</li>
<li>赋值上：具有 <code>A</code>或<code>B</code>或<code>A &amp; B</code> 的属性的对象能赋值给 <code>Union</code>。</li>
<li>访问上：为了类型安全，当赋值为 <code>A</code> 或 <code>B</code> 时，联合类型 <code>Union</code> 只能访问 <code>A</code> 或 <code>B</code> ；当赋值为 <code>A &amp; B</code> 时（即全部属性），联合类型 <code>Union</code> 只能访问 <code>A</code> 和 <code>B</code> 的<strong>共有属性</strong>。</li>
</ul>
<h2 id="3-extends-关键字">3 extends 关键字</h2>
<p>根据集合论，<code>A extends B</code> 的语意是： <code>A</code> 为 <code>B</code> 的<strong>子集</strong>。</p>
<h3 id="31-extends-用作泛型约束">3.1 extends 用作泛型约束</h3>
<ul>
<li>表达式：<code>T extends U</code></li>
<li>作用：泛型约束用作限制泛型的类型，即<code>泛型T</code>必须是<code>类型U</code>的子集，才能通过编译。</li>
</ul>
<pre><code class="language-ts">function needNumber&lt;T extends number&gt;(value: T): number {
  return value + 1
}
// 满足 number 类型的子集
needNumber(1) //ok
// 不是 number 类型的子集
needNumber('1') //error
</code></pre>
<p>对象类型同理：</p>
<pre><code class="language-ts">interface Point {
  x: number
  y: number
}
function Sum&lt;T extends Point&gt;(value: T): number {
  return value.x + value.y
}
// 满足 Point 类型的子集
Sum({ x: 1, y: 2 }) // ok
Sum({ x: 1, y: 2, z: 3 }) // ok
// 不是 Point 类型的子集
Sum({ x: 1 }) // error
</code></pre>
<h3 id="32-extends-用作条件泛型">3.2 extends 用作条件泛型</h3>
<ul>
<li>表达式：<code>T extends U ? X : Y</code></li>
<li>作用：条件类型是一个三元运算表达式，如果 <code>T</code> 是 <code>U</code> 的子集，则表达式的值为 <code>X</code>，否则为 <code>U</code>。</li>
</ul>
<pre><code class="language-ts">type IsNumber&lt;T&gt; = T extends number ? true : false
type Result1 = IsNumber&lt;1&gt; // true
type Result2 = IsNumber&lt;'1'&gt; // false
</code></pre>
<p>对象类型同理：</p>
<pre><code class="language-ts">interface Point {
  x: number
  y: number
}
type IsPointSubset&lt;T&gt; = T extends Point ? true : false
type Result1 = IsPointSubset&lt;{ x: number; y: number }&gt; // true
type Result2 = IsPointSubset&lt;{ x: number; z: number }&gt; // false
</code></pre>
<h2 id="4-参考资料">4. 参考资料</h2>
<ul>
<li><a href="https://typescript.bootcss.com/">TypeScript 中文手册</a></li>
<li><a href="https://juejin.cn/post/6847902223402270728">Typescript 进击的基础（一）交叉类型和联合类型-集合论角度理解</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 工具类型]]></title>
        <id>https://wuwenbang.github.io/post/typescript-gong-ju-lei-xing/</id>
        <link href="https://wuwenbang.github.io/post/typescript-gong-ju-lei-xing/">
        </link>
        <updated>2022-02-24T13:49:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><code>Typescript</code> 中默认内置了很多工具泛型，通过使用这些工具，可以使得我们定义类型更加灵活，高效。本文将会介绍常用泛型工具的使用技巧，以及对其实现原理进行相应的解析，如果有错误的地方，还望指出。</p>
<h2 id="partialt">Partial&lt;T&gt;</h2>
<p><strong>作用</strong>：将传入对象类型 <code>T</code> 的属性变为<strong>可选属性</strong>。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
}

const tom: Partial&lt;Person&gt; = {
  name: &quot;Tom&quot;,
};
</code></pre>
<p><code>Partial&lt;Person&gt;</code> 等价于</p>
<pre><code class="language-ts">interface Person {
  name?: string;
  age?: number;
}
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过关键字 <code>keyof</code> 将传入对象类型的键值转换为联合类型。</li>
<li>通过关键字 <code>in</code> 遍历联合类型，即遍历对象的键值。</li>
<li>通过类型映射，将对象的属性转换为<strong>可选属性</strong></li>
</ol>
<pre><code class="language-ts">type MyPartial&lt;T&gt; = {
  [P in keyof T]?: T[P];
};
</code></pre>
<h2 id="readonlyt">Readonly&lt;T&gt;</h2>
<p><strong>作用</strong>：把传入对象类型 <code>T</code> 属性变为<strong>只读属性</strong>。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
}

const tom: Readonly&lt;Person&gt; = {
  name: &quot;Tom&quot;,
  age: 18;
};

tom.age = 22 // error
</code></pre>
<p><code>Readonly&lt;Person&gt;</code> 等价于</p>
<pre><code class="language-ts">interface Person {
  readonly name: string;
  readonly age: number;
}
</code></pre>
<p><strong>实现原理</strong>：</p>
<p>与<code>Partial</code>类似：</p>
<ol>
<li>通过关键字 <code>keyof</code> 将传入对象类型的键值转换为联合类型。</li>
<li>通过关键字 <code>in</code> 遍历联合类型，即遍历对象的键值。</li>
<li>通过类型映射，将对象的属性转换为<strong>只读属性</strong></li>
</ol>
<pre><code class="language-ts">type Readonly&lt;T&gt; = {
  readonly [P in keyof T]: T[P];
};
</code></pre>
<h2 id="requiredt">Required&lt;T&gt;</h2>
<p><strong>作用</strong>：把传入对象类型 <code>T</code> 属性变为<strong>必填属性</strong>。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name?: string;
  age?: number;
}

let tom: Required&lt;Person&gt;

tom = {
  name: &quot;Tom&quot;,
  age: 18;
};
// ok

tom = {
  name: &quot;Tom&quot;,
};
// error
</code></pre>
<p><strong>实现原理</strong>：</p>
<p>与<code>Partial</code>类似：</p>
<ol>
<li>通过关键字 <code>keyof</code> 将传入对象的键值转换为枚举类型。</li>
<li>通过关键字 <code>in</code> 遍历枚举类型，即遍历对象的键值。</li>
<li>通过类型映射，再统一通过 <code>-</code> 修饰符移除 <code>?</code> 修饰符，从而转变为<strong>必填状态</strong>。</li>
</ol>
<pre><code class="language-ts">type Required&lt;T&gt; = {
  Required [P in keyof T]: T[P];
};
</code></pre>
<h2 id="recordkt">Record&lt;K,T&gt;</h2>
<p><strong>作用</strong>：它用来生成一个属性名为 <code>K</code>，属性值类型为 <code>T</code> 的对象类型集合。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">// 快速生成一个 Person 对象
type Person = Record&lt;&quot;name&quot; | &quot;country&quot;, string&gt;;

const Tom: Person = { name: &quot;Tom&quot;, country: &quot;America&quot; };
</code></pre>
<p><strong>实现原理</strong>:</p>
<ol>
<li>通过 <code>K extends keyof any</code> 对 <code>K</code> 参数进行约束，将其约束为任意类型 <code>any</code> 的键值。</li>
<li>通过 <code>in</code> 对键值集合 <code>K</code> 进行遍历，然后生成类型为 <code>T</code> 的键值对集合。</li>
</ol>
<pre><code class="language-ts">type MyRecord&lt;K extends keyof any, T&gt; = {
  [P in K]: T;
};
</code></pre>
<h2 id="excludetk">Exclude&lt;T,K&gt;</h2>
<p><strong>作用</strong>：从类型 <code>T</code> 中排除所有可以赋值给类型 <code>U</code> 的类型。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">// 从 &quot;a&quot; | &quot;b&quot; | &quot;c&quot; 中排除掉 &quot;a&quot; 类型
type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;
// T1 = &quot;b&quot; | &quot;c&quot;

// 从 string | number | boolean 中排除掉 string 类型
type T2 = Exclude&lt;string | number | boolean, string&gt;;
// T2 = number | boolean
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过条件类型<code>T extends U ? never : T</code> 对 <code>T</code> 参数进行判别：
<ul>
<li>如果 <code>T</code> 可赋值给 <code>U</code> ，那么返回 <code>never</code>（即排除掉<code>T</code>）。</li>
<li>如果 <code>T</code> 不可赋值给 <code>U</code> ，那么返回 <code>T</code>。</li>
</ul>
</li>
<li>通过<strong>分布式条件类型</strong>，如果 <code>T</code> 为联合类型，则将条件类型的结果分发为<strong>联合类型</strong>。</li>
</ol>
<pre><code class="language-ts">type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre>
<h2 id="extracttk">Extract&lt;T,K&gt;</h2>
<p><strong>作用</strong>：与 <code>Exclude</code> 相反，从类型 <code>T</code> 中提取所有可以赋值给类型 <code>U</code> 的类型。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">// 从 &quot;a&quot; | &quot;b&quot; | &quot;c&quot; 中提取出 &quot;a&quot; 类型
type T1 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;
// T1 = &quot;a&quot;

// 从 string | number | boolean 中提取出 string 类型
type T2 = Extract&lt;string | number | boolean, string&gt;;
// T2 = string

type T3 = Extract&lt;string | (() =&gt; void), Function&gt;;
// 相当于 type T3 = () =&gt; void;
</code></pre>
<p><strong>实现原理</strong>：</p>
<p>与 <code>Exclude</code> 类似：</p>
<ol>
<li>通过条件类型<code>T extends U ? never : T</code> 对 <code>T</code> 参数进行判别：
<ul>
<li>如果 <code>T</code> 可赋值给 <code>U</code> ，那么返回 <code>T</code>。</li>
<li>如果 <code>T</code> 不可赋值给 <code>U</code> ，那么返回 <code>never</code>（即排除掉<code>T</code>）。</li>
</ul>
</li>
<li>通过<strong>分布式条件类型</strong>，如果 <code>T</code> 为联合类型，则将条件类型的结果分发为<strong>联合类型</strong>。</li>
</ol>
<pre><code class="language-ts">type Extract&lt;T, U&gt; = T extends U ? T : never;
</code></pre>
<h2 id="picktk">Pick&lt;T,K&gt;</h2>
<p><strong>作用</strong>：在 <code>T</code> 中，摘选出 <code>K</code> 属性。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
}

// 从 Person 中摘选出 name 属性
type PickPerson = Pick&lt;Person, &quot;name&quot;&gt;;

const tom: PickPerson = {
  name: &quot;Tom&quot;,
};
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过 <code>K extends keyof T</code> 对 <code>K</code> 参数进行约束，将其约束为 <code>T</code> 的键值范围内。</li>
<li>通过 <code>in</code> 对键值集合 <code>K</code> 进行遍历，然后生成类型为 <code>T</code> 的键值对集合。</li>
</ol>
<pre><code class="language-ts">type Pick&lt;T, K extends keyof T&gt; = {
  [P in K]: T[P];
};
</code></pre>
<h2 id="omittk">Omit&lt;T,K&gt;</h2>
<p><strong>作用</strong>：在 <code>T</code> 中，剔除掉 <code>K</code> 属性。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
}

// 从 Person 中剔除掉 name 属性
type OmitPerson = Pick&lt;Person, &quot;name&quot;&gt;;

const tom: PickPerson = {
  age: 18,
};
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过 <code>K extends keyof T</code> 对 <code>K</code> 参数进行约束，将其约束为 <code>T</code> 的键值范围内。</li>
<li>通过 <code>Exclude&lt;keyof T, K&gt;</code> 将类型集合 <code>T</code> 中的 <code>K</code> 类型排除掉。</li>
<li>通过 <code>Pick&lt;T,Exclude&lt;keyof T, K&gt;&gt;</code> 在 <code>T</code> 中摘选出排除掉 <code>K</code> 的 <code>T</code> 的属性。</li>
</ol>
<pre><code class="language-ts">type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;
</code></pre>
<h2 id="returntypet">ReturnType&lt;T&gt;</h2>
<p><strong>作用</strong>：获取函数的返回值类型。</p>
<p><strong>示例</strong>：</p>
<pre><code class="language-ts">type Fun = () =&gt; string;

// 获取 Fun 返回值的类型
type T1 = ReturnType&lt;Fun&gt;; // T1 = string

type T2 = ReturnType&lt;() =&gt; { x: number; y: number }&gt;;
// T2 = { x: number, y: number }
</code></pre>
<p><strong>实现原理</strong>：</p>
<ol>
<li>通过 <code>extends</code> 对 <code>T</code> 参数进行约束，<code>(...args: any) =&gt; any</code> 表示一个函数类型，即 <code>T</code> 参数的类型必须是一个<strong>函数类型</strong>。</li>
<li><code>T extends U ? X : Y</code> 是条件类型（注意和之前表示约束的 <code>extends</code> 做区分），其中 <code>T</code> 是泛型参数，<code>U</code> 是<strong>条件部分</strong>，<code>X</code> 是符合条件的返回结果，<code>Y</code> 是不符合条件的返回结果。</li>
<li>推断类型 <code>infer</code> 的作用是：在条件类型内部声明一个<strong>类型变量</strong>。<code>(...args: any) =&gt; infer R</code> 是条件类型的<strong>条件部分</strong>，它声明了一个类型变量 <code>R</code> ，用来存储函数的返回类型。</li>
<li><code>T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any</code>表示：
<ul>
<li>如果 <code>T</code> 是函数类型（<code>(...args: any) =&gt; infer R</code>），则返回 <code>R</code> , 即函数的返回类型。</li>
<li>如果 <code>T</code> 不是函数类型（<code>(...args: any) =&gt; infer R</code>），则返回 <code>any</code>。</li>
</ul>
</li>
</ol>
<pre><code class="language-ts">type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (
  ...args: any
) =&gt; infer R
  ? R
  : any;
</code></pre>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://typescript.bootcss.com/">TypeScript 中文手册</a></li>
<li><a href="https://github.com/chenxiaochun/blog/issues/67">TypeScript 内置工具泛型</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 泛型总结]]></title>
        <id>https://wuwenbang.github.io/post/typescript-fan-xing-zong-jie/</id>
        <link href="https://wuwenbang.github.io/post/typescript-fan-xing-zong-jie/">
        </link>
        <updated>2022-02-24T13:47:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-泛型是什么">1. 泛型是什么？</h2>
<ul>
<li>
<p>官方的定义是：</p>
<blockquote>
<p>**泛型（Generics）**是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
</blockquote>
</li>
<li>
<p>通俗的解释是：泛型是类型系统中的<strong>参数</strong>，就像函数的参数一样，只不过函数的参数传递的是值，而泛型传递的是<strong>类型</strong>。他只出现在现在<strong>函数</strong>，<strong>接口</strong>，和<strong>类</strong>中，主要作用是为了类型的复用。</p>
</li>
</ul>
<ul>
<li>设计泛型的关键目的：是在成员之间提供有意义的约束，这些成员可以是：函数参数、函数返回值、类的实例成员和类的方法。</li>
</ul>
<p>可能这么讲会有一些抽象，接下来我们以泛型函数为例，举一个简单的例子：</p>
<ol>
<li>首先我们来定义一个通用的 <code>identity</code> 函数，该函数接收一个<code>number</code>类型的参数，并直接返回这个值：</li>
</ol>
<pre><code class="language-ts">function identity(value: number): number {
  return value;
}
identity(1); // ok

identity(&quot;hello&quot;); // error
// 编译器报错： Argument of type 'string' is not assignable to parameter of type 'number'.ts(2345)
</code></pre>
<ol start="2">
<li>现在，<code>identity</code> 函数能且只能传入 <code>number</code> 类型的参数，如果我想传入 <code>string</code> 类型的 <code>TypeScript</code> 编译器会报错，那么该怎么办呢？或许你会想到 <code>any</code> 类型。</li>
</ol>
<pre><code class="language-ts">function identity(value: any) {
  return value;
}
identity(1); // ok
identity(&quot;hello&quot;); // ok
</code></pre>
<ol start="3">
<li>好吧，传入 <code>any</code> 确实可以生效，但我们失去了定义应该返回哪种类型的能力，并且在这个过程中也丧失了 <code>TypeScript</code> 的类型保护作用。</li>
</ol>
<p>我们的目标是让 <code>identity</code> 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用 <strong>泛型函数</strong> 来解决这个问题：</p>
<h2 id="2-泛型函数">2. 泛型函数</h2>
<p>定义泛型函数：</p>
<pre><code class="language-ts">function identity&lt;T&gt;(value: T): T {
  return value;
}
identity&lt;number&gt;(1); // ok
identity&lt;string&gt;(&quot;hello&quot;); // ok
</code></pre>
<p>对于刚接触 <code>TypeScript</code> 泛型的读者来说，首次看到 <code>&lt;T&gt;</code> 语法会感到陌生。但这没什么可担心的，就像传递参数一样，通过参数变量 <code>T</code>，把用户想要传入的类型，链式传递到后面函数的类型定义中去。</p>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2020/6/10/1729b3d9774a21ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="泛型传递" loading="lazy"></figure>
<p>（图片来源：<a href="https://juejin.cn/post/6844904184894980104">掘金阿宝哥</a>）</p>
<p>参考上面的图片，通过 <code>&lt;T&gt;</code> 声明 <strong>类型变量 <code>T</code></strong>，然后在后面的函数参数类型声明、和函数返回值类型声明中使用：<code>(value: T): T</code>。</p>
<p>理论上，<code>&lt; &gt;</code>类可以声明任意字符作为类型变量，但在定义泛型时通常用<code>T</code>作为类型变量名称，其中 <code>T</code> 代表 <code>Type</code>。当然，除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p>
<ul>
<li>K（Key）：表示对象中的键类型。</li>
<li>V（Value）：表示对象中的值类型。</li>
<li>E（Element）：表示元素类型。</li>
<li>U（T 后面的字符）：表示第二个类型参数（以此类推）。</li>
</ul>
<p>很多时候并不是只能定义一个类型变量，我们可以引入更多的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p>
<pre><code class="language-ts">function identity&lt;T, U&gt;(value: T, message: U): T {
  console.log(message);
  return value;
}

console.log(identity&lt;Number, string&gt;(100, &quot;Hello Generics&quot;));
// Hello Generics
// 100
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2020/6/10/1729b3dbccc38ea7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="泛型传递" loading="lazy"></figure>
<p>（图片来源：<a href="https://juejin.cn/post/6844904184894980104">掘金阿宝哥</a>）</p>
<p>除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：</p>
<pre><code class="language-ts">function identity&lt;T, U&gt;(value: T, message: U): T {
  console.log(message);
  return value;
}

console.log(identity(100, &quot;Hello Generics&quot;));
// Hello Generics
// 100
</code></pre>
<h2 id="3-泛型接口">3. 泛型接口</h2>
<p>定义泛型接口：</p>
<pre><code class="language-ts">interface GenericInterface&lt;T&gt; {
  data: T;
}
</code></pre>
<p>接口泛型的使用方式和函数类似，我们可以通过<code>&lt;T&gt;</code>来声明参数变量<code>T</code>，并将其用在后面接口属性的类型定义上。</p>
<p>泛型接口常用于定义那些，需要用户自定义类型的对象上，最常见的就是 网络请求的响应对象了，以<code>Axios</code>为例：<br>
假设我们通过 <code>axios.get</code> 发起网络请求，我们可以通过<code>axios.get&lt;DataType&gt;</code>传入<code>data</code>的类型，最后拿响应 <code>res</code> 时，我们就可以明确的知道<code>data</code>的数据类型 ：</p>
<pre><code class="language-ts">interface DataType {
  id: number;
  message: string;
}
axios.get&lt;DataType&gt;(&quot;https://www.xxx.com&quot;).then((res) =&gt; {
  console.log(res.data.message);
});
</code></pre>
<p>其中<code>axios</code>实例，以及响应<code>res</code>的泛型接口如下定义：</p>
<pre><code class="language-ts">interface AxiosInstance {
  // ...
  get&lt;T = any, R = AxiosResponse&lt;T&gt;&gt;(
    url: string,
    config?: AxiosRequestConfig
  ): Promise&lt;R&gt;;
}

interface AxiosResponse&lt;T = any&gt; {
  data: T;
  status: number;
  statusText: string;
  headers: any;
  config: AxiosRequestConfig;
  request?: any;
}
</code></pre>
<p>其中响应的 <code>data</code> 是 <code>axios</code> 不知道的，所以 <code>axios</code> 通过泛型的方式，将类型<code>T</code>传递给后面的<code>data</code>属性。</p>
<h2 id="4-泛型类">4. 泛型类</h2>
<p>在类中使用泛型也很简单，我们只需要在类名后面，使用 <code>&lt;T, ...&gt;</code> 的语法定义任意多个类型变量。</p>
<p>定义泛型类：</p>
<pre><code class="language-ts">interface GenericInterface&lt;U&gt; {
  value: U;
  getValue: () =&gt; U;
}

class GenericClass&lt;T&gt; implements GenericInterface&lt;T&gt; {
  value: T;

  constructor(value: T) {
    this.value = value;
  }

  getValue(): T {
    return this.value;
  }
}

const myNumberClass = new GenericClass&lt;number&gt;(10);
console.log(myNumberClass.getValue()); // 10

const myStringClass = new GenericClass&lt;string&gt;(&quot;Hello Generics!&quot;);
console.log(myStringClass.getValue()); // Hello Generics!
</code></pre>
<p>接下来我们以实例化 <code>myNumberClass</code> 为例，来分析一下其调用过程：</p>
<ol>
<li>在实例化 <code>GenericClass</code> 对象时，我们传入 <code>number</code> 类型和构造函数参数值 68；</li>
<li>之后在 <code>GenericClass</code> 类中，类型变量 <code>T</code> 的值变成 <code>number</code> 类型；</li>
<li><code>GenericClass</code> 类实现了 <code>GenericInterface&lt;T&gt;</code>，而此时 <code>T</code> 表示 <code>number</code> 类型，因此等价于该类实现了 <code>GenericInterface&lt;number&gt;</code> 接口；</li>
<li>而对于 <code>GenericInterface&lt;U&gt;</code> 接口来说，类型变量 <code>U</code> 也变成了 <code>number</code>。这里我有意使用不同的变量名，以表明类型值沿链向上传播，且与变量名无关。</li>
</ol>
<h2 id="5-泛型约束">5. 泛型约束</h2>
<p>有时候我们希望限制泛型变量接受的类型（比如我只希望接受拥有<code>.length</code>属性的类型），我们就需要<strong>泛型约束</strong>。下面我们来举几个例子，介绍一下如何使用泛型约束。</p>
<h3 id="51-确保属性存在">5.1 确保属性存在</h3>
<p>有时候，我们希望类型变量对应的类型上存在某些属性。这时，除非我们显式地将特定属性定义为类型变量，否则编译器不会知道它们的存在。<br>
一个很好的例子是在处理字符串或数组时，我们会假设 <code>length</code> 属性是可用的。让我们再次使用 <code>identity</code> 函数并尝试输出参数的长度：</p>
<pre><code class="language-ts">function identity&lt;T&gt;(arg: T): T {
  console.log(arg.length); // error: T doesn't have .length
  return arg;
}
</code></pre>
<p>在这种情况下，编译器将不会知道 <code>T</code> 确实含有 <code>length</code> 属性，尤其是在可以将任何类型赋给类型变量 <code>T</code> 的情况下。我们需要做的就是让类型变量 <code>extends</code> 一个含有我们所需属性的接口，比如这样：</p>
<pre><code class="language-ts">interface Length {
  length: number;
}

function identity&lt;T extends Length&gt;(arg: T): T {
  console.log(arg.length); // ok: 可以获取length属性
  return arg;
}
</code></pre>
<p><code>T extends Length</code> 用于告诉编译器，我们支持已经实现 <code>Length</code> 接口的任何类型。</p>
<p>之后，当我们使用不含有 <code>length</code> 属性的对象作为参数调用 <code>identity</code> 函数时，<code>TypeScript</code> 会提示相关的错误信息：</p>
<pre><code class="language-ts">identity(10); // Error
// Argument of type '68' is not assignable to parameter of type 'Length'.(2345)
</code></pre>
<h3 id="52-检查对象上的键是否存在">5.2 检查对象上的键是否存在</h3>
<p>泛型约束的另一个常见的使用场景就是检查对象上的键是否存在。不过在看具体示例之前，我们得来了解一下 <code>keyof</code> 操作符，该操作符可以用于<strong>获取某种类型的所有键</strong>，其返回类型是<strong>联合类型</strong>。我们来举个 <code>keyof</code> 的使用示例：</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot; | &quot;location&quot;
type K2 = keyof Person[]; // number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...
</code></pre>
<p>通过 <code>keyof</code> 操作符，我们就可以获取指定类型的所有键，之后我们就可以结合前面介绍的 <code>extends</code> 约束，即限制输入的属性名包含在 <code>keyof</code> 返回的联合类型中。具体的使用方式如下：</p>
<pre><code class="language-ts">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
  return obj[key];
}

const obj = {
  name: &quot;tom&quot;,
};

getProperty(obj, &quot;name&quot;); // ok
getProperty(obj, &quot;age&quot;); // error 属性名 age 不存在 obj 上
</code></pre>
<p>在以上的 <code>getProperty</code> 函数中，我们通过<code>K extends keyof T</code> 确保参数 <code>key</code> 一定是对象中含有的键，这样就不会发生运行时错误。这是一个类型安全的解决方案，与简单调用 <code>let value = obj[key];</code> 不同。</p>
<p>在以上示例中，对于 <code>getProperty(obj, &quot;age&quot;)</code> 这个表达式，<code>TypeScript</code> 编译器会提示以下错误信息：</p>
<pre><code class="language-ts">// 编译器报错：Argument of type '&quot;age&quot;' is not assignable to parameter of type '&quot;name&quot;'.ts(2345)
</code></pre>
<p>很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。</p>
<h2 id="6-泛型参数默认类型">6. 泛型参数默认类型</h2>
<p>我们都知道 <code>JavaScript</code> 的函数参数可以设置初始值（<code>defalut value</code>），类似地，我们也可以为泛型参数设置默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。<br>
泛型参数默认类型与普通函数默认值类似，对应的语法很简单，即 <code>&lt;T=Default Type&gt;</code>，对应的使用示例如下：</p>
<pre><code class="language-ts">interface MyObject&lt;T = string&gt; {
  id: T;
}

const numObject: MyObject = { id: &quot;abc&quot; };
const strObject: MyObject&lt;number&gt; = { id: 123 };
</code></pre>
<p>泛型参数的默认类型遵循以下规则：</p>
<ul>
<li>有默认类型的类型参数被认为是<strong>可选的</strong>。</li>
<li>必选的类型参数不能在可选的类型参数后。</li>
<li>如果类型参数有约束，类型参数的默认类型必须满足这个约束。</li>
<li>当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。</li>
<li>如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。</li>
</ul>
<h2 id="7-泛型条件类型">7. 泛型条件类型</h2>
<p>通过<strong>泛型条件类型</strong>，我们可以根据某些条件得到不同的类型，这里所说的条件是类型兼容性约束。尽管以上代码中使用了 <code>extends</code> 关键字，也不一定要强制满足继承关系，而是检查是否满足结构兼容性。</p>
<p>条件类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：<br>
<code>T extends U ? X : Y</code><br>
以上表达式的意思是：若 <code>T</code> 能够赋值给 <code>U</code>（<code>T</code> 属于与 <code>U</code>的子类），那么类型是 <code>X</code>，否则为 <code>Y</code>。在条件类型表达式中，我们通常还会结合 <code>infer</code> 关键字，实现类型抽取：</p>
<pre><code class="language-ts">interface MyObject&lt;T = any&gt; {
  key: T;
}

type StrObject = MyObject&lt;string&gt;;
type NumObject = MyObject&lt;number&gt;;

type ObjectMember&lt;T&gt; = T extends MyObject&lt;infer V&gt; ? V : never;
type StrObjectMember = ObjectMember&lt;StrObject&gt;; // string
type NumObjectMember = ObjectMember&lt;NumObject&gt;; // number
</code></pre>
<p>在上面示例中，当类型 <code>T</code> 满足 <code>T extends MyObject</code> 约束时，我们会使用 <code>infer</code> 关键字声明了一个类型变量 <code>V</code>，并返回该类型，否则返回 <code>never</code> 类型。</p>
<h2 id="8-参考文章">8. 参考文章</h2>
<ul>
<li><a href="https://typescript.bootcss.com/basic-types.html">TypeScript 中文手册</a></li>
<li><a href="https://juejin.cn/post/6872111128135073806#heading-28">一份不可多得的 TS 学习指南</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 断言总结]]></title>
        <id>https://wuwenbang.github.io/post/typescript-duan-yan-zong-jie/</id>
        <link href="https://wuwenbang.github.io/post/typescript-duan-yan-zong-jie/">
        </link>
        <updated>2022-02-24T13:46:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-类型断言">1. 类型断言</h2>
<p>在使用 <code>TypeScript</code> 的过程中，你可能会遇到这种情况：你比 <code>TypeScript</code> 更加清楚某个值的类型。<br>
比如你从异步请求中拿到一个类型为<code>any</code>的值，但你清楚的知道这个值就是<code>string</code>类型，这个时候你可以通过<strong>类型断言</strong>方式告诉编译器：&quot;嘿！相信我，我知道我在干什么！&quot;。类型断言有点类似于其他语言的类型转换，但它没有运行时的影响，只是在编译阶段起作用。<br>
类型断言有两种形式：</p>
<h3 id="11-尖括号语法">1.1 尖括号语法</h3>
<ul>
<li>形式：<code>&lt;类型&gt;变量名</code></li>
</ul>
<pre><code class="language-ts">let value: any = &quot;this is a string&quot;;
let length: number = (&lt;string&gt;value).length;
</code></pre>
<h3 id="12-as-语法">1.2 as 语法</h3>
<ul>
<li>形式：<code>变量名 as 类型</code></li>
</ul>
<pre><code class="language-ts">let value: any = &quot;this is a string&quot;;
let length: number = (value as string).length;
</code></pre>
<h2 id="2-非空断言">2. 非空断言</h2>
<p>当你明确知道某个值不可能为 <code>undefined</code> 和 <code>null</code> 时，你可以用 在变量后面加上一个 <code>!</code>（非空断言符号）来告诉编译器：&quot;嘿！相信我，我确信这个值不为空！&quot;。<br>
非空断言具体的使用场景如下：</p>
<pre><code class="language-ts">function fun(value: string | undefined | null) {
  const str: string = value; // error value 可能为 undefined 和 null
  const str: string = value!; //ok
  const length: number = value.length; // error value 可能为 undefined 和 null
  const length: number = value!.length; //ok
}
</code></pre>
<h2 id="3-确定赋值断言">3. 确定赋值断言</h2>
<p><code>TypeScript</code> 的确定赋值断言，允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而告诉 <code>TypeScript</code> 该属性会被明确地赋值。</p>
<pre><code class="language-ts">let name!: string;
</code></pre>
<p>上述表达式就是对编译器说：&quot;有一个名为 <code>name</code> 的属性，其类型为 <code>string | undefined</code>。它以值 <code>undefined</code> 开始。但每次获取或设置该属性时，我都希望将其视为类型 <code>string。</code>&quot;</p>
<p>为了更好地理解它的作用，我们来看个具体的例子：</p>
<pre><code class="language-ts">let count: number;
initialize();

// Variable 'count' is used before being assigned.(2454)
console.log(2 * count); // Error

function initialize() {
  count = 10;
}
</code></pre>
<p>很明显该异常信息是说变量 <code>count</code> 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：</p>
<pre><code class="language-ts">let count!: number;
initialize();
console.log(2 * count); // Ok

function initialize() {
  count = 10;
}
</code></pre>
<h2 id="4-参考文章">4. 参考文章</h2>
<ul>
<li><a href="https://typescript.bootcss.com/basic-types.html">TypeScript 中文手册</a></li>
<li><a href="https://juejin.cn/post/6872111128135073806#heading-28">一份不可多得的 TS 学习指南</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript Type 和 Interface 的异同]]></title>
        <id>https://wuwenbang.github.io/post/typescript-type-he-interface-de-yi-tong/</id>
        <link href="https://wuwenbang.github.io/post/typescript-type-he-interface-de-yi-tong/">
        </link>
        <updated>2022-02-24T13:40:58.000Z</updated>
        <content type="html"><![CDATA[<p>在使用<code>TypeScript</code>的时候，我们常常使用<code>interface</code>和<code>type</code>去描述复杂数据的形状和类型，比如<code>对象</code>和<code>函数</code>。由于他们的使用方式高度相似，一度让我觉得他们是可以相互替换的。但是随着更加深入的了解，我发现了他们之间的一些异同点，然我们一起来看看吧。</p>
<h2 id="1-inteface-接口">1. Inteface 接口</h2>
<p>在面向对象语言中，<code>接口</code>是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。<br>
<code>TypeScript</code> 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对<code>对象的形状（Shape）</code>进行描述。</p>
<h3 id="11-接口的作用">1.1 接口的作用</h3>
<ol>
<li>描述对象</li>
</ol>
<pre><code class="language-ts">interface Person {
  name: string;
  age: number;
  run: () =&gt; void;
}
let tom: Person = {
  name: &quot;Tom&quot;,
  age: 23,
};
</code></pre>
<ol start="2">
<li>描述函数</li>
</ol>
<pre><code class="language-ts">interface Action {
  (): void;
}
const sayHi: Action = () =&gt; {
  console.log(&quot;Hi!&quot;);
};
</code></pre>
<h3 id="12-可选属性与只读属性">1.2 可选属性与只读属性</h3>
<pre><code class="language-ts">interface Person {
  readonly name: string; // 只读属性：只可读取，不可更改
  age?: number; // 可选属性：该对象可以拥有，也可以没有该属性
}
let tom: Person = {
  name: &quot;Tom&quot;,
};
tom.name = &quot;Jack&quot;; // error 不可更改
</code></pre>
<h3 id="13-任意属性">1.3 任意属性</h3>
<p>有时候我们希望我们定义的对象可以拥有一个任意属性，这时我们可以使用<code>索引签名</code>的形式来满足上述要求。</p>
<pre><code class="language-ts">interface Person {
  name: string;
  age?: number;
  [propName: string]: any;
}

const tom = { name: &quot;Tom&quot; };
const jack = { name: &quot;Jack&quot;, age: 5 };
const susan = { name: &quot;Susan&quot;, sex: &quot;famale&quot; };
</code></pre>
<h2 id="2-type-alias-类型别名">2. Type Alias 类型别名</h2>
<h3 id="21-类型别名的定义">2.1 类型别名的定义</h3>
<p><code>type（Type Alias 类型别名）</code>会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p>
<pre><code class="language-ts">// 基本类型
type Count = number;
// 函数
type Fun = () =&gt; void;
// 对象
type Person = {
  name: string;
  age: number;
};
</code></pre>
<h2 id="3-inteface-和-type-的相同点">3. Inteface 和 Type 的相同点</h2>
<h3 id="31-都可以用来描述对象或函数">3.1 都可以用来描述对象或函数</h3>
<pre><code class="language-ts">// interface
interface Point {
  x: number;
  y: number;
}

interface SetPoint {
  (x: number, y: number): void;
}
</code></pre>
<pre><code class="language-ts">// type alias
type Point = {
  x: number;
  y: number;
};

type SetPoint = (x: number, y: number) =&gt; void;
</code></pre>
<h3 id="32-都可以扩展">3.2 都可以扩展</h3>
<p>两者都可以用来扩展，但是扩展方式不同，<code>接口</code>的扩展就是继承，通过<code>extends</code>来实现。<code>类型别名</code>的扩展就是<code>交叉类型</code>，通过<code>&amp;</code>来实现。</p>
<pre><code class="language-ts">// 接口扩展
interface PointX {
  x: number;
}

interface Point extends PointX {
  y: number;
}
</code></pre>
<pre><code class="language-ts">// 类型别名扩展
type PointX = {
  x: number;
};

type Point = PointX &amp; {
  y: number;
};
</code></pre>
<p>PS：接口可以扩展类型别名，同理，类型别名也可以扩展接口。</p>
<h2 id="4-inteface-和-type-的不同点">4. Inteface 和 Type 的不同点</h2>
<h3 id="41-type-可以声明基本类型而-interface-不行">4.1 type 可以声明基本类型，而 interface 不行</h3>
<ul>
<li><code>type</code> 可以声明基本类型</li>
</ul>
<pre><code class="language-ts">type Count = number;
type Color = &quot;Red&quot; | &quot;Blue&quot;;
</code></pre>
<ul>
<li><code>interface</code> 只能用来声明复杂类型（对象和函数）</li>
</ul>
<h3 id="42-扩展时表现不同">4.2 扩展时表现不同</h3>
<ul>
<li>扩展<code>接口</code>时，TS 将检查扩展的接口是否可以赋值给被扩展的接口。</li>
</ul>
<pre><code class="language-ts">interface A {
  good(x: number): string;
  bad(x: number): string;
}
interface B extends A {
  good(x: string | number): string;
  bad(x: number): number; // Interface 'B' incorrectly extends interface 'A'.
  // Types of property 'bad' are incompatible.
  // Type '(x: number) =&gt; number' is not assignable to type '(x: number) =&gt; string'.
  // Type 'number' is not assignable to type 'string'.
}
</code></pre>
<ul>
<li>但使用<code>交叉类型</code>时则不会出现这种情况。我们将上述代码中的接口改写成类型别名，把 extends 换成交集运算符&amp;，TS 将尽其所能把扩展和被扩展的类型组合在一起，而不会抛出编译时错误。</li>
</ul>
<pre><code class="language-ts">type A = {
  good(x: number): string;
  bad(x: number): string;
};
type B = A &amp; {
  good(x: string | number): string;
  bad(x: number): number;
};
// ok
</code></pre>
<h3 id="43-多次定义时表现不同">4.3 多次定义时表现不同</h3>
<p><code>接口</code>多次的声明会合并。<code>类型别名</code>不能重复声明。</p>
<ul>
<li><code>接口</code>可以定义多次，多次的声明会合并。</li>
</ul>
<pre><code class="language-ts">interface Point {
  x: number;
}
interface Point {
  y: number;
}
const point: Point = { x: 1 }; //error Property 'y' is missing in type '{ x: number; }' but required in type 'Point'.

const point: Point = { x: 1, y: 1 }; // ok
</code></pre>
<ul>
<li>但是<code>类型别名</code>如果定义多次，会报错。</li>
</ul>
<pre><code class="language-ts">type Point = {
  x: number; //error Duplicate identifier 'A'.
};

type Point = {
  y: number; //error Duplicate identifier 'A'.
};
</code></pre>
<h2 id="到底应该用哪个">到底应该用哪个？</h2>
<p>如果<code>接口</code>和<code>类型别名</code>都能满足的情况下，到底应该用哪个是我们关心的问题。</p>
<p>感觉哪个都可以，但是强烈建议大家只要能用<code>接口</code>实现的就<strong>优先使用接口</strong>，接口满足不了的再用<code>类型别名</code>。</p>
<p>为什么会这么建议呢？其实在 TS 的 wiki 中有说明。具体的文章地址在这里：<a href="https://github.com/microsoft/TypeScript/wiki/Performance#writing-easy-to-compile-code">TS wiki</a><br>
以下是<code>Preferring Interfaces Over Intersections</code>的译文：</p>
<blockquote>
<p>大多数时候，对于声明一个对象，类型别名和接口表现的很相似。</p>
<pre><code class="language-ts">interface Foo {
  prop: string;
}
type Bar = { prop: string };
</code></pre>
<p>然而，当你需要通过组合两个或者两个以上的类型实现其他类型时，可以选择使用接口来扩展类型，也可以通过交叉类型（使用&amp;创造出来的类型）来完成，这就是二者开始有区别的时候了。</p>
<ul>
<li>接口会创建一个单一扁平对象类型来检测属性冲突，当有属性冲突时会提示，而交叉类型只是递归的进行属性合并，在某种情况下可能产生 never 类型</li>
<li>接口通常表现的更好，而交叉类型做为其他交叉类型的一部分时，直观上表现不出来，还是会认为是不同基本类型的组合</li>
<li>接口之间的继承关系会缓存，而交叉类型会被看成组合起来的一个整体</li>
<li>在检查一个目标交叉类型时，在检查到目标类型之前会先检查每一个组分</li>
</ul>
</blockquote>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://typescript.bootcss.com/interfaces.html">TypeScript 中文手冊</a></li>
<li><a href="https://juejin.cn/post/6844904114925600776#heading-11">TypeScript Interface vs Type 知多少</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript 基础类型]]></title>
        <id>https://wuwenbang.github.io/post/typescript-ji-chu-lei-xing/</id>
        <link href="https://wuwenbang.github.io/post/typescript-ji-chu-lei-xing/">
        </link>
        <updated>2022-02-24T13:31:44.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>Number 类型</li>
</ol>
<pre><code class="language-ts">let count: number = 10;
// ES5：var count = 10;
</code></pre>
<h3 id="2-string-类型">2. String 类型</h3>
<pre><code class="language-ts">let name: string = &quot;hello world&quot;;
// ES5：var name = 'hello world';
</code></pre>
<h3 id="3-boolean-类型">3. Boolean 类型</h3>
<pre><code class="language-ts">let isCheck: boolean = false;
// ES5：var isCheck = false;
</code></pre>
<h3 id="4-symbol-类型">4. Symbol 类型</h3>
<pre><code class="language-ts">const sym = Symbol();
let obj = {
  [sym]: &quot;hello world&quot;,
};

console.log(obj[sym]); // hello world
</code></pre>
<h3 id="5-null-和-undefined-类型">5. Null 和 Undefined 类型</h3>
<p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code>。</p>
<pre><code class="language-ts">let u: undefined = undefined;
let n: null = null;
</code></pre>
<h3 id="6-array-类型">6. Array 类型</h3>
<p>TypeScript 里，数组类型有两种表达形式：</p>
<ol>
<li>直接表示：<code>type[]</code>。</li>
<li>用泛型的方式表示：<code>Array&lt;type&gt;</code>。</li>
</ol>
<pre><code class="language-ts">let array: number[] = [1, 2, 3];
// ES5：var array = [1,2,3];

let array: Array&lt;number&gt; = [1, 2, 3]; // Array&lt;number&gt;泛型语法
// ES5：var array = [1,2,3];
</code></pre>
<h3 id="7-tuple元组-类型">7. Tuple（元组） 类型</h3>
<p><code>数组（Array）</code>合并了相同类型的值，而<code>元组（Tuple）</code>合并了不同类型的值</p>
<pre><code class="language-ts">let array: number[] = [100, 200];
let tuple: [number, string] = [100, &quot;200&quot;];
</code></pre>
<p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p>
<pre><code class="language-ts">let tuple: [string, number];
tuple[0] = &quot;Jack&quot;;
tuple[1] = 22;

tuple[0].substr(1); //String独有方法
tuple[1].toFixed(2); //Number独有方法
</code></pre>
<p><code>元组（Tuple）</code>类型是固定长度，固定类型的</p>
<pre><code class="language-ts">let tuple: [string, number];
tuple = [&quot;jack&quot;]; //❌
tuple = [100, &quot;juck&quot;]; //❌
tuple = [&quot;juck&quot;, 100]; //✅
</code></pre>
<p><code>React</code>中的<code>useState</code>返回的就是元组类型：</p>
<pre><code class="language-ts">// 类型定义：返回元组类型 [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;]
function useState&lt;S&gt;(
  initialState: S | (() =&gt; S)
): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];
// 元组：解构赋值
const [state, setState] = useState(0);
</code></pre>
<p>总结：<code>数组（Array）</code>和<code>元组（Tuple）</code>的差异：</p>
<ol>
<li><code>Array</code>类型统一，<code>Tuple</code>类型可以不一。</li>
<li><code>Array</code>长度不限，<code>Tuple</code>长度限定。</li>
</ol>
<h3 id="8-enum枚举类型">8. Enum（枚举）类型</h3>
<p>使用枚举我们可以定义一些带名字的常量，以表达限定在一定范围内值。 TypeScript 支持数字的和基于字符串的枚举。</p>
<h4 id="1-数字枚举">1. 数字枚举</h4>
<pre><code class="language-ts">enum Direction {
  NORTH,
  SOUTH,
  EAST,
  WEST,
}

let dir: Direction = Direction.NORTH; //let dir = 0
</code></pre>
<p>默认情况下，<code>NORTH</code> 的初始值为 <code>0</code>，其余的成员会自动<code>+1</code>增长。换句话说，<code>Direction.SOUTH</code>值为<code>1</code>，<code>Direction.EAST</code>值为<code>2</code>，<code>Direction.WEST</code>值为<code>3</code>。</p>
<p>当然我们也可以设置 NORTH 的初始值，比如：</p>
<pre><code class="language-ts">enum Direction {
  NORTH = 3,
  SOUTH, //4
  EAST, //5
  WEST, //6
}
</code></pre>
<h4 id="2-字符串枚举">2. 字符串枚举</h4>
<p>在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>
<pre><code class="language-ts">enum Direction {
  NORTH = &quot;NORTH&quot;,
  SOUTH = &quot;SOUTH&quot;,
  EAST = &quot;EAST&quot;,
  WEST = &quot;WEST&quot;,
}
let dir: Direction = Direction.NORTH; //let dir = 'NORTH'
</code></pre>
<p>比起<code>枚举</code>类型，我更推荐使用<code>联合类型</code>来表达对于一组值的约束：</p>
<pre><code class="language-ts">const Direction = &quot;NORTH&quot; | &quot;SOUTH&quot; | &quot;EAST&quot; | &quot;WEST&quot;;
let dir: Direction = &quot;NORTH&quot;;
</code></pre>
<h3 id="9-object-类型">9. Object 类型</h3>
<p><code>Object 类型</code>：它是所有 <code>Object</code> 类的实例的类型，它由以下两个接口来定义：</p>
<ol>
<li><code>Object</code> 接口定义了 <code>Object.prototype</code> 原型对象上的属性；</li>
</ol>
<pre><code class="language-ts">// node_modules/typescript/lib/lib.es5.d.ts
interface Object {
  constructor: Function;
  toString(): string;
  toLocaleString(): string;
  valueOf(): Object;
  hasOwnProperty(v: PropertyKey): boolean;
  isPrototypeOf(v: Object): boolean;
  propertyIsEnumerable(v: PropertyKey): boolean;
}
</code></pre>
<ol start="2">
<li><code>ObjectConstructor</code> 接口定义了 <code>Object</code> 类的属性。</li>
</ol>
<pre><code class="language-ts">// node_modules/typescript/lib/lib.es5.d.ts
interface ObjectConstructor {
  /** Invocation via `new` */
  new (value?: any): Object;
  /** Invocation via function calls */
  (value?: any): any;
  readonly prototype: Object;
  getPrototypeOf(o: any): any;
  // ···
}
</code></pre>
<p><code>Object</code> 类的所有实例都继承了 <code>Object</code> 接口中的所有属性。</p>
<h3 id="10-any-类型">10. Any 类型</h3>
<p>在 <code>TypeScript</code> 中，任何类型都可以被归为 <code>any</code> 类型。这让 <code>any</code> 类型成为了类型系统的顶级类型（也被称作全局超级类型）。</p>
<pre><code class="language-ts">let value: any = 666;
value = &quot;hello&quot;;
value = false;
value = {};
value = [];
</code></pre>
<p><code>any</code>类型为从<code>JavaScript</code>到<code>TypeScript</code>提供了平稳的过渡方式：你可以将任意类型赋值给<code>any</code>类型，同时也可以对 <code>any</code> 类型的值执行任何操作，而无需做任何形式的静态类型检查。</p>
<pre><code class="language-ts">let value: any;

value.foo.bar; //✅
value.trim(); // ✅
value(); // ✅
new value(); // ✅
value[0][1]; // ✅
</code></pre>
<p>在许多场景下，这太宽松了。使用 <code>any</code> 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 <code>any</code> 类型，就无法使用 <code>TypeScript</code> 提供的大量的保护机制。为了解决 <code>any</code> 带来的问题，<code>TypeScript 3.0</code> 引入了 <code>unknown</code> 类型。</p>
<h3 id="11-unknown-类型">11. Unknown 类型</h3>
<p>就像所有类型都可以赋值给 <code>any</code>，所有类型也都可以赋值给 <code>unknown</code>。</p>
<pre><code class="language-ts">let value: unknown = 666;
value = &quot;hello&quot;;
value = false;
value = {};
value = [];
</code></pre>
<p>但是你不能将<code>unknown</code>类型赋值给一个已经确定的类型：即<code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。</p>
<pre><code class="language-ts">let value: unknown;

let value1: unknown = value; // ✅
let value2: any = value; // ✅
let value3: boolean = value; // ❌
let value4: number = value; // ❌
let value5: string = value; // ❌
let value6: object = value; // ❌
let value7: any[] = value; // ❌
let value8: Function = value; // ❌
</code></pre>
<p>同时<code>unknown</code>也无法像<code>any</code>那样执行任意操作：</p>
<pre><code class="language-ts">let value: unknown;

value.foo.bar; // ❌
value.trim(); // ❌
value(); // ❌
new value(); // ❌
value[0][1]; // ❌
</code></pre>
<p>总结：<code>any</code>类型和<code>unknown</code>类型的异同：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>any</th>
<th>unknown</th>
</tr>
</thead>
<tbody>
<tr>
<td>被赋值</td>
<td>可以被赋予任意值</td>
<td>可以被赋予任意值</td>
</tr>
<tr>
<td>赋值</td>
<td>可以赋值给任意变量</td>
<td>只能赋值给 <code>any</code> 和 <code>unknown</code> 类型变量</td>
</tr>
<tr>
<td>操作</td>
<td>可以进行任意操作</td>
<td>所有操作被禁止</td>
</tr>
</tbody>
</table>
<h3 id="12-void-类型">12. Void 类型</h3>
<p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<pre><code class="language-ts">function doSomething(): void {
  console.log(&quot;do something&quot;);
}
</code></pre>
<p>需要注意的是，声明一个 <code>void</code> 类型的变量没有什么作用，因为在严格模式下，它的值只能为 <code>undefined：</code></p>
<pre><code class="language-ts">let unusable: void = undefined;
</code></pre>
<h3 id="13-never-类型">13. Never 类型</h3>
<p><code>never</code> 类型表示的是那些永不存在的值的类型。<br>
例如，<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>
<pre><code class="language-ts">// function 永远不会返回
function error(message: string): never {
  throw new Error(message);
}
</code></pre>
<p>又如，基础类型的<code>交叉类型</code>返回的也是<code>never</code>，应为他们之间永远不存在交集：</p>
<pre><code class="language-ts">let value = &quot;1&quot; &amp; 1; // never
</code></pre>
<p>在 <code>TypeScript</code> 中，可以利用 <code>never</code> 类型的特性来实现全面性检查，具体示例如下：</p>
<pre><code class="language-ts">type Foo = string | number;

function controlFlowAnalysisWithNever(foo: Foo) {
  if (typeof foo === &quot;string&quot;) {
    // 这里 foo 被收窄为 string 类型
  } else if (typeof foo === &quot;number&quot;) {
    // 这里 foo 被收窄为 number 类型
  } else {
    // foo 在这里是 never
    const check: never = foo;
  }
}
</code></pre>
<p>注意在 <code>else</code> 分支里面，我们把收窄为 <code>never</code> 的 <code>foo</code> 赋值给一个显示声明的 <code>never</code> 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 <code>Foo</code> 的类型：</p>
<pre><code class="language-ts">type Foo = string | number | boolean;
</code></pre>
<p>然而他忘记同时修改 <code>controlFlowAnalysisWithNever</code> 方法中的控制流程，这时候 <code>else</code> 分支的 <code>foo</code> 类型会被收窄为 <code>boolean</code> 类型，导致无法赋值给 <code>never</code> 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保<br>
<code>controlFlowAnalysisWithNever</code> 方法总是穷尽了 <code>Foo</code> 的所有可能类型。<br>
通过这个示例，我们可以得出一个结论：使用 <code>never</code> 避免出现新增了<code>联合类型</code>没有对应的实现，目的就是写出类型绝对安全的代码。</p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://typescript.bootcss.com/basic-types.html">TypeScript 中文手册</a></li>
<li><a href="https://juejin.cn/post/6872111128135073806#heading-28">一份不可多得的 TS 学习指南</a></li>
</ul>
]]></content>
    </entry>
</feed>