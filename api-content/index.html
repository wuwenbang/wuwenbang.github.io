{"posts":[{"title":"React Hooks 性能优化","content":"前言 现在越来越多人开始使用 React Hooks + 函数组件的方式构筑页面。函数组件简洁且优雅，通过 Hooks 可以让函数组件拥有内部的状态和副作用（生命周期），弥补了函数组件的不足。 但同时函数组件的使用也带来了一些额外的问题：由于函数式组件内部的状态更新时，会重新执行一遍函数，那么就有可能造成以下两点性能问题： 造成子组件的非必要重新渲染 造成组件内部某些代码（计算）的重复执行 好在 React 团队也意识到函数组件可能发生的性能问题，并提供了 React.memo、useMemo、useCallback 这些 API 帮助开发者去优化他们的 React 代码。在使用它们进行优化之前，我想我们需要明确我们使用它们的目的： 减少组件的非必要重新渲染 减少组件内部的重复计算 1 使用 React.memo 避免组件的重复渲染 在讲述 React.memo 的作用之前，我们先来思考一个问题：什么情况下需要重新渲染组件？ 一般来讲以下三种情况需要重新渲染组件： 组件内部 state 发生变化时 组件内部使用的 context 发生变化时 组件外部传递的 props 发生变化时 现在我们先只关注第 3 点：props 发生变化时重新渲染，这种情况是一种理想情况。因为如果一个父组件重新渲染，即使其子组件的 props 没有发生任何变化，这个子组件也会重新渲染，我们称这种渲染为非必要的重新渲染。这时 React.memo 就可以派上用场了。 首先 React.memo 是一个高阶组件。 高阶组件（Higher Order Component）类似一个工厂：将一个组件丢进去，然后返回一个被加工过的组件。 被 React.memo 包裹的组件在渲染前，会对新旧 props 进行浅比较： 如果新旧 props 浅比较相等，则不进行重新渲染（使用缓存的组件）。 如果新旧 props 浅比较不相等，则进行重新渲染（重新渲染的组件）。 上述的解释可能会比较抽象，我们来看一个具体的例子： import React, { useState } from 'react'; const Child = () =&gt; { console.log('Child 渲染了'); return &lt;div&gt;Child&lt;/div&gt;; }; const MemoChild = React.memo(() =&gt; { console.log('MemoChild 渲染了'); return &lt;div&gt;MemoChild&lt;/div&gt;; }); function App() { const [isUpdate, setIsUpdate] = useState(true); const onClick = () =&gt; { setIsUpdate(!isUpdate); console.log('点击了按钮'); }; return ( &lt;div className=&quot;App&quot;&gt; &lt;Child /&gt; &lt;MemoChild /&gt; &lt;button onClick={onClick}&gt;刷新 App &lt;/button&gt; &lt;/div&gt; ); } export default App; 上例中：Child 是一个普通的组件，MemoChild 是一个被 React.memo 包裹的组件。 当我点击 button 按钮时，调用 setIsUpdate 触发 App 组件重新渲染（re-render）。 控制台结果如下： 如上图： 首次渲染时，Child 和 MemoChild 都会被渲染，控制台打印 Child 渲染了 和 memoChild 渲染了。 而当我点击按钮触发重新渲染后，Child 依旧会重新渲染，而 MemoChild 则会进行新旧 props 的判断，由于 memoChild 没有 props，即新旧 props 相等（都为空），则 memoChild 使用之前的渲染结果（缓存），避免了重新渲染。 由此可见，在没有任何优化的情况下，React 中某一组件重新渲染，会导致其全部的子组件重新渲染。即通过 React.memo 的包裹，在其父组件重新渲染时，可以避免这个组件的非必要重新渲染。 需要注意的是：上文中的【渲染】指的是 React 执行函数组件并生成或更新虚拟 DOM 树（Fiber 树）的过程。在渲染真实 DOM （Commit 阶段）前还有 DOM Diff 的过程，会比对虚拟 DOM 之间的差异，再去渲染变化的 DOM 。不然如果每次更改状态都会重新渲染真实 DOM，那么 React 的性能真就爆炸了（笑）。 2 使用 useMemo 避免重复计算 const memolized = useMemo(fn,deps) React 的 useMemo 把【计算函数 fn】和【依赖项数组 deps】作为参数，useMemo 会执行 fn 并返回一个【缓存值 memolized】，它仅会在某个依赖项改变时才重新计算 memolized。这种优化有助于避免在每次渲染时都进行高开销的计算。具体使用场景可以参考下例： import React, { useMemo, useState } from 'react'; function App() { const [list] = useState([1, 2, 3, 4]); const [isUpdate, setIsUpdate] = useState(true); const onClick = () =&gt; { setIsUpdate(!isUpdate); console.log('点击了按钮'); }; // 普通计算 list 的和 console.log('普通计算'); const sum = list.reduce((previous, current) =&gt; previous + current); // 缓存计算 list 的和 const memoSum = useMemo(() =&gt; { console.log('useMemo 计算'); return list.reduce((previous, current) =&gt; previous + current); }, [list]); return ( &lt;div className=&quot;App&quot;&gt; &lt;div&gt; sum:{sum}&lt;/div&gt; &lt;div&gt; memoSum:{memoSum}&lt;/div&gt; &lt;button onClick={onClick}&gt;重新渲染 App&lt;/button&gt; &lt;/div&gt; ); } export default App; 上例中：sum 是一个根据 list 得到的普通计算值，memoSum 是一个通过 useMemo 得到的 momelized 值（缓存值），并且依赖项为 list。 如上图控制台中 log 所示：首次渲染，sum 和 memoSum 都会根据 list 的值进行计算； 当点击 【重新渲染 App】按钮后，虽然 list 没有改变，但是 sum 的值进行了重新计算，而 memoSum 的值则没有重新计算，使用了上一次的计算结果（memolized）。 当点击 【往 List 添加一个数字】按钮后，list 的值发生改变，sum 和 memoSum 的值都进行重新计算。 总结：在函数组件内部，一些基于 State 的衍生值和一些复杂的计算可以通过 useMemo 进行性能优化。 3 使用 useCallback 避免子组件的重复渲染 const memolizedCallback = useCallback(fn, deps); React 的 useCallback 把【回调函数 fn】和【依赖项数组 deps】作为参数，并返回一个【缓存的回调函数 memolizedCallback】（本质上是一个引用），它仅会在某个依赖项改变时才重新生成 memolizedCallback。当你把 memolizedCallback 作为参数传递给子组件（被 React.memo 包裹过的）时，它可以避免非必要的子组件重新渲染。 useCallback 与 useMemo 异同 useCallback 与 useMemo 都会缓存对应的值，并且只有在依赖变动的时候才会更新缓存，区别在于： useMemo 会执行传入的回调函数，返回的是函数执行的结果 useCallback 不会执行传入的回调函数，返回的是函数的引用 useCallback 使用误区 有很多初学者（包括以前的我）会有这样一个误区：在函数组件内部声明的函数全部都用 useCallback 包裹一层，以为这样可以通过避免函数的重复生成优化性能，实则不然： 首先，在 JS 内部函数创建是非常快的，这点性能问题不是个问题（参考：React 官方文档：Hook 会因为在渲染时创建函数而变慢吗？） 其次，使用 useCallback 会造成额外的性能损耗，因为增加了额外的 deps 变化判断。 每个函数用 useCallback 包一层，不仅显得臃肿，而且还需要手写 deps 数组，额外增加心智负担。 useCallback 正确的使用场景 函数组件内部定义的函数需要作为其他 Hooks 的依赖。 函数组件内部定义的函数需要传递给其子组件，并且子组件由 React.memo 包裹。 场景 1：useCallback 主要是为了避免当组件重新渲染时，函数引用变动所导致其它 Hooks 的重新执行，更为甚者可能造成组件的无限渲染： import React, { useEffect, useState } from 'react'; function App() { const [count, setCount] = useState(1); const add = () =&gt; { setCount((count) =&gt; count + 1); }; useEffect(() =&gt; { add(); }, [add]); return &lt;div className=&quot;App&quot;&gt;count: {count}&lt;/div&gt;; } export default App; 上例中，useEffect 会执行 add 函数从而触发组件的重新渲染，函数的重新渲染会重新生成 add 的引用，从而触发 useEffect 的重新执行，然后再执行 add 函数触发组件的重新渲染... ，从而导致无限循环： useEffect 执行 -&gt; add 执行 -&gt; setCount 执行 -&gt; App 重新渲染 -&gt; add 重新生成 -&gt; useEffect 执行 -&gt; add 执行 -&gt; ... 为了避免上述的情况，我们给 add 函数套一层 useCallback 避免函数引用的变动，就可以解决无限循环的问题： import React, { useCallback, useEffect, useState } from 'react'; function App() { const [count, setCount] = useState(1); // 用 useCallback 包裹 add ，只会在组件第一次渲染生成函数引用，之后组件重新渲染时，add 会复用第一次生成的引用。 const add = useCallback(() =&gt; { setCount((count) =&gt; count + 1); }, []); useEffect(() =&gt; { add(); }, [add]); return &lt;div className=&quot;App&quot;&gt;count: {count}&lt;/div&gt;; } export default App; 场景 2：useCallback 是为了避免由于回调函数引用变动，所导致的子组件非必要重新渲染。（这个子组件有两个前提：首先是接收回调函数作为 props，其次是被 React.memo 所包裹。） const Child = React.memo(({ onClick }) =&gt; { console.log(`Button render`); return ( &lt;div&gt; &lt;button onClick={onClick}&gt;child button&lt;/button&gt; &lt;/div&gt; ); }); function App() { const [countA, setCountA] = useState(0); const [countB, setCountB] = useState(0); // 情况1：未包裹 useCallback const onClick = () =&gt; { setCountA(countA + 1); }; // 情况2：包裹 useCallback const onClick = useCallback(() =&gt; { setCountA(countA + 1); }, []); return ( &lt;div&gt; &lt;div&gt;countA:{countA}&lt;/div&gt; &lt;div&gt;countB:{countB}&lt;/div&gt; &lt;Child onClick={onClick1} /&gt; &lt;button onClick={() =&gt; setCountB(countB + 1)}&gt;App button&lt;/button&gt; &lt;/div&gt; ); } 上例中，Child 子组件由 React.memo 包裹，接收 onClick 函数作为 props 参数。 情况 1：onClick 未包裹 useCallback ，当点击 app button 时，触发重新渲染，onClick 重新生成函数引用，导致 Child 子组件重新渲染。 情况 2：onClick 包裹 useCallback ，当点击 app button 时，触发重新渲染，onClick 不会生成新的引用，避免了 Child 子组件重新渲染。 4 总结 上文叙述中，我们通过 React.memo、useMemo、useCallback 这些 API 避免了在使用函数组件的过程中可能触发的性能问题，总结为一下三点： 通过 React.memo 包裹组件，可以避免组件的非必要重新渲染。 通过 useMemo，可以避免组件更新时所引发的重复计算。 通过 useCallback，可以避免由于函数引用变动所导致的组件重复渲染。 参考文章 React 官方文档 Segmentfault 一直以来useCallback的使用姿势都不对 ","link":"https://wuwenbang.github.io/post/react-hooks-xing-neng-you-hua/"},{"title":"Webpack Plugin 浅析","content":"Plugin 是什么 Plugin 是 Webpack 中的扩展器，在 Webpack 运行的生命周期中会广播出许多钩子事件，Plugin 可以监听这些事件，并挂载自己的任务，也就是注册事件。当 Webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行了。 Plugin 与 Loader 的区别 Plugin 与 Loader 功能不同 Loader 是一个转换器：能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中。 Plugin 是一个扩展器：赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事。 Plugin 与 Loader 运行时机不同 可以看到，两者在运行时机上的区别： Loader 运行在打包文件之前 Plugin 在整个编译周期都起作用 Plugin 的使用 Plugin 配置方式 在 webpack.config.js 文件中，通过 Webpack 配置对象的 plugins 属性进行配置，plugins 为一个数组，其元素要求为插件对象 Plugin 的实例，配置参数可以通过 Plugin 在实例化时的构造参数进行传递，例如配置 html-webpack-plugin 如下： const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = = { entry: './index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), }, plugins: [ new HtmlWebpackPlugin({template: './src/index.html'}), ], }; 常见的 Plugin 1 html-webpack-plugin（HTML 文件生成插件） 背景：多入口时，当你的 index.html 引入多个 js 文件，如果这些生成的 js 名称构成有 [hash] ，那么每次打包后的文件名都是变化的。 作用：可以用于自动重新生成一个 index.html ，并帮你把所有生产的 js 文件引入到 html 中，最终生成到 output 目录。 安装： yarn add --dev html-webpack-plugin 配置： //引入 const HtmlWebpackPlugin = require('html-webpack-plugin'); //配置 module.exports = = { // ... plugins: [ new HtmlWebpackPlugin(), ], }; 2 mini-css-extract-plugin（css 提取插件） 背景：在进行打包时，CSS 代码会打包到 JS 中，不利于文件缓存。 作用：依据每个 entry 生成单个 CSS 文件（将 CSS 从 JS 中提取出来）。 安装： yarn add --dev mini-css-extract-plugin 配置： const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = = { // ... plugins: [ new MiniCssExtractPlugin(), ], }; 3 imagemin-webpack-plugin（图片压缩插件） 背景：图片过大，加载速度慢，浪费存储空间。 作用：批量压缩图片。 安装： yarn add --dev imagemin-webpack-plugin 配置： const ImageminPlugin = require('imagemin-webpack-plugin').default; module.exports = { // ... plugins: [ new ImageminPlugin({ disable: process.env.NODE_ENV !== 'production', // 开发时不启用 pngquant: { //图片质量 quality: '95-100', }, }), ], }; 4 clean-webpack-plugin（清空文件夹插件） 背景：每次进行打包需要手动清空目标文件夹。 作用：每次打包时先清空 output 文件夹。 安装： yarn add --dev clean-webpack-plugin 配置： const CleanWebpackPlugin = require('clean-webpack-plugin'); module.exports = { // ... output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), }, // 自动清空 dist 文件夹 plugins: [new CleanWebpackPlugin(['dist'])], }; 5 copy-webpack-plugin（文件复制插件） 背景：一些静态资源（图片、字体等），在编译时，需要拷贝到输出文件夹。 作用：用来复制文件或文件夹。 安装： yarn add --dev copy-webpack-plugin 配置： // 引入 const CopyPlugin = require('copy-webpack-plugin'); module.exports = { // ... plugins: [ new CopyPlugin([ { from: 'assets', to: 'dist' }, { from: 'images/xxx.png', to: 'dist' }, ]), ], }; 6 compression-webpack-plugin（gzip 压缩插件） 背景：所有现代浏览器都支持 gzip 压缩，启用 gzip 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。 作用：用来对一些文本文件（JS CSS HTML）文件进行 gzip 压缩。 安装： yarn add --dev compression-webpack-plugin 配置： // 引入 const CompressionPlugin = require('compression-webpack-plugin'); module.exports = { // ... plugins: [ new CompressionPlugin({ // gzip压缩配置 test: /\\.js$|\\.html$|\\.css/, // 匹配文件名 threshold: 10240, // 对超过10kb的数据进行压缩 deleteOriginalAssets: false, // 是否删除原文件 }), ], }; 参考文档 Webpack 官方文档 Plugin webpack 常用插件 ","link":"https://wuwenbang.github.io/post/webpack-plugin-qian-xi/"},{"title":"Webpack Loader 浅析","content":"1 Loader 是什么 Loader 是 Webpack 中的文件加载器。 Loader 的作用 Webpack 是一个模块化打包工具，但是其只能直接处理 JavaScript 格式的代码。任何非 JavaScript 文件（例如 TypeScript CSS SASS JSX）都必须被预先处理转换为 JavaScript 代码，才可以参与打包。而 Loader 文件加载器，能够加载资源文件，并对这些文件进行特定的处理，然后打包的指定文件中。 例如 ts-loader 可以将 TypeScript 转换为 JavaScript 代码： TypeScript -&gt; (ts-loader) -&gt; JavaScript Loader 的本质 Loader 本质上是导出函数的 JavaScript 模块： /** * @param {string|Buffer} content 源文件的内容 * @param {object} [map] SourceMap 数据，用于定位源码 * @param {any} [meta] meta 数据，可以是任何内容 */ function webpackLoader(content, map, meta) { // 你的webpack loader代码 } module.exports = webpackLoader; 基于所导出的函数，我们可以实现对源文件内容 content 的转换：函数 return 的就是转换的结果。 2 Loader 使用方式 Loader 三种使用方式 配置（推荐）：在 webpack.config.js 文件中指定 loader。 module.exports = { module: { rules: [ { test: /\\.css$/, use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { modules: true, }, }, ], }, ], }, }; 内联：在每个 import 语句中显式指定 loader。 可以在 import 语句或任何等效于 &quot;import&quot; 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。 import Styles from 'style-loader!css-loader?modules!./styles.css'; 命令行：在 shell 命令中指定它们。 webpack --module-bind 'css=style-loader!css-loader' 这样会对 .css 文件使用 style-loader 和 css-loader。 Loader 执行顺序 Loader 遵循如下规则执行：从右到左，从下到上。 例如上述 Loader 的执行顺序就是： css-loader -&gt; style-loader。 3 Webpack 常用 Loader 样式：style-loader、css-loader、sass-loader 等 文件：raw-loader、file-loader、url-loader 等 编译：babel-loader、vue-loader、ts-loader 等 校验测试：eslint-loader、mocha-loader 等 样式 Loader 例如我们需要处理 .sass 文件，则需要经历一下三个 Loader ： sass-loader: 将 .sass 文件转换为 .css 文件 css-loader: 将.css 文件内容转换为 JS 的字符串并作为 JS 模块导出 style-loader: 将 css 字符串以 style 标签的方式插入 DOM 树中 实现以上三个 Loader 的配置如下： module.exports = { module: { rules: [ { test: /\\.s[ca]ss$/, use: ['style-loader', 'css-loader', 'sass-loader'], }, ], }, }; 文件 Loader raw-loader：加载文件原始内容（utf-8），返回 JSON.stringify 后的内容。 file-loader：主要作用是将指定文件拷贝到输出文件夹。 url-loader：url-loader 在 file-loader 的基础上加了一个 data URL 的功能。传给 url-loader 一个限制值，如果处理的文件小于这个值，loader 将会把文件转化为 base64 的 data URL 输出。大于限制的文件则交给引入的 file-loader 处理。 编译 Loader babel-loader：默认用来处理 ES6 语法，将其编译为浏览器可以执行的 JS 语法。 vue-loader：用来将 .vue 文件处理为 JS 可以识别的模块。 ts-loader：用来将 .ts 文件处理为 JS 可以识别的语法。 校验测试 Loader eslint-loader：允许 Eslitn 对 JS 文件做语法检查。 mocha-loader：允许通过 Webpack 加载和运行 Mocha Test。 参考文档 Webpack 官方文档 Loaders ","link":"https://wuwenbang.github.io/post/webpack-loader-qian-xi/"},{"title":"Reack Hooks 从函数的角度去理解","content":"1. React 核心公式 当我们在使用 React 函数组件构筑视图的时候，我们到底在干什么呢？ 大部分时间我们其实是在定义函数（函数组件），然后把写好的函数丢进 ReactDOM.render() 里去渲染，就像这样： // 定义函数组件 function App() { return &lt;div&gt;Hello World!&lt;/div&gt;; } // 渲染函数组件 ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 然后 React 帮助我们将函数执行的结果（在函数内部 return 的 HTML 内容）渲染到视图上，所以 React 的核心功能可以用一个简单的公式概括： UI = f() 即视图等于一个函数执行的结果。 再介绍后续 Hooks 相关内容之前，首先介绍两个概念：纯函数和副作用函数。 纯函数（ Pure Function ）：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，这样的函数被称为纯函数。 副作用函数（ Side effect Function ）：如果一个函数在运行的过程中，除了返回函数值，还对主调用函数产生附加的影响（例如访问外部变量，发起 HTTP 请求，操作 DOM 等等），这样的函数被称为副作用函数。 在没有引入 Hooks 之前，函数式组件还是一个纯函数（相同的输入永远获得相同的输出），我们称这样的函数组件为纯函数组件。 2. 状态 useState 现在我们已经可以通过 React 渲染一个页面了，然而他就岁月尽好的躺在那，但是如果我想来点动静：比如添加一个计数器——一个数字和一个按钮，每次点击就 +1 ，这个时候我们就需要组件自己的状态了：用 useState 创建状态。先看一个例子： function App() { const [count, setCount] = useState(0); const add = () =&gt; { setCount(count + 1); }; return ( &lt;div&gt; &lt;div&gt;count:{count}&lt;/div&gt; &lt;button onClick={add}&gt;+1&lt;/button&gt; &lt;/div&gt; ); } ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 我们来具体聊一下上述代码中我们到底做了哪些事情： 首先，我们调用 useState 函数并传入初始值 0，useState 函数返回一个包含 状态（state） 和 改变状态的方法（setState） 的元组，最后我们对元组用解构赋值：将状态赋值给 count 常量，改变状态的方法赋值给 setCount 常量。 然后我们定义 add 函数：调用 setCount 方法并传入 count + 1 的值。 接着我们在 return 的 div 元素内渲染 count，同时将函数 add 绑定在 button 元素的 onClick 事件上。 运行这段代码：初次渲染 count 的值为 0，每次点击 +1 按钮后，页面中 count 的值 +1。 那么问题来了，页面中渲染的 count 是怎么改变的呢？我们来详细解析一下： 第一次渲染： 初始化 useState 中的 state 为初始值 0，然后将其解构赋值给 count。 渲染 count 的值 0 到页面中。 点击 +1 按钮： 调用 add 方法，从而调用 setCount 方法并传入新的状态 count + 1 即 1。 将新的状态 1 更新给 useState 中的 state，随后触发重新渲染。 第二次渲染： 从 useState 获取中的 state（此时 state 已更新为 1），将其解构赋值给 count。 渲染 count 的值 1 到页面中。 根据上述分析我们可以得出 useState 中的 setState 有两个作用： 更新内部 state； 触发重新渲染。 可以看到，我们渲染的 UI 随着 state 的变化而变化，所以我们需要更新一下我们的核心公式为 UI = f(state)。 同时我们可以看到，在每次点击 +1 按钮后，执行相同的 App 函数会得到不同的结果（count 渲染的值每次都变动了），这是因为通过 useState 访问的 state 其实存储在函数组件外部的 React Fiber 对象上的，此时组件已经不是纯函数组件了，而是带有副作用的函数组件。 3. 参数 Props 既然函数式组件本质为函数，那么我们理应可以给它传入参数，一般将其称为 props 即外部参数。props 常常用于父子组件之间状态的传递，先看一个例子： function Child(props) { return &lt;div&gt;child:{props.value}&lt;/div&gt;; } function App() { const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;Child value={count} /&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt; &lt;/div&gt; ); } ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 上述代码中：我们先是定义一个函数子组件 Child，声明参数 props，然后在返回的 HTML 中渲染 props.value。在父函数组件 App 中，我们调用 Child 组件，并将 count 的值传给 value，写法为：&lt;Child value={count} /&gt;。 可以看到：在父函数传入的 value 属性，它会挂载在一个对象上（props），在子函数中我们通过 props.value 拿到。 当我们点击 +1 按钮时，count 的值发生改变并触发重新渲染，&lt;Child value={count} /&gt;也随之重新渲染， props.value 也随 count 的改变而改变。 至此我可以得知：props 的改变也会间接导致函数组件重新渲染，核心公式更改为： UI = f(state,props)。 4. 上下文 useContext 通过 useState 我们可以使函数式组件拥有自己的内部状态，通过 props 我们可以使得状态在父子组件之间传递。对于组件树中相对位置较远的组件亦或兄弟组件之间，我们可以使用 context 去共享状态，先看一个例子： // 创建 Context const countContext = createContext(0); // 子组件 A function ChildA() { const count = useContext(countContext); return &lt;div&gt;child A:{count}&lt;/div&gt;; } // 子组件 B function ChildB() { const count = useContext(countContext); return &lt;div&gt;child B:{count}&lt;/div&gt;; } // 父组件 function App() { const [count, setCount] = useState(0); const add = () =&gt; { setCount(count + 1); }; return ( &lt;countContext.Provider value={count}&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;button onClick={add}&gt;+1&lt;/button&gt; &lt;/countContext.Provider&gt; ); } ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 首先，调用 createContext 创建一个 countContext 上下文。 在父组件 App 中，我们使用 &lt;countContext.Provider value={count}&gt; ，将 count 作为 context 的内容，然后通过 Provider 对包裹在其内部的组件提供 context。 在子组件 ChildA、ChildB 中我们使用 useContext(countContext) 去消费 context，此时子组件 count 就是通过 context 共享的父组件的 count。 当我们点击 +1 按钮时，App 中 count 的值发生改变，countContext 值随之改变，并触发重新渲染，ChildA、ChildB 中 count 的值随着 countContext 改变而改变。 至此我可以得知：context 的改变也会间接导致函数组件重新渲染，核心公式更改为： UI = f(state,props,context)。 核心公式中 state、props、context 的变动都会更新视图 UI，但其实仔细思考一下就能发现：props 和 context 只不过是充当了 state 的媒介（帮助 state 在组件之间传递和共享），真正意义上 UI 更新还是由 state 的变动引起的。更为切确的说是： setState 在变更 state 的同时触发了重新渲染 re-render（重新执行函数组件）进而导致 UI 视图的变更。这一点对于理解 Hooks 的作用机制来说非常重要。 5. 引用 useRef useRef(initialValue) useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 useRef 和 useState 都可以在函数组件内部存储值（状态），相较于 useState , useRef 可以在函数组件内部更新值而不触发重新渲染。或者你可以简单的将 useRef 理解为变更不触发重新渲染的 useState。我们来看一个例子： function App() { const [count, setCount] = useState(0); const countRef = useRef(0); return ( &lt;div&gt; &lt;div&gt;countRef:{countRef.current}&lt;/div&gt; &lt;div&gt;countState:{count}&lt;/div&gt; &lt;button onClick={() =&gt; countRef.current++}&gt;change count ref&lt;/button&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;change count state&lt;/button&gt; &lt;/div&gt; ); } ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 上述例子中： 当点击 change count ref 按钮时，页面上没有任何变化； 当点击 change count state 按钮时，页面上 countState 的值 +1 ，并且 countRef 的值也发生了变动。 值得注意的是：在 countState 变动并且重新渲染的同时，也会把 countRef 当前的值渲染出来。（这里再次解释一下：所谓重新渲染就是再次执行一遍函数（例子中App），在本例中会重新读取 countRef.current 的值然后渲染再页面中。） 6. 副作用 useEffect useEffect 可以让你在函数组件中执行副作用操作。 useEffect 执行顺序 useEffect(effect, deps) useEffect 的第一个参数为一个函数（我们暂时称其为 effect 函数），effect 函数会在函数组件 App 每次渲染后异步执行，同时 effect 函数可以再返回一个函数（我们一般叫它 cleanup 函数），其将在下一次 effect 函数执行前执行。cleanup 函数一般用于清除 effect 残留的副作用，。 useEffect 的执行顺序可以参考下面这个例子： function App() { const [count, setCount] = useState(0); useEffect(() =&gt; { console.log('effect 执行了'); return () =&gt; { console.log('cleanup 执行了'); }; }); const add = () =&gt; { console.log('点击按钮'); setCount(count + 1); }; console.log(`App函数组件 执行了`); return ( &lt;div&gt; &lt;div&gt;count:{count}&lt;/div&gt; &lt;button onClick={add}&gt;+1&lt;/button&gt; &lt;/div&gt; ); } ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 控制台打印如下： 根据打印信息可以得到： 第一次渲染时，执行了 effect 函数； 当点击按钮后，触发第二次渲染，先执行 cleanup 函数（第一次渲染 effect 函数返回的函数），再执行 effect 函数。 useEffect 依赖数组 useEffect 的第二个参数是个依赖数组（deps），在每次渲染后 React 会根据依赖数组来判断是否应该执行 effect 函数。依赖数组 deps 分为一下三种情况讨论： deps 为空（不填），每次函数组件渲染都会执行 effect 函数； deps 为 []，只有在首次函数组件渲染才会执行 effect 函数； deps 为 [dep1,dep2,...]，在首次函数组件渲染，或者任意依赖项（dep1,dep2,...）变动的情况下会执行 effect 函数。 7. 缓存 useMemo useCallback useMemo 和 useCallback 用于 React 的性能优化，通过合理的使用可以避免多余的计算和渲染。 useMemo useMemo(fn, deps) useMemo 的参数分别是一个创建函数 fn 和一个依赖数组 deps，创建函数需要一个返回值，只有在依赖项发生改变的时候，才会重新调用此函数返回一个新的值。 如果使用过 Vue 的小伙伴肯定知道计算属性 computed，useMemo 的作用与其类似，主要用于缓存需要计算的值（state 的衍生值）。举一个例子： function App() { const [list, setList] = useState([1, 1, 1]); const listLength = useMemo(() =&gt; { return list.length; }, [list]); return ( &lt;div&gt; &lt;div&gt;{list.map((item) =&gt; item)}&lt;/div&gt; &lt;div&gt;listLength:{listLength}&lt;/div&gt; &lt;button onClick={() =&gt; setList([...list, 1])}&gt;push&lt;/button&gt; &lt;/div&gt; ); } ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); listLength 依赖于 list 计算 list 的长度（是状态 list 的衍生值），每次当且仅当 list 变动时，会重新调用 useMemo 的创建函数，返回一个新的 length。 当每次点击 push 时，会调用 setList 导致 list 发生变化，list 的变化导致 listLength 重新计算，所以可以看到 listLength 的值随着 list 同步变化。 useCallback useCallback(fn, deps) useCallback 的参数分别是一个创建函数 fn 和一个依赖数组 deps，返回值是创建函数的引用，只有当依赖项变化发生改变的时候，useCallback 才会重新创建函数并返回一个新的引用。 useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps) useCallback 最主要的作用就是用于缓存函数的引用，从而避免函数创建时，引用变化所带来的非必要渲染。 千万不要滥用 useCallback，一般来说 useCallback 的应用场景主要有二： 函数组件内部定义的函数需要作为其他 Hooks 的依赖。 父组件内部定义的函数需要传递给子组件，并且子组件由React.memo包裹。 React.memo 会检查 props 变更，如果 props 未变动，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。 场景 1 应该很容易理解，我们主要解释一下场景 2，例子如下： const Child = React.memo(({ onClick }) =&gt; { console.log(`Button render`); return ( &lt;div&gt; &lt;button onClick={onClick}&gt;child button&lt;/button&gt; &lt;/div&gt; ); }); function App() { const [countA, setCountA] = useState(0); const [countB, setCountB] = useState(0); // 情况1：未包裹 useCallback const onClick = () =&gt; { setCountA(countA + 1); }; // 情况2：包裹 useCallback const onClick = useCallback(() =&gt; { setCountA(countA + 1); }, []); return ( &lt;div&gt; &lt;div&gt;countA:{countA}&lt;/div&gt; &lt;div&gt;countB:{countB}&lt;/div&gt; &lt;Child onClick={onClick1} /&gt; &lt;button onClick={() =&gt; setCountB(countB + 1)}&gt;App button&lt;/button&gt; &lt;/div&gt; ); } 上例中，Child 子组件由 React.memo 包裹，接收 onClick 函数作为参数。 情况 1：onClick 未包裹 useCallback ，当点击 app button 时，触发重新渲染，onClick 重新生成函数引用，导致 Child 子组件重新渲染。 情况 2：onClick 包裹 useCallback ，当点击 app button 时，触发重新渲染，onClick 不会生成新的引用，避免了 Child 子组件重新渲染。 参考文档 React 官方文档 ","link":"https://wuwenbang.github.io/post/reack-hooks-cong-han-shu-de-jiao-du-qu-li-jie/"},{"title":"Docker 学习笔记","content":"1 Docker 初见 1.1 Docker 是什么 Docker 可以理解成一个超轻量级的虚拟机，专业的说法叫应用容器，它是在 LCX（linux 容器）基础上进行的封装。 Docker 和传统虚拟化方式的不同之处在于容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 相较于传统的 VM 虚拟化方法，Docker 的好处是启动速度快，资源利用率高，性能开销小。 1.2.Docker 的三个概念 镜像（Image）：Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。 容器（Container）：Docker 镜像 和 容器 的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。 仓库（Repository）：类似于代码仓库，这里是镜像仓库，是 Docker 用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用 tag 进行区分，比如 Ubuntu 仓库存放有多个版本（12.04、14.04 等）的 Ubuntu 镜像。 1.3 Docker 安装 不同系统的 Docker 安装方法可以直接参考 Docker 官方安装教程：https://docs.docker.com/get-docker/ 2 Docker 容器 2.1 容器 操作命令 创建容器 首先让我们来创建一个新容器，创建容器的命令是： docker run &lt; image_name &gt; image_name 代表一个镜像名称，例如你可以创建一个 nginx 容器，就像这样： docker run nginx 输入完成后，直接回车。如果系统中没有这个镜像，Docker 会自动去 Docker Hub 上拉取对应的镜像（最新版本）到本地，然后执行对应的 Shell 脚本，脚本会把镜像自动安装到 Docker 容器里，并最终启动对于的镜像服务（注意，这时候容器是在前台运行的）。 Docker Hub 是 Docker 官方的镜像和社区，里边有很多开发者制作好的镜像，我们可以直接使用这些镜像。如果你有能力，也可以制作镜像，并上传到 Docker Hub。 查看容器 创建完容器后，如果想查看这个容器的信息和状态，你可以再打开一个新的终端，然后可以使用下面的命令： docker ps 然后你就可以看到如下信息： CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4b2410514c51 nginx &quot;/docker-entrypoint.…&quot; 8 seconds ago Up 7 seconds 80/tcp nice_ritchie 这些信息对应的含义如下表： 信息 含义 CONTAINER ID 容器对应的唯一 ID IMAGE 镜像名称 COMMAND 执行的相关命令 CREATED 创建的时间 STATUS 当前镜像的状态（Up 为运行中，Exited 为退出） PORTS 协议和端口 NAMES 容器的名称（不指定的话 Docker 会随机生成） 停止容器 如果你想停止掉一个正在运行的容器，可以使用下面的命令： docker stop &lt;container_id&gt; 当容器停止后，再使用查看命令进行查看，你会发现没有任何容器。 docker ps 这是因为普通的 ps 指令只会查看正在运行的容器，这时候你要查看你所有容器，包含已经停止的容器，可以加一个 -a 参数。 docker ps -a 删除容器 当我们停止容器之后，容器并没有删除，而只是停止掉了。这时候你可以使用下面的命令删除容器。 docker rm &lt;container_id&gt; 正在运行的容器是无法直接删除的，你可以是强制删除指令进行删除： docker rm -f &lt;container_id&gt; 2.2 容器 attached 和 detached 模式 两种模式最简单的对比理解就是：attached 模式在前台运行，detached 模式在后台运行。 attached 模式 我们现在先用 Docker 创建一个 Nginx 容器，并把它映射在服务器的 80 端口，运行如下命令： docker run nginx 这个时候你会发现你的命令行（Terminal）上打印出了相关的日志（log）。也就是说 Docker 容器的日志会实时的展现到窗口并且占用此端口。这种模式叫做 attached 模式。 如果这时候你按 Ctrl+C ，就会停止掉 Docker 服务。也就是在 Linux 上你的操作命令，会直接传递给 Docker 容器。这个缺点就是很容易误操作，你随便 Ctrl+C 一下整个服务就崩掉了。 所以我们需要一个更好的，更稳定的模式。也就是 detached 模式。attached 模式更适用于容器和程序的调试阶段。 detached 模式 detached 模式的开启方法，就是加一个参数 -d 或者 --detach。 docker run -d nginx 这次你会看到，和 attached 模式不同的是，这次输入完命令后，只显示出了容器的编号，并且可以再输入任何命令。就算我们关掉窗口，容器依然运行，也就是他是在系统后台进行运行的。我们可以通过输入命令 docker ps 查看，发现刚刚启动的 Nginx 服务正在后台运行中。 这种就比较适合在生产环境中运行，停掉和删除容器都需要使用 Shell 脚本的形式。减少了很多误操作。 如果你想在 detached 模式下查看日志，你可以使用以下命令： docker container logs &lt;container_id&gt; detached 模式转换 attached 模式 在运行之后，也有需要调试的时候，Docker 提供了两个模式间的转换。比如现在要把 detached 模式的容器，改为 attached 模式。我们可以输入一下命令： docker logs &lt;container_id&gt; 虽然日志在窗口中出现了，但只打印一次 logs，如果想动态一直跟踪日志，可以在命令上加入一个 -f。 docker logs -f &lt;container_id&gt; Docker 端口映射 如果想在浏览器上访问刚刚启动的 Nginx 服务，我们就需要做端口映射，在开启端口映射之前，你首先要之道 Docker 对应的容器端口是多少。比如 Nginx 镜像的端口是 80。知道这个端口后，就可以在启动容器的时候，用-p &lt;port:port&gt; 的形式，启用映射了。 docker run -p 80:80 nginx 等待项目启动后，打开浏览器窗口，在地址栏输入 127.0.0.1 或 localhost（默认指向 80 端口），就可以打开 Nginx 的默认网址。 第一个端口是映射到服务器本机的端口; 第二个端口是 Docker 容器使用的端口。 比如你想把 Docker 的 80 端口，映射到服务器的 90 端口。 docker container run -p 90:80 nginx 2.3 容器 交互模式 有时候容器的镜像不是简单的一个服务，而是需要交互的操作系统。例如创建一个 Ubuntu 系统，然后需要到系统里输入各种 Shell 命令和系统进行交互。这时候 attached 模式和 detached 模式就不能满足要求了。需要使用交互模式。 使用 Ubuntu 镜像并开启交互模式 docker run -it ubuntu sh -it 代表启用交互模式，sh 代表可以使用 Shell 脚本。当你输入玩这个脚本后，Docker 就会进入到交互模式。可以使用 ls 来得到目录下的文件。 这时候你想退出容器和交互模式可以输入 exit 命令。需要重点说明的是，随着命令退出后，容器也会跟着退出，变成 Exited 模式。 detached 模式下的交互 如果我们想退出交互，但是并不想停止容器。可以先开启 detached 模式，然后通过命令进入交互模式。 先用 detached 模式创建一个 nginx 镜像的容器。 docker run -d -p 80:80 nginx 然后直接通过下面的命令就可以进入到交互模式下了（这是我们以后要经常使用的一个命令）。 docker exec -it &lt;container_id&gt; sh exec 是执行的意思，-it交互模式， sh 交互的方式，用 shell 脚本进行交互。 整个命令的意思是：用 shell 脚本的方式执行交互模式。 进入后可以使用 ls 来查看容器的文件系统。 这种模式的优点是，再使用 exit（或者 Ctrl+D）退出后，服务并不会停止，而只是退出了交互模式。可以自己尝试一下退出，然后使用 docker container ls -a 来查看一下容器的状态，你会发现依然是 up 状态。 3 Docker 镜像 镜像是 Docker 里最重要的一个知识点，如果你只会创建容器和使用官方的镜像，并不能算是 Docker 的高手或者是专业选手，只能说会使用 Docker。而制作镜像文件，并让广大网友使用，才是每个 Docker 人的追求。 3.1 镜像 基本操作 获取镜像的三种方式 从网络社区直接拉取，在 Docker 里这种社区叫做 Registry（登记处）。 从 Dockerfile 构建一个镜像，这种像是 DIY 一个镜像，但是整个构建过程是需要联网，因为需要西在基础镜像，然后根据基础镜像进行构建（build from Dockerfile）。 自有文件的导入，可以从本地导入已经构建好的镜像文件，在没有网络的时候可以用。这个文件是通过 已有的镜像导出来的压缩包，然后就可以进行使用了。 镜像社区（Image registry） 镜像社区也叫做 Image registry（镜像登记处），是拉取和下载镜像的网站，你也可以通过 Dockerfile 制作镜像，让所有人使用，类似 Docker Image 专属的简单版 GitHub。 dockerhub：网址- https://hub.docker.com/ ,Docker 官方社区，在使用 Docker 时默认的拉取网站。 拉取镜像 我们先尝试从 Dockerhub 上拉取 nginx 镜像： docker image pull nginx # 可以简写为： docker pull nginx 如果是第一次拉取镜像，则需要下载很多依赖的基础镜像。具体快慢会和网速有关。这里给出第一次拉取 nginx 的日志信息。 % docker pull nginx Using default tag: latest latest: Pulling from library/nginx 5eb5b503b376: Pull complete 1ae07ab881bd: Pull complete 78091884b7be: Pull complete 091c283c6a66: Pull complete 55de5851019b: Pull complete b559bad762be: Pull complete Digest: sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767 Status: Downloaded newer image for nginx:latest docker.io/library/nginx:latest 上面命令的第二行 tag 的意思就是版本,latest 代表的是最新版。因为这里并没有给版本号，你可以加入版本号进行下载的。到 dockerhub 上可以找到对应的版本号。比如我们要下载 wordpress 1.20 版本，就可以输入下面的命令。 docker pull nginx:1.20 查看镜像 查看镜像列表 docker image ls 通过这条命令就可以查看 Docker 中有的镜像和相关信息。 查看具体镜像信息 docker image inspech &lt;image_id&gt; 通过这条命令就可以查看具体某个镜像的详细信息。 删除镜像 删除单个镜像 docker image rm &lt;image_id&gt; 需要注意的是，当有容器在使用镜像时，是没有办法被删除的。即使容器是停止掉的，依然是没办法删除的。 删除所有未被容器使用的镜像 docker image prune -a prune（修剪） 命令用来删除不再使用的 docker 对象。 导出镜像 docker image save 在导出之前，你最好到一个好找的路径下面（比如 Desktop 目录），使用 mkdir 命令创建一个文件夹，进入文件后输入下面的命令。比如现在要导出镜像中的 nginx 镜像，可以这样写命令。 docker image save nginx:latest -o my_nginx.image 解读上面的命令：save 是导出/保存的意思，nginx:latest 是镜像名称+版本号， -o 代表输出，my_nginx.image 是导出后镜像的名字。 命令执行完成后，可以看到在执行命令所在的目录下就会多出一个 my_nginx.image 的文件，这就是刚才导出的镜像了。 导入镜像 先删除掉本机已有的 nginx 镜像。 docker image rm nginx 删除后直接导入镜像。 docker image load -i .\\my_nginx.image 执行完命令之后，再使用 docker image ls 命令查看，nginx 镜像已经回来了。 3.2 镜像 Dockerfile 构筑镜像 初识 Dockerfile 已经讲了两种获取 Docker 镜像的方式，第一种是直接从 Registry 中拉去，第二种是自己导入导出镜像。接下来是第三种获得镜像的方法：通过 Dockerfile 来 DIY 制作镜像。 通过 Dockerfile 构建镜像虽然比较麻烦，这是最常使用的一种方式，必须掌握。它的知识点非常多，后期准备专门出一篇文章来讲解这个 Dockerfile 的使用、语法和注意问题。 什么是 Dockerfile ？ Dockerfile 是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker 通过读取 Dockerfile 中的指令自动生成映像。 可以简单总结为下面三点： Dockerfile 是用于构建 docker镜像 的文件。 Dockerfile 里包含了构建镜像所需的指令。 Dockerfile 有其特定的语法规则（重要学习）。 第一个 Dockerfile Demo 有这样一个需求：制作一个镜像。镜像拥有一个 nodejs 环境，然后在系统上运行 hello.js 程序。JS 程序的内容非常简单，只要打印出 Hello Docker!，就可以了。这个需求可以分为一下几个步骤去实现： 第一步，下载一个 Node 环境。 第二步，准备 hello.js 文件。我们可以在 Desktop 目录下新建一个 DockerTest 文件夹，然后在文件夹中新建一个 hello.js 文件，然后编写下面的文件。 console.log('Hello Docker!'); 第三步，运行 hello.js。 node hello.js Hello Docker! 有了以上的步骤，我们就可以开始编写 Dockerfile 文件了： FROM node ADD hello.js / CMD [&quot;node&quot;,&quot;hello.js&quot;] 这算是最简单的一个 Dockerfile 文件的编写，有了这个文件之后，就可以通过 Dockerfile 来构建一个镜像了。 当有了 Dockerfile 和 hello.js 文件以后，通过命令行进入 DockerTest 文件夹。通过 Docker 命令就可以完成镜像的构建： docker image build -t &lt;name:tag&gt; &lt;file_path&gt; 例如现在要通过已经写好的 Dockerfile，构建一个 hello 的镜像，就可以使用下面的命令构建。 docker image build -t hello . （注意命令最后是有一个.的），如果你是第一次执行打包，这个过程还是需要 2-3 分钟的，当出现 FINISHED 后，说明打包完成了。 打包完成后，可以通过 docker image ls 命令来查看现在拥有的镜像列表。如果一切正常，你应该可以看到名字为 hello 的镜像已经存在了。 可以执行容器，验证一下自己 DIY 的镜像是否可用。 docker run node 镜像如果正常，应该正确现实出 Hello Docker 字样，然后就直接退出容器了。这是跟我们写的 Dockerfile 有关的。 3.3 镜像 Dockerhub 分享镜像 这一章节我们要把镜像 push 到 dockerhub 上去，这样就可以让所有人进行使用了。想要分享镜像，需要做到一下几步： 第一步，申请了一个账号，例如账号名为 prayx ，所以在点开 Profile 时是没有任何镜像的。 第二步，如果你想上传属于自己的镜像，需要遵守社区规则，就是 用户ID/镜像名称。可以最简单的方法，就是重新 build 一个镜像，镜像名称符合社区规则就可以了。 docker image build -t prayx/hello . 这时候就会生成一下新的镜像，但是 Image ID 是一摸一样的。 也可以通过 docker image tag 命令，具体语法如下： docker image tag &lt;old_image_name&gt; &lt;new_iamge_name&gt; 例如把 hello 这个镜像，改为 prayx/hello 镜像,命令可以如下： docker image tag hello prayx/hello 在推送前，需要先登录 Dockerhub 账号,登录命令如下： docker login 执行命令好，会要求输入 Username，也就你 Dockerhub ID，还需要输入密码。如果输入正确，并出现 Login Succeeded 就证明登录成功了。 docker image push Name[:TAG] 比如就是把刚才的 prayx/hello 镜像 push 到社区，就可以使用下面的命令。 docker image push prayx/hello 输入完命令，就会给我们进行 push 到 Dockerhub 上了。这时候你可以到 Dockerhub 的 profile 页面，刷新一下，就可以看到刚刚 push 上去的镜像。 4 Dockerfile 4.1 Dockerfile FROM 指令 还记得上一章节，我们写的 Dockerfile 文件吗？ FROM node ADD hello.js / CMD [&quot;node&quot;,&quot;hello.js&quot;] 第一句就是 FROM node，它的意思是选择一个基础镜像，我这里选择的是带最新版本 Node 的 Linux 系统。等价于 FROM node:latest。如果想选择固定版本的只需要在:后面加上版本号：FROM node:16。 使用 Dockerfile 定制镜像，就需要是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 node 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 在 Docker Hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。 FROM scratch ... 选择基础镜像的三个原则 官方镜像优于非官方的镜像。 固定版本的 Tag，而不是每次都使用 latest。 功能满足的前提下，选择体积小的镜像。 4.2 Dockerfile RUN 指令 RUN 是 Dockerfile 中一个重要的指令，它可以执行 Shell 指令，包括下载文件、安装软件、配置环境.....都是可以的。 例如我们先选定 Ubuntu 作为我们基础镜像，纯净的 Ubuntu 系统是没有 ipinfo 命令的，在安装完系统后，都会安装 ipinfo 命令。步骤如下： $ apt-get update $ apt-get install wget $ wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz $ tar zxf ipinfo_2.0.1_linux_amd64.tar.gz $ mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo $ rm -rf ipinfo_2.0.1_linux_amd64.tar.gz 上面这段代码需要你会一些 Linux 的基本操作，其实就是安装，解压和删除下载文件的一个过程。 不建议的 Dockerfile 写法 如果用 RUN 命令来编写，直接可以写成下面的样子。 FROM ubuntu:latest RUN apt-get update RUN apt-get install -y wget RUN wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz RUN tar zxf ipinfo_2.0.1_linux_amd64.tar.gz RUN mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo RUN rm -rf ipinfo_2.0.1_linux_amd64.tar.gz Dockerfile 中每一个指令都会建立一层（image layer），RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。 上面的这种写法，创建了 6 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。 建议的 Dockerfile 写法 把所有执行命令放到一个 RUN 里，并用&amp;&amp; \\进行连接。就可以把很多命令写到一个 RUN 里边了。 FROM ubuntu:latest RUN apt-get update &amp;&amp; \\ apt-get install -y wget &amp;&amp; \\ wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \\ tar zxf ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \\ mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo &amp;&amp; \\ rm -rf ipinfo_2.0.1_linux_amd64.tar.gz 这样所有的 RUN 命令只生成一层 image layer。打包出来的镜像也没有那么大了。 4.3 Dockerfile 文件操作 制作镜像的时候，经常需要向镜像里添加文件。在 Dockerfile 中有两个命令可以向镜像中添加文件 COPY 和 ADD。这节我们聊一下这两个命令，并重点了解一下两个命令的不同。 用 COPY 命令构建镜像 现在我们写一个 Dockerfile，里边的内容是用基础 Node 镜像，然后拷贝一个 index.js 文件进去。 Dockerfile.copy 内容如下: FROM node:16 COPY index.js /app/index.js 引用 node 16 版本，然后把 index.js 文件，拷贝到 app 目录下面。 index.js 文件如下。代码是我们在 3000 端口上，开启了一个最简单 web 服务，然后返回了 Hello Nodejs 两个单词。 //1. 导入 http 模块 const http = require('http'); //2. 创建服务器对象 const server = http.createServer(); //3. 开启服务器 server.listen(3000, () =&gt; { console.log('Server is running...'); }); //4. 监听浏览器请求并进行处理 server.on('request', (req, res) =&gt; { // end方法能够将数据返回给浏览器，浏览器会显示该字符串 res.end('Hello Nodejs'); }); 两个文件准备好以后，用 build 命令进行构建。 docker image build -f Dockerfile.copy -t hello-copy . 构建完成后，可以使用 docerk image ls 命令进行查询。生成成功后，可以启用交互模式，再加上映射端口的形式，运行容器。 docker container run -it -p 3000:3000 hello-copy sh 这里映射了 3000 端口，这样我们就可以用 127.0.0.1:3000 进行访问了。 用 ADD 构筑镜像 ADD 构建镜像和 COPY 最直观的一点不同，是 ADD 命令可以直接解压 gzip 压缩文件，这当我们有很多文件要上传操作的时候，就会变的简单很多。 Dockerfile.add 文件内容： FROM node:alpine3.14 ADD index.tar /app/ 用 ADD 命令进行打包镜像 docker image build -f Dockerfile.add -t hello-gzip . 打包好以后使用交互模式，开启容器。 docker container run -it -p 3000:3000 hello-gzip sh 再进入 app 路径下面，可以看到下面自动给我们解压了 index.tar 文件。 WORKDIR 切换工作目录 在写 Dockerfile 文件时，默认的操作目录，是镜像的根目录。但有时候需要拷贝很多内容到镜像里是二级目录，就可以使用 WORKDIR 命令。把工作目录切换到二级，WORKDIR 命令像我们操作 linux 下的 cd 命令。 比如还是刚才的 Dockerfile.add 文件，我们可以使用 WORKDIR 命令，改成下面的形式。 FROM node:alpine3.14 WORKDIR /app ADD index.tar index.js 这时候进入系统后的工作目录，就是在 /app 下面了。 4.4 Dockerfile ARG 与 ENV 指令 ARG 和 ENV 是经常容易被混淆的两个 Dockerfile 语法，它们都可以用来设置一个【变量】。但其实两个语法在细节上有很多不同。 还记得之前我们写过一个默认安装 ipinfo 的 ubuntu 系统吗，其 Dockerfile 文件如下： FROM ubuntu:latest RUN apt-get update &amp;&amp; \\ apt-get install -y wget &amp;&amp; \\ wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \\ tar zxf ipinfo_2.0.1_linux_amd64.tar.gz &amp;&amp; \\ mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo &amp;&amp; \\ rm -rf ipinfo_2.0.1_linux_amd64.tar.gz 这段文件里有 ipinfo 的版本是 ipinfo-2.0.1,这个版本是有可能改变的。文件里一共出现了 5 次 2.0.1，修改起来已经比较麻烦了，如果出现更多次，几乎变的不可维护。所以这时候就需要定义一个变量，方便日后的维护。 ENV 定义变量 先用 ENV 的形式来修改变量，把上面的 Dockerfile.ENV 文件修改为下面的形式（这里有个小坑需要给大家说一下，就是注意在写变量时，值不要有任何的空格，否则在打包时会失败。） FROM ubuntu:latest ENV VERSION=2.0.1 RUN apt-get update &amp;&amp; \\ apt-get install -y wget &amp;&amp; \\ wget https://github.com/ipinfo/cli/releases/download/ipinfo-${VERSION}/ipinfo_${VERSION}_linux_amd64.tar.gz &amp;&amp; \\ tar zxf ipinfo_${VERSION}_linux_amd64.tar.gz &amp;&amp; \\ mv ipinfo_${VERSION}_linux_amd64 /usr/bin/ipinfo &amp;&amp; \\ rm -rf ipinfo_${VERSION}_linux_amd64.tar.gz 这样写之后，如果以后版本改变了，我们只要修改一处，就可以完成所有的修改了。 我们现在来构建一下这个 ENV 的镜像。 docker image build -f Dockerfile.ENV -t ipinfo-env . ARG 定义变量 跟上面的方法一样用 ARG 定义变量效果是一样。只是把 ENV 换成了 ARG。这个文件是 Dockerfile.ARG，内容如下： FROM ubuntu:latest ARG VERSION=2.0.1 RUN apt-get update &amp;&amp; \\ apt-get install -y wget &amp;&amp; \\ wget https://github.com/ipinfo/cli/releases/download/ipinfo-${VERSION}/ipinfo_${VERSION}_linux_amd64.tar.gz &amp;&amp; \\ tar zxf ipinfo_${VERSION}_linux_amd64.tar.gz &amp;&amp; \\ mv ipinfo_${VERSION}_linux_amd64 /usr/bin/ipinfo &amp;&amp; \\ rm -rf ipinfo_${VERSION}_linux_amd64.tar.gz 我们可以通过命令来构建一下 ARG 的镜像： docker image build -f `Dockerfile.ARG -t` ipinfo-arg . ENV 和 ARG 的不同点 总的来说 ARG 和 ENV 有两点不同，第一点是声明变量的作用域不同，第二点是 ARG 声明后，可以在构建时修改变量。 ARG 是构建环境，ENV 可带到镜像中 用交互模式进入到 ipconfig-env 镜像中，然后输入 env 可以看到当前镜像的信息。 docker container run -it ipinfo-env 然后输入 env，可以看到里边是会有 VERSION 变量的。 ARG 可以在构建镜像时改变变量值 在构建时，可以使用 —build-arg 参数来更改变量的值，比如现在要把变量 VERSION 的值进行修改,就可以使用下面的命令。 docker image build -f Dockerfile.ARG -t ipinfo-arg-2.0.0 --build-arg VERSION=2.0.0 . 这时候我们再使用交互模式，开启 ipinfo-arg-2.0.0 容器。 docker container run -it ipinfo-arg-2.0.0 然后再通过 shell 命令，ipinfo verison 查看 ipinfo 的版本，可以看到版本已经变成了 2.0.0 了。 4.5 Dockerfile CMD 与 ENTRYPOINT 指令 CMD 容器启动命令 CMD 指令的格式有一下两种： shell格式：CMD &lt;命令&gt; CMD node hello.js exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数 1&quot;, &quot;参数 2&quot;...] CMD [&quot;node&quot;,&quot;hello.js&quot;] CMD 命令在使用时，有三个基本原则需要我们遵守。 容器启动时默认执行的命令 如果docker container run 启动容器时指定了其它命令，则 CMD 命令会被忽略 如果定义多个 CMD，只有最后一个 CMD 执行 ENTRYPOINT 入口点 ENTRYPOINT 的格式和 CMD 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐， 需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令， 换句话说实际执行时，将变为： &lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 5 Docker Compose 5.1 Docker Compose 介绍 熟悉 Linux 都知道，我们可以把很多相关的命令写成一个 xxx.sh 文件，而且这些步骤也是相对固定的。 这样直接运行 sh 文件，就可以逐一执行很多相关的 Docker 命令。这种形式可以减少出错和解决复用问题。Docker 很贴心的为我们准备了一个专门的工具 docker-compose，实现类似 sh 文件的功能。让我们更加轻松的实现多 Docker 命令的操作。 你也可以把 docker-compose 就是把很多 Docker 命令写入一个专属的文件 docker-compose.yml，然后执行这个文件，就可以直接启动我们想要的容器。docker-compose 也为我们提供了对应的操作命令: docker-compose up 、docker-compose stop。 也就是说，操作 docker-compose 会有两个大的部分需要操作: 第一部分：编写 docker-compose.yml 文件。 第二部分：输入相关的命令构筑容器。 5.2 Docker Compose 文件结构 yaml 文件的基础结构 基本的 docker-compose.yml 文件格式如下： version: '3.8' services: # 容器 servicename: # 服务名字，这个名字也是内部 bridge 网络可以使用的 DNS name image: # 镜像的名字 command: # 可选，如果设置，则会覆盖默认镜像里的 CMD命令 environment: # 可选，相当于 docker run里的 --env volumes: # 可选，相当于docker run里的 -v networks: # 可选，相当于 docker run里的 --network ports: # 可选，相当于 docker run里的 -p servicename2: volumes: # 可选，相当于 docker volume create networks: # 可选，相当于 docker network create 下面我们以一个 wordpress 的镜像为例，制作 yaml 文件。 用 Docker 命令的写法： docker container run -d -p 80:80 wordpress 用 yaml 文件的写法： version: '3.8' services: my-wordpress: image: wordpress:latest ports: - 80:80 docker-compose 版本说明 https://docs.docker.com/desktop/ 打开这个网址，就会看到 docker-compose 和 Docker 版本的兼容关系表。比如 3.8 版本，要求 Docker Engine 的版本是 19.03.0+。 我们可以使用下面的命令查看当前电脑的版本。 docker --version Docker version 20.10.10, build b485636 可以看到，我们现在的 Docker 版本是完全符合 docker-compose 的，所以在 yaml 文件的最开始写 version: '3.8' 是没有问题的。 这里需要说的是: docker-compose 现在有两个主要版本 Version3 和 Version2。这两个版本的 yaml 写法也略有不同，但是基础语法是相同的。 5.3 Docker Compose 基础命令 docker-compose 的命令我们可以直接在终端输入 docker-compose 查看： Commands: build Build or rebuild services config Validate and view the Compose file create Create services down Stop and remove resources events Receive real time events from containers exec Execute a command in a running container help Get help on a command images List images kill Kill containers logs View output from containers pause Pause services port Print the public port for a port binding ps List containers pull Pull service images push Push service images restart Restart services rm Remove stopped containers run Run a one-off command scale Set number of containers for a service start Start services stop Stop services top Display the running processes unpause Unpause services up Create and start containers version Show version information and quit docker-compose 启动容器 上一节我们配置了一个关于 wordpress 服务的 docker-compose.yml 文件： version: '3.8' services: my-wordpress: image: wordpress:latest ports: - 80:80 现在我们打开 VSCode 进入该文件所在的目录，打开终端输入容器启动命令 docker compose up，就可以开启 wordpress 容器了。但这时候的容器开启方式是有日志输出的，并且窗口被占用了。没办法进行其它操作了。可以加入 -d 参数，解决这个问题。 docker compose up -d 这样就是后台运行模式了，我们就可以继续操作这个终端了，如果你想查看 service 运行情况，可以使用下面的命令： $ docker-compose ps Name Command State Ports ----------------------------------------------------------------------------------------------- test_my-wordpress_1 docker-entrypoint.sh apach ... Up 0.0.0.0:80-&gt;80/tcp,:::80-&gt;80/tcp docker-compose 停止和删除容器 当你不在使用这个 service 的时候，就可以使用 stop 命令停止。停止以后，容器就处于 Exited 模式了。容器已经停止，就可以进行清理了。 docker compose stop rm 命令会删除掉由 docker compose 所建立的容器，但用 docker 命令创建的容器不会被删除，对应的网络也不会被删除。 docker compose rm docker-compose 命名规则 用 docker-compose 创建的容器，名字都会加入一个对应文件夹的名字，比如我在的文件夹叫做 test ，而我在 yaml 文件中起的名字是 my-wordpress，最终容器的名字就是 test_my-wordpress_1。 如果你想更改容器的名字，你可以在 yaml 文件里使用 contaner_name: wordpress-demo指定这个名字： version: '3.8' services: my-wordpress: container_name: wordpress-demo image: wordpress:latest ports: - 80:80 5.4 Docker Compose 自定义镜像构筑 如果我们想使用自己的 Dockerfile 去启动自定义的镜像容器，我们可以按以下步骤： 先创建一个 Dockerfile 文件 FROM node:latest CMD [] 在相同目录下创建 docker-compose.yml 文件 version: '3.8' services: my-node: build: . container_name: 'my-node' 这里的 build: . 意思是：根据当前目录下 Dockerfile 文件构筑镜像，再启动容器。 执行 docker-compose up -d 容器启动之后，你再使用 docker image ls 会看到自定义镜像。 参考文章 Docker Docs Docker -- 从入门到实践 跟胖哥一起学 Docker ","link":"https://wuwenbang.github.io/post/docker-xue-xi-bi-ji/"},{"title":"TypeScript + React 实践总结","content":"本文根据日常的开发实践，参考优秀的文档、文章，总结出一些TypeScript在React开发中实用的技巧和经验。 由于日常开发中已全面拥抱函数式组件和 React Hooks，所以 class 类组件的写法这里不提及。 构建项目 markdown 构筑一个React with TypeScript项目最快的方式就是使用 Facebook 官方脚手架create-react-app提供的TypeScript模版。运行以下指令： $ create-react-app my-app --template typescript 生成后的项目文件会多有些许不同，主要新增了以下配置： .tsx：使用 TypeScript 的 JSX 文件扩展； tsconfig.json：默认的 TypeScript 的配置文件； react-app-env.d.ts：TypeScript 声明文件， 注释的内容会作为编译器指令使用。 函数式组件 普通声明 interface PropsType { value: string children: React.ReactNode // 显示声明 } const MyComponent = ({ title, children }: PropsType) =&gt; { return &lt;div title={title}&gt;{children}&lt;/div&gt; } 使用 React.FC 声明 PropsType作为React.FC的范型参数（推荐方式） interface PropsType { title: string } const MyComponent: React.FC&lt;PropsType&gt; = ({ title, children }) =&gt; { return &lt;div title={title}&gt;{children}&lt;/div&gt; } 使用 React.FC 声明函数组件与 普通声明 的区别是： React.FC 是隐式声明 children（目前存在一些issue） ，而 普通声明 则是显示的声明 children 。 React.FC 显式地定义了返回类型，普通声明则是隐式推导的。 React.FC 对静态属性：displayName、propTypes、defaultProps提供了类型检查和自动补全。 Props 常用的基础 Props 类型 interface PropsType = { // 基本类型 message: string; count: number; disabled: boolean; // 数组 names: string[]; // 联合类型 status: 'waiting' | 'success'; // 对象 obj: { id: string; title: string; }; // 对象数组 objArr: { id: string; title: string; }[]; // Map类型 map1: { [key: number]: string; }; // Map类型的另一种实现方式 map2: Record&lt;number, string&gt;; // 没有参数&amp;返回值的函数 onClick: () =&gt; void; // 携带参数的函数 onChange: (id: number) =&gt; void; // 携带点击事件的函数 onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void; // 可选的属性 optional?: OptionalType; }; 常用的 React Props 类型 export declare interface AppBetterProps { children: React.ReactNode // 一般情况下推荐使用，支持所有类型 functionChildren: (name: string) =&gt; React.ReactNode // 函数组件 style?: React.CSSProperties // 传递style对象 onChange?: React.FormEventHandler&lt;HTMLInputElement&gt; //表单事件, 泛型参数是event.target的类型 } 设置 Props 的默认值 传递Props时，设置默认值（推荐方式） interface PropsType { text: string } // 传递 props 时，设置默认值 const MyComponent: React.FC&lt;PropsType&gt; = ({ text = 'default' }) =&gt; { return &lt;div&gt;{text}&lt;/div&gt; } 通过defaultProps设置默认值 interface PropsType { text: string } const MyComponent: React.FC&lt;PropsType&gt; = ({ text }) =&gt; { return &lt;div&gt;{text}&lt;/div&gt; } // 通过 defaultProps 设置默认值 MyComponent.defaultProps = { text: 'default', } React Hooks useState 给定初始值的情况下，TypeScript 会做类型推断 const [state, setState] = useState(false) // state 会被自动推断为 boolean 类型 没有初始值或初始值为null时，可以使用联合类型 interface DataType { message: string } const [data, setData] = &lt;DataType | null&gt;useState(null) // or const [data, setData] = &lt;DataType | undefined&gt;useState() useEffect 首先看一下 useEffect 接收第一个参数的类型定义 // 1. 是一个函数 // 2. 无参数 // 3. 无返回值 或 返回一个清理函数，该函数类型无参数、无返回值 。 type EffectCallback = () =&gt; void | (() =&gt; void | undefined) 根据定义，useEffect的使用方式为 useEffect(() =&gt; { // when deps update // 可选 return () =&gt; { // when component unmount } }, [deps]) // ✅ 确保函数返回 void 或 一个返回 void|undefined 的清理函数 同理，用 async await 语法处理异步请求，类似传入一个 () =&gt; Promise&lt;void&gt; 函数，与 EffectCallback 类型不匹配。 // ❌ error useEffect(async () =&gt; { const { data } = await ajax(params) // todo }, [params]) 异步请求的处理方式： // ✅ 立即执行函数 useEffect(() =&gt; { ;(async () =&gt; { const { data } = await ajax(params) // todo })() }, [params]) // ✅ 或者 then 也是可以的 useEffect(() =&gt; { ajax(params).then(({ data }) =&gt; { // todo }) }, [params]) useRef useRef 一般用于两种场景 引用 DOM 元素； 不想作为其他 hooks 的依赖项，因为 ref 的值引用是不会变的，变的只是 ref.current。 useRef 传递非空初始值的时候可以推断类型， 也可以通过传入第一个泛型参数来定义类型，约束 ref.current 的类型。 // 引用DOM const domRef = React.useRef&lt;HTMLDivElement | null&gt;(null) // 非依赖项值 const countRef = React.useRef&lt;number&gt;(0) useReducer 使用 useReducer 时，多多利用 联合类型 来精确辨识、收窄确定的 type 的 payload 类型。 一般也需要定义 reducer 的返回类型，不然 TS 会自动推导。 // 使用联合类型约束 Action 的 type 和 payload type ACTIONTYPE = { type: 'increment'; payload: number } | { type: 'decrement'; payload: string } | { type: 'initial' } // reducer function reducer(state: typeof initialState, action: ACTIONTYPE) { switch (action.type) { case 'increment': return { count: state.count + action.payload } case 'decrement': return { count: state.count - Number(action.payload) } case 'initial': return { count: initialState.count } default: throw new Error() } } function Counter() { const [state, dispatch] = useReducer(reducer, initialState) return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({ type: 'decrement', payload: '5' })}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: 'increment', payload: 5 })}&gt;+&lt;/button&gt; &lt;/&gt; ) } useContext 通过React.createContext&lt;Type&gt;()的范型函数定义共享状态的类型。 下例是 useContext 和 useReducer 结合使用，来管理全局的数据流。 interface AppContextInterface { state: typeof initialState dispatch: React.Dispatch&lt;ACTIONTYPE&gt; } // 通过范型定义 Context 的类型 const AppCtx = React.createContext&lt;AppContextInterface&gt;({ state: initialState, dispatch: (action) =&gt; action, }) const App = (): React.ReactNode =&gt; { const [state, dispatch] = useReducer(reducer, initialState) return ( &lt;AppCtx.Provider value={{ state, dispatch }}&gt; &lt;Counter /&gt; &lt;/AppCtx.Provider&gt; ) } // 消费 context function Counter() { const { state, dispatch } = React.useContext(AppCtx) return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({ type: 'decrement', payload: '5' })}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: 'increment', payload: 5 })}&gt;+&lt;/button&gt; &lt;/&gt; ) } 事件处理 事件对象类型 在事件处理函数中，我们经常性的需要使用 event 对象，比如获取Input事件的e.target.value，鼠标事件的clientX、clientY。 在刚接触TypeScript开发时，我都是直接把 event 设置为 any 类型，但是这样就失去了TypeScript对代码进行静态检查的意义。 const onChange = (e: any) =&gt; { console.log(e.target.value) } 幸运的是 React 的声明文件提供了 Event 对象的类型声明，拿最常见的情况之一：Input的onChange事件举例： import React from 'react' const MyInput: React.FC = () =&gt; { const [value, setValue] = React.useState('') // e 的类型是 ChangeEvent // e.target 的类型是 HTMLInputElement const onChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; { setValue(e.target.value) } return &lt;input value={value} onChange={onChange} id=&quot;input-example&quot; /&gt; } export default MyInput 常用 Event 事件对象类型 ClipboardEvent&lt;T = Element&gt; 剪贴板事件对象 DragEvent&lt;T = Element&gt; 拖拽事件对象 ChangeEvent&lt;T = Element&gt; Change 事件对象 KeyboardEvent&lt;T = Element&gt; 键盘事件对象 MouseEvent&lt;T = Element&gt; 鼠标事件对象 TouchEvent&lt;T = Element&gt; 触摸事件对象 WheelEvent&lt;T = Element&gt; 滚轮事件对象 AnimationEvent&lt;T = Element&gt; 动画事件对象 TransitionEvent&lt;T = Element&gt; 过渡事件对象 事件处理函数类型 当我们定义事件处理函数时有没有更方便定义其函数类型的方式呢？答案是使用 React 声明文件所提供的 EventHandler 类型别名，通过不同事件的 EventHandler 的类型别名来定义事件处理函数的类型。 EventHandler 类型实现源码 node_modules/@types/react/index.d.ts 。 type EventHandler&lt;E extends SyntheticEvent&lt;any&gt;&gt; = { bivarianceHack(event: E): void }['bivarianceHack'] type ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt; type ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt; type DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt; type FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt; type FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt; type ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt; type KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt; type MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt; type TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt; type PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt; type UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt; type WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt; type AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt; type TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt; 实例： interface PropsType { onClick: MouseEventHandler&lt;HTMLDivElement&gt; onChange: ChangeEventHandler&lt;HTMLInputElement&gt; } 参考资料 TypeScript 中文手册 React React with TypeScript 最佳实践 ","link":"https://wuwenbang.github.io/post/typescript-react-shi-jian-zong-jie/"},{"title":"TypeScript 从集合论的角度理解类型系统","content":"0. 前言 在学习和使用 TypeScript 的过程中，有一些问题一直困惑着我： 比如说联合类型与交叉类型在基础类型和对象类型上的不同表现： 对于基础类型来说，联合类型是类型的并集，交叉类型是类型的交集。 // 联合类型 type Union = string | number // Union = string | number // 交叉类型 type Intersection = string &amp; number // Intersection = never 对于对象类型来说，联合类型是属性的交集（勘误：只有在被赋值的对象拥有全部属性的情况下，才表现为属性的交集），交叉类型是属性的并集。 interface A { x: number y: number } interface B { y: number z: number } // 联合类型 type Union = A | B /* Union = { y: number } */ // 交叉类型 type Intersection = A &amp; B /* Intersection = { x: number y: number z: number } */ 再比如说条件类型的 extends 关键字到底是什么意思——可继承？可扩展？还是可赋值？ // extends =&gt; 可赋值 ？ type T1 = string extends string | number ? true : false // T1 = true // extends =&gt; 可继承 ？ interface ObjectA { x: string y: string } interface ObjectB { x: string } type T2 = ObjectA extends ObjectB ? true : false // T2 = true 上述的例子确实令人困惑，或许我们应该换个角度去思考：尝试用集合论的角度去思考 TypeScript 的类型系统。 1. 类型与集合 在 JavaScript 里，类型是满足某些特征的值的集合。例如： number 类型是是所有数字的集合。 string 类型是所有字符串的集合。 bolean 类型是 true 和 false 的集合。 undefined 类型是 undefined 的集合。 总结一下就是：类型 对应集合论里的 集合，值 对应集合论里的 元素。 而在 TypeScript 里，我们可以给变量声明类型，并将对应类型的值赋予它。 let str: string = 'xxx' str = 'yyy' let num: number = 123 num = 456 而对于对象的类型，也就是类（Class），集合的概念就非常容易混淆，我们来看下面一个例子： interface A { x: number } interface B { x: number y: number } const b: B = { x: 1, y: 2, } const a: A = b // ok 示例中，对象 b 的类型是 { x: number, y: number }，但是它却可以赋值给类型为 { x: number } 的变量 a。这看似不合理的现象，通过集合论的观点便可以解释： 我们把类 A 即 { x: number } 看成所有拥有属性 x: number 的对象的集合，也就是说只要拥有属性 x: number 的对象都可以看成集合 A 的一个元素（或者类 A 的实例）。 那么因为 b = { x:1, y:2 } 拥有属性 x: number =&gt; 所以对象 b 是类 A 的一个实例 =&gt; 所以 b 可以赋值给类型为 A 的变量 a。 关于对象，我们必须清晰地知道：对象类型（类）是若干对象的集合，而不是属性的集合。只要一个对象具有类所描述的全部属性，那么该对象就是该类的元素（实例）。 2. 交叉类型与联合类型 交叉类型（Intersection Types） 对应集合论的 交集（Intersection） 联合类型（Union Types） 对应集合论的 并集（Union） （PS：从英文原文翻译的角度来看，我认为将 交叉类型与联合类型 翻译成 交集类型和并集类型 可能更加贴切。） 2.1 交叉类型与联合类型的简单运算 关于交叉类型 &amp; 和联合类型 | 的运算，我们来看一个简单的例子： type A = 1 | 2 type B = 2 | 3 // A B 交集 type C = A &amp; B // C = 2 // A B 并集 type D = A | B // D = 1 | 2 | 3 // A number 交集 type E = A &amp; number // E = A = 1 | 2 // A number 并集 type F = A | number // F = number // 空集 never type G = number &amp; string // G = never // 全集 unknown type H = number | unknown // H = unknown A - F 符合集合论交集并集的运算规律 G never 意为不会出现的类型，其符合空集的计算规律，遂可以理解为空集。 H unkonwn 意为未知的类型，其符合全集的计算规律，遂可以理解为全集。 集合论中交集与并集的运算特性，交叉类型和联合类型也满足： 对于交集运算符 &amp;： 唯一性: A &amp; A 等价于 A. 满足交换律: A &amp; B 等价于 B &amp; A . 满足结合律: (A &amp; B) &amp; C 等价于 A &amp; (B &amp; C). 父类型收敛: 当且仅当 B 是 A 的父类型时，A &amp; B 等价于 A. 对于并集运算符 |： 唯一性: A | A 等价于 A. 满足交换律: A | B 等价于 B | A. 满足结合律: (A | B) | C 等价于 A | (B | C). 子类型收敛: 当且仅当 B 是 A 的子类型时，A | B 等价于 A. 2.2 交叉类型与联合类型高级运算 对于对象类型的交叉类型和联合类型，同样符合集合论的规律： 交叉类型高级运算 interface A { x: number y: number } interface B { y: number z: number } // 交叉类型 type Intersection = B &amp; A const obj1: Intersection = { x: 1, y: 2, z: 3, } obj1.x // ok obj1.y // ok obj1.z // ok 交叉类型 Intersection 是对象 A 和 B 的交集，是对象集合的交集，表现为拥有 A 和 B 的全部属性，是属性集合的并集。。 赋值上：只有具有 A 和 B 所有的属性的对象才能赋值给 Intersection。 访问上：交叉类型 Intersection 可以访问 A 和 B 的所有属性。 联合类型高级运算 interface A { x: number y: number } interface B { y: number z: number } // 联合类型 type Union = B | A const obj1: Union = { x: 1, y: 2, z: 3, } const obj2: Union = { x: 1, y: 2, } const obj3: Union = { y: 2, z: 3, } obj1.x // error obj1.y // ok obj1.z // error 联合类型 Union 是对象 A 和 B 的并集，即对象集合的并集。 赋值上：具有 A或B或A &amp; B 的属性的对象能赋值给 Union。 访问上：为了类型安全，当赋值为 A 或 B 时，联合类型 Union 只能访问 A 或 B ；当赋值为 A &amp; B 时（即全部属性），联合类型 Union 只能访问 A 和 B 的共有属性。 3 extends 关键字 根据集合论，A extends B 的语意是： A 为 B 的子集。 3.1 extends 用作泛型约束 表达式：T extends U 作用：泛型约束用作限制泛型的类型，即泛型T必须是类型U的子集，才能通过编译。 function needNumber&lt;T extends number&gt;(value: T): number { return value + 1 } // 满足 number 类型的子集 needNumber(1) //ok // 不是 number 类型的子集 needNumber('1') //error 对象类型同理： interface Point { x: number y: number } function Sum&lt;T extends Point&gt;(value: T): number { return value.x + value.y } // 满足 Point 类型的子集 Sum({ x: 1, y: 2 }) // ok Sum({ x: 1, y: 2, z: 3 }) // ok // 不是 Point 类型的子集 Sum({ x: 1 }) // error 3.2 extends 用作条件泛型 表达式：T extends U ? X : Y 作用：条件类型是一个三元运算表达式，如果 T 是 U 的子集，则表达式的值为 X，否则为 U。 type IsNumber&lt;T&gt; = T extends number ? true : false type Result1 = IsNumber&lt;1&gt; // true type Result2 = IsNumber&lt;'1'&gt; // false 对象类型同理： interface Point { x: number y: number } type IsPointSubset&lt;T&gt; = T extends Point ? true : false type Result1 = IsPointSubset&lt;{ x: number; y: number }&gt; // true type Result2 = IsPointSubset&lt;{ x: number; z: number }&gt; // false 4. 参考资料 TypeScript 中文手册 Typescript 进击的基础（一）交叉类型和联合类型-集合论角度理解 ","link":"https://wuwenbang.github.io/post/typescript-cong-ji-he-lun-de-jiao-du-li-jie-lei-xing-xi-tong/"},{"title":"TypeScript 工具类型","content":"前言 Typescript 中默认内置了很多工具泛型，通过使用这些工具，可以使得我们定义类型更加灵活，高效。本文将会介绍常用泛型工具的使用技巧，以及对其实现原理进行相应的解析，如果有错误的地方，还望指出。 Partial&lt;T&gt; 作用：将传入对象类型 T 的属性变为可选属性。 示例： interface Person { name: string; age: number; } const tom: Partial&lt;Person&gt; = { name: &quot;Tom&quot;, }; Partial&lt;Person&gt; 等价于 interface Person { name?: string; age?: number; } 实现原理： 通过关键字 keyof 将传入对象类型的键值转换为联合类型。 通过关键字 in 遍历联合类型，即遍历对象的键值。 通过类型映射，将对象的属性转换为可选属性 type MyPartial&lt;T&gt; = { [P in keyof T]?: T[P]; }; Readonly&lt;T&gt; 作用：把传入对象类型 T 属性变为只读属性。 示例： interface Person { name: string; age: number; } const tom: Readonly&lt;Person&gt; = { name: &quot;Tom&quot;, age: 18; }; tom.age = 22 // error Readonly&lt;Person&gt; 等价于 interface Person { readonly name: string; readonly age: number; } 实现原理： 与Partial类似： 通过关键字 keyof 将传入对象类型的键值转换为联合类型。 通过关键字 in 遍历联合类型，即遍历对象的键值。 通过类型映射，将对象的属性转换为只读属性 type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P]; }; Required&lt;T&gt; 作用：把传入对象类型 T 属性变为必填属性。 示例： interface Person { name?: string; age?: number; } let tom: Required&lt;Person&gt; tom = { name: &quot;Tom&quot;, age: 18; }; // ok tom = { name: &quot;Tom&quot;, }; // error 实现原理： 与Partial类似： 通过关键字 keyof 将传入对象的键值转换为枚举类型。 通过关键字 in 遍历枚举类型，即遍历对象的键值。 通过类型映射，再统一通过 - 修饰符移除 ? 修饰符，从而转变为必填状态。 type Required&lt;T&gt; = { Required [P in keyof T]: T[P]; }; Record&lt;K,T&gt; 作用：它用来生成一个属性名为 K，属性值类型为 T 的对象类型集合。 示例： // 快速生成一个 Person 对象 type Person = Record&lt;&quot;name&quot; | &quot;country&quot;, string&gt;; const Tom: Person = { name: &quot;Tom&quot;, country: &quot;America&quot; }; 实现原理: 通过 K extends keyof any 对 K 参数进行约束，将其约束为任意类型 any 的键值。 通过 in 对键值集合 K 进行遍历，然后生成类型为 T 的键值对集合。 type MyRecord&lt;K extends keyof any, T&gt; = { [P in K]: T; }; Exclude&lt;T,K&gt; 作用：从类型 T 中排除所有可以赋值给类型 U 的类型。 示例： // 从 &quot;a&quot; | &quot;b&quot; | &quot;c&quot; 中排除掉 &quot;a&quot; 类型 type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // T1 = &quot;b&quot; | &quot;c&quot; // 从 string | number | boolean 中排除掉 string 类型 type T2 = Exclude&lt;string | number | boolean, string&gt;; // T2 = number | boolean 实现原理： 通过条件类型T extends U ? never : T 对 T 参数进行判别： 如果 T 可赋值给 U ，那么返回 never（即排除掉T）。 如果 T 不可赋值给 U ，那么返回 T。 通过分布式条件类型，如果 T 为联合类型，则将条件类型的结果分发为联合类型。 type Exclude&lt;T, U&gt; = T extends U ? never : T; Extract&lt;T,K&gt; 作用：与 Exclude 相反，从类型 T 中提取所有可以赋值给类型 U 的类型。 示例： // 从 &quot;a&quot; | &quot;b&quot; | &quot;c&quot; 中提取出 &quot;a&quot; 类型 type T1 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // T1 = &quot;a&quot; // 从 string | number | boolean 中提取出 string 类型 type T2 = Extract&lt;string | number | boolean, string&gt;; // T2 = string type T3 = Extract&lt;string | (() =&gt; void), Function&gt;; // 相当于 type T3 = () =&gt; void; 实现原理： 与 Exclude 类似： 通过条件类型T extends U ? never : T 对 T 参数进行判别： 如果 T 可赋值给 U ，那么返回 T。 如果 T 不可赋值给 U ，那么返回 never（即排除掉T）。 通过分布式条件类型，如果 T 为联合类型，则将条件类型的结果分发为联合类型。 type Extract&lt;T, U&gt; = T extends U ? T : never; Pick&lt;T,K&gt; 作用：在 T 中，摘选出 K 属性。 示例： interface Person { name: string; age: number; } // 从 Person 中摘选出 name 属性 type PickPerson = Pick&lt;Person, &quot;name&quot;&gt;; const tom: PickPerson = { name: &quot;Tom&quot;, }; 实现原理： 通过 K extends keyof T 对 K 参数进行约束，将其约束为 T 的键值范围内。 通过 in 对键值集合 K 进行遍历，然后生成类型为 T 的键值对集合。 type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P]; }; Omit&lt;T,K&gt; 作用：在 T 中，剔除掉 K 属性。 示例： interface Person { name: string; age: number; } // 从 Person 中剔除掉 name 属性 type OmitPerson = Pick&lt;Person, &quot;name&quot;&gt;; const tom: PickPerson = { age: 18, }; 实现原理： 通过 K extends keyof T 对 K 参数进行约束，将其约束为 T 的键值范围内。 通过 Exclude&lt;keyof T, K&gt; 将类型集合 T 中的 K 类型排除掉。 通过 Pick&lt;T,Exclude&lt;keyof T, K&gt;&gt; 在 T 中摘选出排除掉 K 的 T 的属性。 type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; ReturnType&lt;T&gt; 作用：获取函数的返回值类型。 示例： type Fun = () =&gt; string; // 获取 Fun 返回值的类型 type T1 = ReturnType&lt;Fun&gt;; // T1 = string type T2 = ReturnType&lt;() =&gt; { x: number; y: number }&gt;; // T2 = { x: number, y: number } 实现原理： 通过 extends 对 T 参数进行约束，(...args: any) =&gt; any 表示一个函数类型，即 T 参数的类型必须是一个函数类型。 T extends U ? X : Y 是条件类型（注意和之前表示约束的 extends 做区分），其中 T 是泛型参数，U 是条件部分，X 是符合条件的返回结果，Y 是不符合条件的返回结果。 推断类型 infer 的作用是：在条件类型内部声明一个类型变量。(...args: any) =&gt; infer R 是条件类型的条件部分，它声明了一个类型变量 R ，用来存储函数的返回类型。 T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any表示： 如果 T 是函数类型（(...args: any) =&gt; infer R），则返回 R , 即函数的返回类型。 如果 T 不是函数类型（(...args: any) =&gt; infer R），则返回 any。 type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends ( ...args: any ) =&gt; infer R ? R : any; 参考资料 TypeScript 中文手册 TypeScript 内置工具泛型 ","link":"https://wuwenbang.github.io/post/typescript-gong-ju-lei-xing/"},{"title":"TypeScript 泛型总结","content":"1. 泛型是什么？ 官方的定义是： **泛型（Generics）**是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 通俗的解释是：泛型是类型系统中的参数，就像函数的参数一样，只不过函数的参数传递的是值，而泛型传递的是类型。他只出现在现在函数，接口，和类中，主要作用是为了类型的复用。 设计泛型的关键目的：是在成员之间提供有意义的约束，这些成员可以是：函数参数、函数返回值、类的实例成员和类的方法。 可能这么讲会有一些抽象，接下来我们以泛型函数为例，举一个简单的例子： 首先我们来定义一个通用的 identity 函数，该函数接收一个number类型的参数，并直接返回这个值： function identity(value: number): number { return value; } identity(1); // ok identity(&quot;hello&quot;); // error // 编译器报错： Argument of type 'string' is not assignable to parameter of type 'number'.ts(2345) 现在，identity 函数能且只能传入 number 类型的参数，如果我想传入 string 类型的 TypeScript 编译器会报错，那么该怎么办呢？或许你会想到 any 类型。 function identity(value: any) { return value; } identity(1); // ok identity(&quot;hello&quot;); // ok 好吧，传入 any 确实可以生效，但我们失去了定义应该返回哪种类型的能力，并且在这个过程中也丧失了 TypeScript 的类型保护作用。 我们的目标是让 identity 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用 泛型函数 来解决这个问题： 2. 泛型函数 定义泛型函数： function identity&lt;T&gt;(value: T): T { return value; } identity&lt;number&gt;(1); // ok identity&lt;string&gt;(&quot;hello&quot;); // ok 对于刚接触 TypeScript 泛型的读者来说，首次看到 &lt;T&gt; 语法会感到陌生。但这没什么可担心的，就像传递参数一样，通过参数变量 T，把用户想要传入的类型，链式传递到后面函数的类型定义中去。 （图片来源：掘金阿宝哥） 参考上面的图片，通过 &lt;T&gt; 声明 类型变量 T，然后在后面的函数参数类型声明、和函数返回值类型声明中使用：(value: T): T。 理论上，&lt; &gt;类可以声明任意字符作为类型变量，但在定义泛型时通常用T作为类型变量名称，其中 T 代表 Type。当然，除了 T 之外，以下是常见泛型变量代表的意思： K（Key）：表示对象中的键类型。 V（Value）：表示对象中的值类型。 E（Element）：表示元素类型。 U（T 后面的字符）：表示第二个类型参数（以此类推）。 很多时候并不是只能定义一个类型变量，我们可以引入更多的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数： function identity&lt;T, U&gt;(value: T, message: U): T { console.log(message); return value; } console.log(identity&lt;Number, string&gt;(100, &quot;Hello Generics&quot;)); // Hello Generics // 100 （图片来源：掘金阿宝哥） 除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如： function identity&lt;T, U&gt;(value: T, message: U): T { console.log(message); return value; } console.log(identity(100, &quot;Hello Generics&quot;)); // Hello Generics // 100 3. 泛型接口 定义泛型接口： interface GenericInterface&lt;T&gt; { data: T; } 接口泛型的使用方式和函数类似，我们可以通过&lt;T&gt;来声明参数变量T，并将其用在后面接口属性的类型定义上。 泛型接口常用于定义那些，需要用户自定义类型的对象上，最常见的就是 网络请求的响应对象了，以Axios为例： 假设我们通过 axios.get 发起网络请求，我们可以通过axios.get&lt;DataType&gt;传入data的类型，最后拿响应 res 时，我们就可以明确的知道data的数据类型 ： interface DataType { id: number; message: string; } axios.get&lt;DataType&gt;(&quot;https://www.xxx.com&quot;).then((res) =&gt; { console.log(res.data.message); }); 其中axios实例，以及响应res的泛型接口如下定义： interface AxiosInstance { // ... get&lt;T = any, R = AxiosResponse&lt;T&gt;&gt;( url: string, config?: AxiosRequestConfig ): Promise&lt;R&gt;; } interface AxiosResponse&lt;T = any&gt; { data: T; status: number; statusText: string; headers: any; config: AxiosRequestConfig; request?: any; } 其中响应的 data 是 axios 不知道的，所以 axios 通过泛型的方式，将类型T传递给后面的data属性。 4. 泛型类 在类中使用泛型也很简单，我们只需要在类名后面，使用 &lt;T, ...&gt; 的语法定义任意多个类型变量。 定义泛型类： interface GenericInterface&lt;U&gt; { value: U; getValue: () =&gt; U; } class GenericClass&lt;T&gt; implements GenericInterface&lt;T&gt; { value: T; constructor(value: T) { this.value = value; } getValue(): T { return this.value; } } const myNumberClass = new GenericClass&lt;number&gt;(10); console.log(myNumberClass.getValue()); // 10 const myStringClass = new GenericClass&lt;string&gt;(&quot;Hello Generics!&quot;); console.log(myStringClass.getValue()); // Hello Generics! 接下来我们以实例化 myNumberClass 为例，来分析一下其调用过程： 在实例化 GenericClass 对象时，我们传入 number 类型和构造函数参数值 68； 之后在 GenericClass 类中，类型变量 T 的值变成 number 类型； GenericClass 类实现了 GenericInterface&lt;T&gt;，而此时 T 表示 number 类型，因此等价于该类实现了 GenericInterface&lt;number&gt; 接口； 而对于 GenericInterface&lt;U&gt; 接口来说，类型变量 U 也变成了 number。这里我有意使用不同的变量名，以表明类型值沿链向上传播，且与变量名无关。 5. 泛型约束 有时候我们希望限制泛型变量接受的类型（比如我只希望接受拥有.length属性的类型），我们就需要泛型约束。下面我们来举几个例子，介绍一下如何使用泛型约束。 5.1 确保属性存在 有时候，我们希望类型变量对应的类型上存在某些属性。这时，除非我们显式地将特定属性定义为类型变量，否则编译器不会知道它们的存在。 一个很好的例子是在处理字符串或数组时，我们会假设 length 属性是可用的。让我们再次使用 identity 函数并尝试输出参数的长度： function identity&lt;T&gt;(arg: T): T { console.log(arg.length); // error: T doesn't have .length return arg; } 在这种情况下，编译器将不会知道 T 确实含有 length 属性，尤其是在可以将任何类型赋给类型变量 T 的情况下。我们需要做的就是让类型变量 extends 一个含有我们所需属性的接口，比如这样： interface Length { length: number; } function identity&lt;T extends Length&gt;(arg: T): T { console.log(arg.length); // ok: 可以获取length属性 return arg; } T extends Length 用于告诉编译器，我们支持已经实现 Length 接口的任何类型。 之后，当我们使用不含有 length 属性的对象作为参数调用 identity 函数时，TypeScript 会提示相关的错误信息： identity(10); // Error // Argument of type '68' is not assignable to parameter of type 'Length'.(2345) 5.2 检查对象上的键是否存在 泛型约束的另一个常见的使用场景就是检查对象上的键是否存在。不过在看具体示例之前，我们得来了解一下 keyof 操作符，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。我们来举个 keyof 的使用示例： interface Person { name: string; age: number; location: string; } type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot; | &quot;location&quot; type K2 = keyof Person[]; // number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ... 通过 keyof 操作符，我们就可以获取指定类型的所有键，之后我们就可以结合前面介绍的 extends 约束，即限制输入的属性名包含在 keyof 返回的联合类型中。具体的使用方式如下： function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] { return obj[key]; } const obj = { name: &quot;tom&quot;, }; getProperty(obj, &quot;name&quot;); // ok getProperty(obj, &quot;age&quot;); // error 属性名 age 不存在 obj 上 在以上的 getProperty 函数中，我们通过K extends keyof T 确保参数 key 一定是对象中含有的键，这样就不会发生运行时错误。这是一个类型安全的解决方案，与简单调用 let value = obj[key]; 不同。 在以上示例中，对于 getProperty(obj, &quot;age&quot;) 这个表达式，TypeScript 编译器会提示以下错误信息： // 编译器报错：Argument of type '&quot;age&quot;' is not assignable to parameter of type '&quot;name&quot;'.ts(2345) 很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。 6. 泛型参数默认类型 我们都知道 JavaScript 的函数参数可以设置初始值（defalut value），类似地，我们也可以为泛型参数设置默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。 泛型参数默认类型与普通函数默认值类似，对应的语法很简单，即 &lt;T=Default Type&gt;，对应的使用示例如下： interface MyObject&lt;T = string&gt; { id: T; } const numObject: MyObject = { id: &quot;abc&quot; }; const strObject: MyObject&lt;number&gt; = { id: 123 }; 泛型参数的默认类型遵循以下规则： 有默认类型的类型参数被认为是可选的。 必选的类型参数不能在可选的类型参数后。 如果类型参数有约束，类型参数的默认类型必须满足这个约束。 当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。 如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。 一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。 一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。 7. 泛型条件类型 通过泛型条件类型，我们可以根据某些条件得到不同的类型，这里所说的条件是类型兼容性约束。尽管以上代码中使用了 extends 关键字，也不一定要强制满足继承关系，而是检查是否满足结构兼容性。 条件类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一： T extends U ? X : Y 以上表达式的意思是：若 T 能够赋值给 U（T 属于与 U的子类），那么类型是 X，否则为 Y。在条件类型表达式中，我们通常还会结合 infer 关键字，实现类型抽取： interface MyObject&lt;T = any&gt; { key: T; } type StrObject = MyObject&lt;string&gt;; type NumObject = MyObject&lt;number&gt;; type ObjectMember&lt;T&gt; = T extends MyObject&lt;infer V&gt; ? V : never; type StrObjectMember = ObjectMember&lt;StrObject&gt;; // string type NumObjectMember = ObjectMember&lt;NumObject&gt;; // number 在上面示例中，当类型 T 满足 T extends MyObject 约束时，我们会使用 infer 关键字声明了一个类型变量 V，并返回该类型，否则返回 never 类型。 8. 参考文章 TypeScript 中文手册 一份不可多得的 TS 学习指南 ","link":"https://wuwenbang.github.io/post/typescript-fan-xing-zong-jie/"},{"title":"TypeScript 断言总结","content":"1. 类型断言 在使用 TypeScript 的过程中，你可能会遇到这种情况：你比 TypeScript 更加清楚某个值的类型。 比如你从异步请求中拿到一个类型为any的值，但你清楚的知道这个值就是string类型，这个时候你可以通过类型断言方式告诉编译器：&quot;嘿！相信我，我知道我在干什么！&quot;。类型断言有点类似于其他语言的类型转换，但它没有运行时的影响，只是在编译阶段起作用。 类型断言有两种形式： 1.1 尖括号语法 形式：&lt;类型&gt;变量名 let value: any = &quot;this is a string&quot;; let length: number = (&lt;string&gt;value).length; 1.2 as 语法 形式：变量名 as 类型 let value: any = &quot;this is a string&quot;; let length: number = (value as string).length; 2. 非空断言 当你明确知道某个值不可能为 undefined 和 null 时，你可以用 在变量后面加上一个 !（非空断言符号）来告诉编译器：&quot;嘿！相信我，我确信这个值不为空！&quot;。 非空断言具体的使用场景如下： function fun(value: string | undefined | null) { const str: string = value; // error value 可能为 undefined 和 null const str: string = value!; //ok const length: number = value.length; // error value 可能为 undefined 和 null const length: number = value!.length; //ok } 3. 确定赋值断言 TypeScript 的确定赋值断言，允许在实例属性和变量声明后面放置一个 ! 号，从而告诉 TypeScript 该属性会被明确地赋值。 let name!: string; 上述表达式就是对编译器说：&quot;有一个名为 name 的属性，其类型为 string | undefined。它以值 undefined 开始。但每次获取或设置该属性时，我都希望将其视为类型 string。&quot; 为了更好地理解它的作用，我们来看个具体的例子： let count: number; initialize(); // Variable 'count' is used before being assigned.(2454) console.log(2 * count); // Error function initialize() { count = 10; } 很明显该异常信息是说变量 count 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言： let count!: number; initialize(); console.log(2 * count); // Ok function initialize() { count = 10; } 4. 参考文章 TypeScript 中文手册 一份不可多得的 TS 学习指南 ","link":"https://wuwenbang.github.io/post/typescript-duan-yan-zong-jie/"},{"title":"TypeScript Type 和 Interface 的异同","content":"在使用TypeScript的时候，我们常常使用interface和type去描述复杂数据的形状和类型，比如对象和函数。由于他们的使用方式高度相似，一度让我觉得他们是可以相互替换的。但是随着更加深入的了解，我发现了他们之间的一些异同点，然我们一起来看看吧。 1. Inteface 接口 在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。 TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对对象的形状（Shape）进行描述。 1.1 接口的作用 描述对象 interface Person { name: string; age: number; run: () =&gt; void; } let tom: Person = { name: &quot;Tom&quot;, age: 23, }; 描述函数 interface Action { (): void; } const sayHi: Action = () =&gt; { console.log(&quot;Hi!&quot;); }; 1.2 可选属性与只读属性 interface Person { readonly name: string; // 只读属性：只可读取，不可更改 age?: number; // 可选属性：该对象可以拥有，也可以没有该属性 } let tom: Person = { name: &quot;Tom&quot;, }; tom.name = &quot;Jack&quot;; // error 不可更改 1.3 任意属性 有时候我们希望我们定义的对象可以拥有一个任意属性，这时我们可以使用索引签名的形式来满足上述要求。 interface Person { name: string; age?: number; [propName: string]: any; } const tom = { name: &quot;Tom&quot; }; const jack = { name: &quot;Jack&quot;, age: 5 }; const susan = { name: &quot;Susan&quot;, sex: &quot;famale&quot; }; 2. Type Alias 类型别名 2.1 类型别名的定义 type（Type Alias 类型别名）会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 // 基本类型 type Count = number; // 函数 type Fun = () =&gt; void; // 对象 type Person = { name: string; age: number; }; 3. Inteface 和 Type 的相同点 3.1 都可以用来描述对象或函数 // interface interface Point { x: number; y: number; } interface SetPoint { (x: number, y: number): void; } // type alias type Point = { x: number; y: number; }; type SetPoint = (x: number, y: number) =&gt; void; 3.2 都可以扩展 两者都可以用来扩展，但是扩展方式不同，接口的扩展就是继承，通过extends来实现。类型别名的扩展就是交叉类型，通过&amp;来实现。 // 接口扩展 interface PointX { x: number; } interface Point extends PointX { y: number; } // 类型别名扩展 type PointX = { x: number; }; type Point = PointX &amp; { y: number; }; PS：接口可以扩展类型别名，同理，类型别名也可以扩展接口。 4. Inteface 和 Type 的不同点 4.1 type 可以声明基本类型，而 interface 不行 type 可以声明基本类型 type Count = number; type Color = &quot;Red&quot; | &quot;Blue&quot;; interface 只能用来声明复杂类型（对象和函数） 4.2 扩展时表现不同 扩展接口时，TS 将检查扩展的接口是否可以赋值给被扩展的接口。 interface A { good(x: number): string; bad(x: number): string; } interface B extends A { good(x: string | number): string; bad(x: number): number; // Interface 'B' incorrectly extends interface 'A'. // Types of property 'bad' are incompatible. // Type '(x: number) =&gt; number' is not assignable to type '(x: number) =&gt; string'. // Type 'number' is not assignable to type 'string'. } 但使用交叉类型时则不会出现这种情况。我们将上述代码中的接口改写成类型别名，把 extends 换成交集运算符&amp;，TS 将尽其所能把扩展和被扩展的类型组合在一起，而不会抛出编译时错误。 type A = { good(x: number): string; bad(x: number): string; }; type B = A &amp; { good(x: string | number): string; bad(x: number): number; }; // ok 4.3 多次定义时表现不同 接口多次的声明会合并。类型别名不能重复声明。 接口可以定义多次，多次的声明会合并。 interface Point { x: number; } interface Point { y: number; } const point: Point = { x: 1 }; //error Property 'y' is missing in type '{ x: number; }' but required in type 'Point'. const point: Point = { x: 1, y: 1 }; // ok 但是类型别名如果定义多次，会报错。 type Point = { x: number; //error Duplicate identifier 'A'. }; type Point = { y: number; //error Duplicate identifier 'A'. }; 到底应该用哪个？ 如果接口和类型别名都能满足的情况下，到底应该用哪个是我们关心的问题。 感觉哪个都可以，但是强烈建议大家只要能用接口实现的就优先使用接口，接口满足不了的再用类型别名。 为什么会这么建议呢？其实在 TS 的 wiki 中有说明。具体的文章地址在这里：TS wiki 以下是Preferring Interfaces Over Intersections的译文： 大多数时候，对于声明一个对象，类型别名和接口表现的很相似。 interface Foo { prop: string; } type Bar = { prop: string }; 然而，当你需要通过组合两个或者两个以上的类型实现其他类型时，可以选择使用接口来扩展类型，也可以通过交叉类型（使用&amp;创造出来的类型）来完成，这就是二者开始有区别的时候了。 接口会创建一个单一扁平对象类型来检测属性冲突，当有属性冲突时会提示，而交叉类型只是递归的进行属性合并，在某种情况下可能产生 never 类型 接口通常表现的更好，而交叉类型做为其他交叉类型的一部分时，直观上表现不出来，还是会认为是不同基本类型的组合 接口之间的继承关系会缓存，而交叉类型会被看成组合起来的一个整体 在检查一个目标交叉类型时，在检查到目标类型之前会先检查每一个组分 参考文章 TypeScript 中文手冊 TypeScript Interface vs Type 知多少 ","link":"https://wuwenbang.github.io/post/typescript-type-he-interface-de-yi-tong/"},{"title":"TypeScript 基础类型","content":" Number 类型 let count: number = 10; // ES5：var count = 10; 2. String 类型 let name: string = &quot;hello world&quot;; // ES5：var name = 'hello world'; 3. Boolean 类型 let isCheck: boolean = false; // ES5：var isCheck = false; 4. Symbol 类型 const sym = Symbol(); let obj = { [sym]: &quot;hello world&quot;, }; console.log(obj[sym]); // hello world 5. Null 和 Undefined 类型 TypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。 let u: undefined = undefined; let n: null = null; 6. Array 类型 TypeScript 里，数组类型有两种表达形式： 直接表示：type[]。 用泛型的方式表示：Array&lt;type&gt;。 let array: number[] = [1, 2, 3]; // ES5：var array = [1,2,3]; let array: Array&lt;number&gt; = [1, 2, 3]; // Array&lt;number&gt;泛型语法 // ES5：var array = [1,2,3]; 7. Tuple（元组） 类型 数组（Array）合并了相同类型的值，而元组（Tuple）合并了不同类型的值 let array: number[] = [100, 200]; let tuple: [number, string] = [100, &quot;200&quot;]; 当赋值或访问一个已知索引的元素时，会得到正确的类型： let tuple: [string, number]; tuple[0] = &quot;Jack&quot;; tuple[1] = 22; tuple[0].substr(1); //String独有方法 tuple[1].toFixed(2); //Number独有方法 元组（Tuple）类型是固定长度，固定类型的 let tuple: [string, number]; tuple = [&quot;jack&quot;]; //❌ tuple = [100, &quot;juck&quot;]; //❌ tuple = [&quot;juck&quot;, 100]; //✅ React中的useState返回的就是元组类型： // 类型定义：返回元组类型 [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;] function useState&lt;S&gt;( initialState: S | (() =&gt; S) ): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;]; // 元组：解构赋值 const [state, setState] = useState(0); 总结：数组（Array）和元组（Tuple）的差异： Array类型统一，Tuple类型可以不一。 Array长度不限，Tuple长度限定。 8. Enum（枚举）类型 使用枚举我们可以定义一些带名字的常量，以表达限定在一定范围内值。 TypeScript 支持数字的和基于字符串的枚举。 1. 数字枚举 enum Direction { NORTH, SOUTH, EAST, WEST, } let dir: Direction = Direction.NORTH; //let dir = 0 默认情况下，NORTH 的初始值为 0，其余的成员会自动+1增长。换句话说，Direction.SOUTH值为1，Direction.EAST值为2，Direction.WEST值为3。 当然我们也可以设置 NORTH 的初始值，比如： enum Direction { NORTH = 3, SOUTH, //4 EAST, //5 WEST, //6 } 2. 字符串枚举 在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 enum Direction { NORTH = &quot;NORTH&quot;, SOUTH = &quot;SOUTH&quot;, EAST = &quot;EAST&quot;, WEST = &quot;WEST&quot;, } let dir: Direction = Direction.NORTH; //let dir = 'NORTH' 比起枚举类型，我更推荐使用联合类型来表达对于一组值的约束： const Direction = &quot;NORTH&quot; | &quot;SOUTH&quot; | &quot;EAST&quot; | &quot;WEST&quot;; let dir: Direction = &quot;NORTH&quot;; 9. Object 类型 Object 类型：它是所有 Object 类的实例的类型，它由以下两个接口来定义： Object 接口定义了 Object.prototype 原型对象上的属性； // node_modules/typescript/lib/lib.es5.d.ts interface Object { constructor: Function; toString(): string; toLocaleString(): string; valueOf(): Object; hasOwnProperty(v: PropertyKey): boolean; isPrototypeOf(v: Object): boolean; propertyIsEnumerable(v: PropertyKey): boolean; } ObjectConstructor 接口定义了 Object 类的属性。 // node_modules/typescript/lib/lib.es5.d.ts interface ObjectConstructor { /** Invocation via `new` */ new (value?: any): Object; /** Invocation via function calls */ (value?: any): any; readonly prototype: Object; getPrototypeOf(o: any): any; // ··· } Object 类的所有实例都继承了 Object 接口中的所有属性。 10. Any 类型 在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型）。 let value: any = 666; value = &quot;hello&quot;; value = false; value = {}; value = []; any类型为从JavaScript到TypeScript提供了平稳的过渡方式：你可以将任意类型赋值给any类型，同时也可以对 any 类型的值执行任何操作，而无需做任何形式的静态类型检查。 let value: any; value.foo.bar; //✅ value.trim(); // ✅ value(); // ✅ new value(); // ✅ value[0][1]; // ✅ 在许多场景下，这太宽松了。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。 11. Unknown 类型 就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。 let value: unknown = 666; value = &quot;hello&quot;; value = false; value = {}; value = []; 但是你不能将unknown类型赋值给一个已经确定的类型：即unknown 类型只能被赋值给 any 类型和 unknown 类型本身。 let value: unknown; let value1: unknown = value; // ✅ let value2: any = value; // ✅ let value3: boolean = value; // ❌ let value4: number = value; // ❌ let value5: string = value; // ❌ let value6: object = value; // ❌ let value7: any[] = value; // ❌ let value8: Function = value; // ❌ 同时unknown也无法像any那样执行任意操作： let value: unknown; value.foo.bar; // ❌ value.trim(); // ❌ value(); // ❌ new value(); // ❌ value[0][1]; // ❌ 总结：any类型和unknown类型的异同： 类型 any unknown 被赋值 可以被赋予任意值 可以被赋予任意值 赋值 可以赋值给任意变量 只能赋值给 any 和 unknown 类型变量 操作 可以进行任意操作 所有操作被禁止 12. Void 类型 某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void： function doSomething(): void { console.log(&quot;do something&quot;); } 需要注意的是，声明一个 void 类型的变量没有什么作用，因为在严格模式下，它的值只能为 undefined： let unusable: void = undefined; 13. Never 类型 never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。 // function 永远不会返回 function error(message: string): never { throw new Error(message); } 又如，基础类型的交叉类型返回的也是never，应为他们之间永远不存在交集： let value = &quot;1&quot; &amp; 1; // never 在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下： type Foo = string | number; function controlFlowAnalysisWithNever(foo: Foo) { if (typeof foo === &quot;string&quot;) { // 这里 foo 被收窄为 string 类型 } else if (typeof foo === &quot;number&quot;) { // 这里 foo 被收窄为 number 类型 } else { // foo 在这里是 never const check: never = foo; } } 注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型： type Foo = string | number | boolean; 然而他忘记同时修改 controlFlowAnalysisWithNever 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保 controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。 参考文章 TypeScript 中文手册 一份不可多得的 TS 学习指南 ","link":"https://wuwenbang.github.io/post/typescript-ji-chu-lei-xing/"}]}