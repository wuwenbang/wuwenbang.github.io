{"posts":[{"title":"TypeScript + React 实践总结","content":"本文根据日常的开发实践，参考优秀的文档、文章，总结出一些TypeScript在React开发中实用的技巧和经验。 由于日常开发中已全面拥抱函数式组件和 React Hooks，所以 class 类组件的写法这里不提及。 构建项目 markdown 构筑一个React with TypeScript项目最快的方式就是使用 Facebook 官方脚手架create-react-app提供的TypeScript模版。运行以下指令： $ create-react-app my-app --template typescript 生成后的项目文件会多有些许不同，主要新增了以下配置： .tsx：使用 TypeScript 的 JSX 文件扩展； tsconfig.json：默认的 TypeScript 的配置文件； react-app-env.d.ts：TypeScript 声明文件， 注释的内容会作为编译器指令使用。 函数式组件 普通声明 interface PropsType { value: string children: React.ReactNode // 显示声明 } const MyComponent = ({ title, children }: PropsType) =&gt; { return &lt;div title={title}&gt;{children}&lt;/div&gt; } 使用 React.FC 声明 PropsType作为React.FC的范型参数（推荐方式） interface PropsType { title: string } const MyComponent: React.FC&lt;PropsType&gt; = ({ title, children }) =&gt; { return &lt;div title={title}&gt;{children}&lt;/div&gt; } 使用 React.FC 声明函数组件与 普通声明 的区别是： React.FC 是隐式声明 children（目前存在一些issue） ，而 普通声明 则是显示的声明 children 。 React.FC 显式地定义了返回类型，普通声明则是隐式推导的。 React.FC 对静态属性：displayName、propTypes、defaultProps提供了类型检查和自动补全。 Props 常用的基础 Props 类型 interface PropsType = { // 基本类型 message: string; count: number; disabled: boolean; // 数组 names: string[]; // 联合类型 status: 'waiting' | 'success'; // 对象 obj: { id: string; title: string; }; // 对象数组 objArr: { id: string; title: string; }[]; // Map类型 map1: { [key: number]: string; }; // Map类型的另一种实现方式 map2: Record&lt;number, string&gt;; // 没有参数&amp;返回值的函数 onClick: () =&gt; void; // 携带参数的函数 onChange: (id: number) =&gt; void; // 携带点击事件的函数 onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void; // 可选的属性 optional?: OptionalType; }; 常用的 React Props 类型 export declare interface AppBetterProps { children: React.ReactNode // 一般情况下推荐使用，支持所有类型 functionChildren: (name: string) =&gt; React.ReactNode // 函数组件 style?: React.CSSProperties // 传递style对象 onChange?: React.FormEventHandler&lt;HTMLInputElement&gt; //表单事件, 泛型参数是event.target的类型 } 设置 Props 的默认值 传递Props时，设置默认值（推荐方式） interface PropsType { text: string } // 传递 props 时，设置默认值 const MyComponent: React.FC&lt;PropsType&gt; = ({ text = 'default' }) =&gt; { return &lt;div&gt;{text}&lt;/div&gt; } 通过defaultProps设置默认值 interface PropsType { text: string } const MyComponent: React.FC&lt;PropsType&gt; = ({ text }) =&gt; { return &lt;div&gt;{text}&lt;/div&gt; } // 通过 defaultProps 设置默认值 MyComponent.defaultProps = { text: 'default', } React Hooks useState 给定初始值的情况下，TypeScript 会做类型推断 const [state, setState] = useState(false) // state 会被自动推断为 boolean 类型 没有初始值或初始值为null时，可以使用联合类型 interface DataType { message: string } const [data, setData] = &lt;DataType | null&gt;useState(null) // or const [data, setData] = &lt;DataType | undefined&gt;useState() useEffect 首先看一下 useEffect 接收第一个参数的类型定义 // 1. 是一个函数 // 2. 无参数 // 3. 无返回值 或 返回一个清理函数，该函数类型无参数、无返回值 。 type EffectCallback = () =&gt; void | (() =&gt; void | undefined) 根据定义，useEffect的使用方式为 useEffect(() =&gt; { // when deps update // 可选 return () =&gt; { // when component unmount } }, [deps]) // ✅ 确保函数返回 void 或 一个返回 void|undefined 的清理函数 同理，用 async await 语法处理异步请求，类似传入一个 () =&gt; Promise&lt;void&gt; 函数，与 EffectCallback 类型不匹配。 // ❌ error useEffect(async () =&gt; { const { data } = await ajax(params) // todo }, [params]) 异步请求的处理方式： // ✅ 立即执行函数 useEffect(() =&gt; { ;(async () =&gt; { const { data } = await ajax(params) // todo })() }, [params]) // ✅ 或者 then 也是可以的 useEffect(() =&gt; { ajax(params).then(({ data }) =&gt; { // todo }) }, [params]) useRef useRef 一般用于两种场景 引用 DOM 元素； 不想作为其他 hooks 的依赖项，因为 ref 的值引用是不会变的，变的只是 ref.current。 useRef 传递非空初始值的时候可以推断类型， 也可以通过传入第一个泛型参数来定义类型，约束 ref.current 的类型。 // 引用DOM const domRef = React.useRef&lt;HTMLDivElement | null&gt;(null) // 非依赖项值 const countRef = React.useRef&lt;number&gt;(0) useReducer 使用 useReducer 时，多多利用 联合类型 来精确辨识、收窄确定的 type 的 payload 类型。 一般也需要定义 reducer 的返回类型，不然 TS 会自动推导。 // 使用联合类型约束 Action 的 type 和 payload type ACTIONTYPE = { type: 'increment'; payload: number } | { type: 'decrement'; payload: string } | { type: 'initial' } // reducer function reducer(state: typeof initialState, action: ACTIONTYPE) { switch (action.type) { case 'increment': return { count: state.count + action.payload } case 'decrement': return { count: state.count - Number(action.payload) } case 'initial': return { count: initialState.count } default: throw new Error() } } function Counter() { const [state, dispatch] = useReducer(reducer, initialState) return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({ type: 'decrement', payload: '5' })}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: 'increment', payload: 5 })}&gt;+&lt;/button&gt; &lt;/&gt; ) } useContext 通过React.createContext&lt;Type&gt;()的范型函数定义共享状态的类型。 下例是 useContext 和 useReducer 结合使用，来管理全局的数据流。 interface AppContextInterface { state: typeof initialState dispatch: React.Dispatch&lt;ACTIONTYPE&gt; } // 通过范型定义 Context 的类型 const AppCtx = React.createContext&lt;AppContextInterface&gt;({ state: initialState, dispatch: (action) =&gt; action, }) const App = (): React.ReactNode =&gt; { const [state, dispatch] = useReducer(reducer, initialState) return ( &lt;AppCtx.Provider value={{ state, dispatch }}&gt; &lt;Counter /&gt; &lt;/AppCtx.Provider&gt; ) } // 消费 context function Counter() { const { state, dispatch } = React.useContext(AppCtx) return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({ type: 'decrement', payload: '5' })}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: 'increment', payload: 5 })}&gt;+&lt;/button&gt; &lt;/&gt; ) } 事件处理 事件对象类型 在事件处理函数中，我们经常性的需要使用 event 对象，比如获取Input事件的e.target.value，鼠标事件的clientX、clientY。 在刚接触TypeScript开发时，我都是直接把 event 设置为 any 类型，但是这样就失去了TypeScript对代码进行静态检查的意义。 const onChange = (e: any) =&gt; { console.log(e.target.value) } 幸运的是 React 的声明文件提供了 Event 对象的类型声明，拿最常见的情况之一：Input的onChange事件举例： import React from 'react' const MyInput: React.FC = () =&gt; { const [value, setValue] = React.useState('') // e 的类型是 ChangeEvent // e.target 的类型是 HTMLInputElement const onChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; { setValue(e.target.value) } return &lt;input value={value} onChange={onChange} id=&quot;input-example&quot; /&gt; } export default MyInput 常用 Event 事件对象类型 ClipboardEvent&lt;T = Element&gt; 剪贴板事件对象 DragEvent&lt;T = Element&gt; 拖拽事件对象 ChangeEvent&lt;T = Element&gt; Change 事件对象 KeyboardEvent&lt;T = Element&gt; 键盘事件对象 MouseEvent&lt;T = Element&gt; 鼠标事件对象 TouchEvent&lt;T = Element&gt; 触摸事件对象 WheelEvent&lt;T = Element&gt; 滚轮事件对象 AnimationEvent&lt;T = Element&gt; 动画事件对象 TransitionEvent&lt;T = Element&gt; 过渡事件对象 事件处理函数类型 当我们定义事件处理函数时有没有更方便定义其函数类型的方式呢？答案是使用 React 声明文件所提供的 EventHandler 类型别名，通过不同事件的 EventHandler 的类型别名来定义事件处理函数的类型。 EventHandler 类型实现源码 node_modules/@types/react/index.d.ts 。 type EventHandler&lt;E extends SyntheticEvent&lt;any&gt;&gt; = { bivarianceHack(event: E): void }['bivarianceHack'] type ReactEventHandler&lt;T = Element&gt; = EventHandler&lt;SyntheticEvent&lt;T&gt;&gt; type ClipboardEventHandler&lt;T = Element&gt; = EventHandler&lt;ClipboardEvent&lt;T&gt;&gt; type DragEventHandler&lt;T = Element&gt; = EventHandler&lt;DragEvent&lt;T&gt;&gt; type FocusEventHandler&lt;T = Element&gt; = EventHandler&lt;FocusEvent&lt;T&gt;&gt; type FormEventHandler&lt;T = Element&gt; = EventHandler&lt;FormEvent&lt;T&gt;&gt; type ChangeEventHandler&lt;T = Element&gt; = EventHandler&lt;ChangeEvent&lt;T&gt;&gt; type KeyboardEventHandler&lt;T = Element&gt; = EventHandler&lt;KeyboardEvent&lt;T&gt;&gt; type MouseEventHandler&lt;T = Element&gt; = EventHandler&lt;MouseEvent&lt;T&gt;&gt; type TouchEventHandler&lt;T = Element&gt; = EventHandler&lt;TouchEvent&lt;T&gt;&gt; type PointerEventHandler&lt;T = Element&gt; = EventHandler&lt;PointerEvent&lt;T&gt;&gt; type UIEventHandler&lt;T = Element&gt; = EventHandler&lt;UIEvent&lt;T&gt;&gt; type WheelEventHandler&lt;T = Element&gt; = EventHandler&lt;WheelEvent&lt;T&gt;&gt; type AnimationEventHandler&lt;T = Element&gt; = EventHandler&lt;AnimationEvent&lt;T&gt;&gt; type TransitionEventHandler&lt;T = Element&gt; = EventHandler&lt;TransitionEvent&lt;T&gt;&gt; 实例： interface PropsType { onClick: MouseEventHandler&lt;HTMLDivElement&gt; onChange: ChangeEventHandler&lt;HTMLInputElement&gt; } 参考资料 TypeScript 中文手册 React React with TypeScript 最佳实践 ","link":"https://wuwenbang.github.io/post/typescript-react-shi-jian-zong-jie/"},{"title":"TypeScript 从集合论的角度理解类型系统","content":"0. 前言 在学习和使用 TypeScript 的过程中，有一些问题一直困惑着我： 比如说联合类型与交叉类型在基础类型和对象类型上的不同表现： 对于基础类型来说，联合类型是类型的并集，交叉类型是类型的交集。 // 联合类型 type Union = string | number // Union = string | number // 交叉类型 type Intersection = string &amp; number // Intersection = never 对于对象类型来说，联合类型是属性的交集（勘误：只有在被赋值的对象拥有全部属性的情况下，才表现为属性的交集），交叉类型是属性的并集。 interface A { x: number y: number } interface B { y: number z: number } // 联合类型 type Union = A | B /* Union = { y: number } */ // 交叉类型 type Intersection = A &amp; B /* Intersection = { x: number y: number z: number } */ 再比如说条件类型的 extends 关键字到底是什么意思——可继承？可扩展？还是可赋值？ // extends =&gt; 可赋值 ？ type T1 = string extends string | number ? true : false // T1 = true // extends =&gt; 可继承 ？ interface ObjectA { x: string y: string } interface ObjectB { x: string } type T2 = ObjectA extends ObjectB ? true : false // T2 = true 上述的例子确实令人困惑，或许我们应该换个角度去思考：尝试用集合论的角度去思考 TypeScript 的类型系统。 1. 类型与集合 在 JavaScript 里，类型是满足某些特征的值的集合。例如： number 类型是是所有数字的集合。 string 类型是所有字符串的集合。 bolean 类型是 true 和 false 的集合。 undefined 类型是 undefined 的集合。 总结一下就是：类型 对应集合论里的 集合，值 对应集合论里的 元素。 而在 TypeScript 里，我们可以给变量声明类型，并将对应类型的值赋予它。 let str: string = 'xxx' str = 'yyy' let num: number = 123 num = 456 而对于对象的类型，也就是类（Class），集合的概念就非常容易混淆，我们来看下面一个例子： interface A { x: number } interface B { x: number y: number } const b: B = { x: 1, y: 2, } const a: A = b // ok 示例中，对象 b 的类型是 { x: number, y: number }，但是它却可以赋值给类型为 { x: number } 的变量 a。这看似不合理的现象，通过集合论的观点便可以解释： 我们把类 A 即 { x: number } 看成所有拥有属性 x: number 的对象的集合，也就是说只要拥有属性 x: number 的对象都可以看成集合 A 的一个元素（或者类 A 的实例）。 那么因为 b = { x:1, y:2 } 拥有属性 x: number =&gt; 所以对象 b 是类 A 的一个实例 =&gt; 所以 b 可以赋值给类型为 A 的变量 a。 关于对象，我们必须清晰地知道：对象类型（类）是若干对象的集合，而不是属性的集合。只要一个对象具有类所描述的全部属性，那么该对象就是该类的元素（实例）。 2. 交叉类型与联合类型 交叉类型（Intersection Types） 对应集合论的 交集（Intersection） 联合类型（Union Types） 对应集合论的 并集（Union） （PS：从英文原文翻译的角度来看，我认为将 交叉类型与联合类型 翻译成 交集类型和并集类型 可能更加贴切。） 2.1 交叉类型与联合类型的简单运算 关于交叉类型 &amp; 和联合类型 | 的运算，我们来看一个简单的例子： type A = 1 | 2 type B = 2 | 3 // A B 交集 type C = A &amp; B // C = 2 // A B 并集 type D = A | B // D = 1 | 2 | 3 // A number 交集 type E = A &amp; number // E = A = 1 | 2 // A number 并集 type F = A | number // F = number // 空集 never type G = number &amp; string // G = never // 全集 unknown type H = number | unknown // H = unknown A - F 符合集合论交集并集的运算规律 G never 意为不会出现的类型，其符合空集的计算规律，遂可以理解为空集。 H unkonwn 意为未知的类型，其符合全集的计算规律，遂可以理解为全集。 集合论中交集与并集的运算特性，交叉类型和联合类型也满足： 对于交集运算符 &amp;： 唯一性: A &amp; A 等价于 A. 满足交换律: A &amp; B 等价于 B &amp; A . 满足结合律: (A &amp; B) &amp; C 等价于 A &amp; (B &amp; C). 父类型收敛: 当且仅当 B 是 A 的父类型时，A &amp; B 等价于 A. 对于并集运算符 |： 唯一性: A | A 等价于 A. 满足交换律: A | B 等价于 B | A. 满足结合律: (A | B) | C 等价于 A | (B | C). 子类型收敛: 当且仅当 B 是 A 的子类型时，A | B 等价于 A. 2.2 交叉类型与联合类型高级运算 对于对象类型的交叉类型和联合类型，同样符合集合论的规律： 交叉类型高级运算 interface A { x: number y: number } interface B { y: number z: number } // 交叉类型 type Intersection = B &amp; A const obj1: Intersection = { x: 1, y: 2, z: 3, } obj1.x // ok obj1.y // ok obj1.z // ok 交叉类型 Intersection 是对象 A 和 B 的交集，是对象集合的交集，表现为拥有 A 和 B 的全部属性，是属性集合的并集。。 赋值上：只有具有 A 和 B 所有的属性的对象才能赋值给 Intersection。 访问上：交叉类型 Intersection 可以访问 A 和 B 的所有属性。 联合类型高级运算 interface A { x: number y: number } interface B { y: number z: number } // 联合类型 type Union = B | A const obj1: Union = { x: 1, y: 2, z: 3, } const obj2: Union = { x: 1, y: 2, } const obj3: Union = { y: 2, z: 3, } obj1.x // error obj1.y // ok obj1.z // error 联合类型 Union 是对象 A 和 B 的并集，即对象集合的并集。 赋值上：具有 A或B或A &amp; B 的属性的对象能赋值给 Union。 访问上：为了类型安全，当赋值为 A 或 B 时，联合类型 Union 只能访问 A 或 B ；当赋值为 A &amp; B 时（即全部属性），联合类型 Union 只能访问 A 和 B 的共有属性。 3 extends 关键字 根据集合论，A extends B 的语意是： A 为 B 的子集。 3.1 extends 用作泛型约束 表达式：T extends U 作用：泛型约束用作限制泛型的类型，即泛型T必须是类型U的子集，才能通过编译。 function needNumber&lt;T extends number&gt;(value: T): number { return value + 1 } // 满足 number 类型的子集 needNumber(1) //ok // 不是 number 类型的子集 needNumber('1') //error 对象类型同理： interface Point { x: number y: number } function Sum&lt;T extends Point&gt;(value: T): number { return value.x + value.y } // 满足 Point 类型的子集 Sum({ x: 1, y: 2 }) // ok Sum({ x: 1, y: 2, z: 3 }) // ok // 不是 Point 类型的子集 Sum({ x: 1 }) // error 3.2 extends 用作条件泛型 表达式：T extends U ? X : Y 作用：条件类型是一个三元运算表达式，如果 T 是 U 的子集，则表达式的值为 X，否则为 U。 type IsNumber&lt;T&gt; = T extends number ? true : false type Result1 = IsNumber&lt;1&gt; // true type Result2 = IsNumber&lt;'1'&gt; // false 对象类型同理： interface Point { x: number y: number } type IsPointSubset&lt;T&gt; = T extends Point ? true : false type Result1 = IsPointSubset&lt;{ x: number; y: number }&gt; // true type Result2 = IsPointSubset&lt;{ x: number; z: number }&gt; // false 4. 参考资料 TypeScript 中文手册 Typescript 进击的基础（一）交叉类型和联合类型-集合论角度理解 ","link":"https://wuwenbang.github.io/post/typescript-cong-ji-he-lun-de-jiao-du-li-jie-lei-xing-xi-tong/"},{"title":"TypeScript 工具类型","content":"前言 Typescript 中默认内置了很多工具泛型，通过使用这些工具，可以使得我们定义类型更加灵活，高效。本文将会介绍常用泛型工具的使用技巧，以及对其实现原理进行相应的解析，如果有错误的地方，还望指出。 Partial&lt;T&gt; 作用：将传入对象类型 T 的属性变为可选属性。 示例： interface Person { name: string; age: number; } const tom: Partial&lt;Person&gt; = { name: &quot;Tom&quot;, }; Partial&lt;Person&gt; 等价于 interface Person { name?: string; age?: number; } 实现原理： 通过关键字 keyof 将传入对象类型的键值转换为联合类型。 通过关键字 in 遍历联合类型，即遍历对象的键值。 通过类型映射，将对象的属性转换为可选属性 type MyPartial&lt;T&gt; = { [P in keyof T]?: T[P]; }; Readonly&lt;T&gt; 作用：把传入对象类型 T 属性变为只读属性。 示例： interface Person { name: string; age: number; } const tom: Readonly&lt;Person&gt; = { name: &quot;Tom&quot;, age: 18; }; tom.age = 22 // error Readonly&lt;Person&gt; 等价于 interface Person { readonly name: string; readonly age: number; } 实现原理： 与Partial类似： 通过关键字 keyof 将传入对象类型的键值转换为联合类型。 通过关键字 in 遍历联合类型，即遍历对象的键值。 通过类型映射，将对象的属性转换为只读属性 type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P]; }; Required&lt;T&gt; 作用：把传入对象类型 T 属性变为必填属性。 示例： interface Person { name?: string; age?: number; } let tom: Required&lt;Person&gt; tom = { name: &quot;Tom&quot;, age: 18; }; // ok tom = { name: &quot;Tom&quot;, }; // error 实现原理： 与Partial类似： 通过关键字 keyof 将传入对象的键值转换为枚举类型。 通过关键字 in 遍历枚举类型，即遍历对象的键值。 通过类型映射，再统一通过 - 修饰符移除 ? 修饰符，从而转变为必填状态。 type Required&lt;T&gt; = { Required [P in keyof T]: T[P]; }; Record&lt;K,T&gt; 作用：它用来生成一个属性名为 K，属性值类型为 T 的对象类型集合。 示例： // 快速生成一个 Person 对象 type Person = Record&lt;&quot;name&quot; | &quot;country&quot;, string&gt;; const Tom: Person = { name: &quot;Tom&quot;, country: &quot;America&quot; }; 实现原理: 通过 K extends keyof any 对 K 参数进行约束，将其约束为任意类型 any 的键值。 通过 in 对键值集合 K 进行遍历，然后生成类型为 T 的键值对集合。 type MyRecord&lt;K extends keyof any, T&gt; = { [P in K]: T; }; Exclude&lt;T,K&gt; 作用：从类型 T 中排除所有可以赋值给类型 U 的类型。 示例： // 从 &quot;a&quot; | &quot;b&quot; | &quot;c&quot; 中排除掉 &quot;a&quot; 类型 type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // T1 = &quot;b&quot; | &quot;c&quot; // 从 string | number | boolean 中排除掉 string 类型 type T2 = Exclude&lt;string | number | boolean, string&gt;; // T2 = number | boolean 实现原理： 通过条件类型T extends U ? never : T 对 T 参数进行判别： 如果 T 可赋值给 U ，那么返回 never（即排除掉T）。 如果 T 不可赋值给 U ，那么返回 T。 通过分布式条件类型，如果 T 为联合类型，则将条件类型的结果分发为联合类型。 type Exclude&lt;T, U&gt; = T extends U ? never : T; Extract&lt;T,K&gt; 作用：与 Exclude 相反，从类型 T 中提取所有可以赋值给类型 U 的类型。 示例： // 从 &quot;a&quot; | &quot;b&quot; | &quot;c&quot; 中提取出 &quot;a&quot; 类型 type T1 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // T1 = &quot;a&quot; // 从 string | number | boolean 中提取出 string 类型 type T2 = Extract&lt;string | number | boolean, string&gt;; // T2 = string type T3 = Extract&lt;string | (() =&gt; void), Function&gt;; // 相当于 type T3 = () =&gt; void; 实现原理： 与 Exclude 类似： 通过条件类型T extends U ? never : T 对 T 参数进行判别： 如果 T 可赋值给 U ，那么返回 T。 如果 T 不可赋值给 U ，那么返回 never（即排除掉T）。 通过分布式条件类型，如果 T 为联合类型，则将条件类型的结果分发为联合类型。 type Extract&lt;T, U&gt; = T extends U ? T : never; Pick&lt;T,K&gt; 作用：在 T 中，摘选出 K 属性。 示例： interface Person { name: string; age: number; } // 从 Person 中摘选出 name 属性 type PickPerson = Pick&lt;Person, &quot;name&quot;&gt;; const tom: PickPerson = { name: &quot;Tom&quot;, }; 实现原理： 通过 K extends keyof T 对 K 参数进行约束，将其约束为 T 的键值范围内。 通过 in 对键值集合 K 进行遍历，然后生成类型为 T 的键值对集合。 type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P]; }; Omit&lt;T,K&gt; 作用：在 T 中，剔除掉 K 属性。 示例： interface Person { name: string; age: number; } // 从 Person 中剔除掉 name 属性 type OmitPerson = Pick&lt;Person, &quot;name&quot;&gt;; const tom: PickPerson = { age: 18, }; 实现原理： 通过 K extends keyof T 对 K 参数进行约束，将其约束为 T 的键值范围内。 通过 Exclude&lt;keyof T, K&gt; 将类型集合 T 中的 K 类型排除掉。 通过 Pick&lt;T,Exclude&lt;keyof T, K&gt;&gt; 在 T 中摘选出排除掉 K 的 T 的属性。 type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; ReturnType&lt;T&gt; 作用：获取函数的返回值类型。 示例： type Fun = () =&gt; string; // 获取 Fun 返回值的类型 type T1 = ReturnType&lt;Fun&gt;; // T1 = string type T2 = ReturnType&lt;() =&gt; { x: number; y: number }&gt;; // T2 = { x: number, y: number } 实现原理： 通过 extends 对 T 参数进行约束，(...args: any) =&gt; any 表示一个函数类型，即 T 参数的类型必须是一个函数类型。 T extends U ? X : Y 是条件类型（注意和之前表示约束的 extends 做区分），其中 T 是泛型参数，U 是条件部分，X 是符合条件的返回结果，Y 是不符合条件的返回结果。 推断类型 infer 的作用是：在条件类型内部声明一个类型变量。(...args: any) =&gt; infer R 是条件类型的条件部分，它声明了一个类型变量 R ，用来存储函数的返回类型。 T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any表示： 如果 T 是函数类型（(...args: any) =&gt; infer R），则返回 R , 即函数的返回类型。 如果 T 不是函数类型（(...args: any) =&gt; infer R），则返回 any。 type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends ( ...args: any ) =&gt; infer R ? R : any; 参考资料 TypeScript 中文手册 TypeScript 内置工具泛型 ","link":"https://wuwenbang.github.io/post/typescript-gong-ju-lei-xing/"},{"title":"TypeScript 泛型总结","content":"1. 泛型是什么？ 官方的定义是： **泛型（Generics）**是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 通俗的解释是：泛型是类型系统中的参数，就像函数的参数一样，只不过函数的参数传递的是值，而泛型传递的是类型。他只出现在现在函数，接口，和类中，主要作用是为了类型的复用。 设计泛型的关键目的：是在成员之间提供有意义的约束，这些成员可以是：函数参数、函数返回值、类的实例成员和类的方法。 可能这么讲会有一些抽象，接下来我们以泛型函数为例，举一个简单的例子： 首先我们来定义一个通用的 identity 函数，该函数接收一个number类型的参数，并直接返回这个值： function identity(value: number): number { return value; } identity(1); // ok identity(&quot;hello&quot;); // error // 编译器报错： Argument of type 'string' is not assignable to parameter of type 'number'.ts(2345) 现在，identity 函数能且只能传入 number 类型的参数，如果我想传入 string 类型的 TypeScript 编译器会报错，那么该怎么办呢？或许你会想到 any 类型。 function identity(value: any) { return value; } identity(1); // ok identity(&quot;hello&quot;); // ok 好吧，传入 any 确实可以生效，但我们失去了定义应该返回哪种类型的能力，并且在这个过程中也丧失了 TypeScript 的类型保护作用。 我们的目标是让 identity 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用 泛型函数 来解决这个问题： 2. 泛型函数 定义泛型函数： function identity&lt;T&gt;(value: T): T { return value; } identity&lt;number&gt;(1); // ok identity&lt;string&gt;(&quot;hello&quot;); // ok 对于刚接触 TypeScript 泛型的读者来说，首次看到 &lt;T&gt; 语法会感到陌生。但这没什么可担心的，就像传递参数一样，通过参数变量 T，把用户想要传入的类型，链式传递到后面函数的类型定义中去。 （图片来源：掘金阿宝哥） 参考上面的图片，通过 &lt;T&gt; 声明 类型变量 T，然后在后面的函数参数类型声明、和函数返回值类型声明中使用：(value: T): T。 理论上，&lt; &gt;类可以声明任意字符作为类型变量，但在定义泛型时通常用T作为类型变量名称，其中 T 代表 Type。当然，除了 T 之外，以下是常见泛型变量代表的意思： K（Key）：表示对象中的键类型。 V（Value）：表示对象中的值类型。 E（Element）：表示元素类型。 U（T 后面的字符）：表示第二个类型参数（以此类推）。 很多时候并不是只能定义一个类型变量，我们可以引入更多的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数： function identity&lt;T, U&gt;(value: T, message: U): T { console.log(message); return value; } console.log(identity&lt;Number, string&gt;(100, &quot;Hello Generics&quot;)); // Hello Generics // 100 （图片来源：掘金阿宝哥） 除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如： function identity&lt;T, U&gt;(value: T, message: U): T { console.log(message); return value; } console.log(identity(100, &quot;Hello Generics&quot;)); // Hello Generics // 100 3. 泛型接口 定义泛型接口： interface GenericInterface&lt;T&gt; { data: T; } 接口泛型的使用方式和函数类似，我们可以通过&lt;T&gt;来声明参数变量T，并将其用在后面接口属性的类型定义上。 泛型接口常用于定义那些，需要用户自定义类型的对象上，最常见的就是 网络请求的响应对象了，以Axios为例： 假设我们通过 axios.get 发起网络请求，我们可以通过axios.get&lt;DataType&gt;传入data的类型，最后拿响应 res 时，我们就可以明确的知道data的数据类型 ： interface DataType { id: number; message: string; } axios.get&lt;DataType&gt;(&quot;https://www.xxx.com&quot;).then((res) =&gt; { console.log(res.data.message); }); 其中axios实例，以及响应res的泛型接口如下定义： interface AxiosInstance { // ... get&lt;T = any, R = AxiosResponse&lt;T&gt;&gt;( url: string, config?: AxiosRequestConfig ): Promise&lt;R&gt;; } interface AxiosResponse&lt;T = any&gt; { data: T; status: number; statusText: string; headers: any; config: AxiosRequestConfig; request?: any; } 其中响应的 data 是 axios 不知道的，所以 axios 通过泛型的方式，将类型T传递给后面的data属性。 4. 泛型类 在类中使用泛型也很简单，我们只需要在类名后面，使用 &lt;T, ...&gt; 的语法定义任意多个类型变量。 定义泛型类： interface GenericInterface&lt;U&gt; { value: U; getValue: () =&gt; U; } class GenericClass&lt;T&gt; implements GenericInterface&lt;T&gt; { value: T; constructor(value: T) { this.value = value; } getValue(): T { return this.value; } } const myNumberClass = new GenericClass&lt;number&gt;(10); console.log(myNumberClass.getValue()); // 10 const myStringClass = new GenericClass&lt;string&gt;(&quot;Hello Generics!&quot;); console.log(myStringClass.getValue()); // Hello Generics! 接下来我们以实例化 myNumberClass 为例，来分析一下其调用过程： 在实例化 GenericClass 对象时，我们传入 number 类型和构造函数参数值 68； 之后在 GenericClass 类中，类型变量 T 的值变成 number 类型； GenericClass 类实现了 GenericInterface&lt;T&gt;，而此时 T 表示 number 类型，因此等价于该类实现了 GenericInterface&lt;number&gt; 接口； 而对于 GenericInterface&lt;U&gt; 接口来说，类型变量 U 也变成了 number。这里我有意使用不同的变量名，以表明类型值沿链向上传播，且与变量名无关。 5. 泛型约束 有时候我们希望限制泛型变量接受的类型（比如我只希望接受拥有.length属性的类型），我们就需要泛型约束。下面我们来举几个例子，介绍一下如何使用泛型约束。 5.1 确保属性存在 有时候，我们希望类型变量对应的类型上存在某些属性。这时，除非我们显式地将特定属性定义为类型变量，否则编译器不会知道它们的存在。 一个很好的例子是在处理字符串或数组时，我们会假设 length 属性是可用的。让我们再次使用 identity 函数并尝试输出参数的长度： function identity&lt;T&gt;(arg: T): T { console.log(arg.length); // error: T doesn't have .length return arg; } 在这种情况下，编译器将不会知道 T 确实含有 length 属性，尤其是在可以将任何类型赋给类型变量 T 的情况下。我们需要做的就是让类型变量 extends 一个含有我们所需属性的接口，比如这样： interface Length { length: number; } function identity&lt;T extends Length&gt;(arg: T): T { console.log(arg.length); // ok: 可以获取length属性 return arg; } T extends Length 用于告诉编译器，我们支持已经实现 Length 接口的任何类型。 之后，当我们使用不含有 length 属性的对象作为参数调用 identity 函数时，TypeScript 会提示相关的错误信息： identity(10); // Error // Argument of type '68' is not assignable to parameter of type 'Length'.(2345) 5.2 检查对象上的键是否存在 泛型约束的另一个常见的使用场景就是检查对象上的键是否存在。不过在看具体示例之前，我们得来了解一下 keyof 操作符，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。我们来举个 keyof 的使用示例： interface Person { name: string; age: number; location: string; } type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot; | &quot;location&quot; type K2 = keyof Person[]; // number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ... 通过 keyof 操作符，我们就可以获取指定类型的所有键，之后我们就可以结合前面介绍的 extends 约束，即限制输入的属性名包含在 keyof 返回的联合类型中。具体的使用方式如下： function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] { return obj[key]; } const obj = { name: &quot;tom&quot;, }; getProperty(obj, &quot;name&quot;); // ok getProperty(obj, &quot;age&quot;); // error 属性名 age 不存在 obj 上 在以上的 getProperty 函数中，我们通过K extends keyof T 确保参数 key 一定是对象中含有的键，这样就不会发生运行时错误。这是一个类型安全的解决方案，与简单调用 let value = obj[key]; 不同。 在以上示例中，对于 getProperty(obj, &quot;age&quot;) 这个表达式，TypeScript 编译器会提示以下错误信息： // 编译器报错：Argument of type '&quot;age&quot;' is not assignable to parameter of type '&quot;name&quot;'.ts(2345) 很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。 6. 泛型参数默认类型 我们都知道 JavaScript 的函数参数可以设置初始值（defalut value），类似地，我们也可以为泛型参数设置默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。 泛型参数默认类型与普通函数默认值类似，对应的语法很简单，即 &lt;T=Default Type&gt;，对应的使用示例如下： interface MyObject&lt;T = string&gt; { id: T; } const numObject: MyObject = { id: &quot;abc&quot; }; const strObject: MyObject&lt;number&gt; = { id: 123 }; 泛型参数的默认类型遵循以下规则： 有默认类型的类型参数被认为是可选的。 必选的类型参数不能在可选的类型参数后。 如果类型参数有约束，类型参数的默认类型必须满足这个约束。 当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。 如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。 一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。 一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。 7. 泛型条件类型 通过泛型条件类型，我们可以根据某些条件得到不同的类型，这里所说的条件是类型兼容性约束。尽管以上代码中使用了 extends 关键字，也不一定要强制满足继承关系，而是检查是否满足结构兼容性。 条件类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一： T extends U ? X : Y 以上表达式的意思是：若 T 能够赋值给 U（T 属于与 U的子类），那么类型是 X，否则为 Y。在条件类型表达式中，我们通常还会结合 infer 关键字，实现类型抽取： interface MyObject&lt;T = any&gt; { key: T; } type StrObject = MyObject&lt;string&gt;; type NumObject = MyObject&lt;number&gt;; type ObjectMember&lt;T&gt; = T extends MyObject&lt;infer V&gt; ? V : never; type StrObjectMember = ObjectMember&lt;StrObject&gt;; // string type NumObjectMember = ObjectMember&lt;NumObject&gt;; // number 在上面示例中，当类型 T 满足 T extends MyObject 约束时，我们会使用 infer 关键字声明了一个类型变量 V，并返回该类型，否则返回 never 类型。 8. 参考文章 TypeScript 中文手册 一份不可多得的 TS 学习指南 ","link":"https://wuwenbang.github.io/post/typescript-fan-xing-zong-jie/"},{"title":"TypeScript 断言总结","content":"1. 类型断言 在使用 TypeScript 的过程中，你可能会遇到这种情况：你比 TypeScript 更加清楚某个值的类型。 比如你从异步请求中拿到一个类型为any的值，但你清楚的知道这个值就是string类型，这个时候你可以通过类型断言方式告诉编译器：&quot;嘿！相信我，我知道我在干什么！&quot;。类型断言有点类似于其他语言的类型转换，但它没有运行时的影响，只是在编译阶段起作用。 类型断言有两种形式： 1.1 尖括号语法 形式：&lt;类型&gt;变量名 let value: any = &quot;this is a string&quot;; let length: number = (&lt;string&gt;value).length; 1.2 as 语法 形式：变量名 as 类型 let value: any = &quot;this is a string&quot;; let length: number = (value as string).length; 2. 非空断言 当你明确知道某个值不可能为 undefined 和 null 时，你可以用 在变量后面加上一个 !（非空断言符号）来告诉编译器：&quot;嘿！相信我，我确信这个值不为空！&quot;。 非空断言具体的使用场景如下： function fun(value: string | undefined | null) { const str: string = value; // error value 可能为 undefined 和 null const str: string = value!; //ok const length: number = value.length; // error value 可能为 undefined 和 null const length: number = value!.length; //ok } 3. 确定赋值断言 TypeScript 的确定赋值断言，允许在实例属性和变量声明后面放置一个 ! 号，从而告诉 TypeScript 该属性会被明确地赋值。 let name!: string; 上述表达式就是对编译器说：&quot;有一个名为 name 的属性，其类型为 string | undefined。它以值 undefined 开始。但每次获取或设置该属性时，我都希望将其视为类型 string。&quot; 为了更好地理解它的作用，我们来看个具体的例子： let count: number; initialize(); // Variable 'count' is used before being assigned.(2454) console.log(2 * count); // Error function initialize() { count = 10; } 很明显该异常信息是说变量 count 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言： let count!: number; initialize(); console.log(2 * count); // Ok function initialize() { count = 10; } 4. 参考文章 TypeScript 中文手册 一份不可多得的 TS 学习指南 ","link":"https://wuwenbang.github.io/post/typescript-duan-yan-zong-jie/"},{"title":"TypeScript Type 和 Interface 的异同","content":"在使用TypeScript的时候，我们常常使用interface和type去描述复杂数据的形状和类型，比如对象和函数。由于他们的使用方式高度相似，一度让我觉得他们是可以相互替换的。但是随着更加深入的了解，我发现了他们之间的一些异同点，然我们一起来看看吧。 1. Inteface 接口 在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。 TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对对象的形状（Shape）进行描述。 1.1 接口的作用 描述对象 interface Person { name: string; age: number; run: () =&gt; void; } let tom: Person = { name: &quot;Tom&quot;, age: 23, }; 描述函数 interface Action { (): void; } const sayHi: Action = () =&gt; { console.log(&quot;Hi!&quot;); }; 1.2 可选属性与只读属性 interface Person { readonly name: string; // 只读属性：只可读取，不可更改 age?: number; // 可选属性：该对象可以拥有，也可以没有该属性 } let tom: Person = { name: &quot;Tom&quot;, }; tom.name = &quot;Jack&quot;; // error 不可更改 1.3 任意属性 有时候我们希望我们定义的对象可以拥有一个任意属性，这时我们可以使用索引签名的形式来满足上述要求。 interface Person { name: string; age?: number; [propName: string]: any; } const tom = { name: &quot;Tom&quot; }; const jack = { name: &quot;Jack&quot;, age: 5 }; const susan = { name: &quot;Susan&quot;, sex: &quot;famale&quot; }; 2. Type Alias 类型别名 2.1 类型别名的定义 type（Type Alias 类型别名）会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 // 基本类型 type Count = number; // 函数 type Fun = () =&gt; void; // 对象 type Person = { name: string; age: number; }; 3. Inteface 和 Type 的相同点 3.1 都可以用来描述对象或函数 // interface interface Point { x: number; y: number; } interface SetPoint { (x: number, y: number): void; } // type alias type Point = { x: number; y: number; }; type SetPoint = (x: number, y: number) =&gt; void; 3.2 都可以扩展 两者都可以用来扩展，但是扩展方式不同，接口的扩展就是继承，通过extends来实现。类型别名的扩展就是交叉类型，通过&amp;来实现。 // 接口扩展 interface PointX { x: number; } interface Point extends PointX { y: number; } // 类型别名扩展 type PointX = { x: number; }; type Point = PointX &amp; { y: number; }; PS：接口可以扩展类型别名，同理，类型别名也可以扩展接口。 4. Inteface 和 Type 的不同点 4.1 type 可以声明基本类型，而 interface 不行 type 可以声明基本类型 type Count = number; type Color = &quot;Red&quot; | &quot;Blue&quot;; interface 只能用来声明复杂类型（对象和函数） 4.2 扩展时表现不同 扩展接口时，TS 将检查扩展的接口是否可以赋值给被扩展的接口。 interface A { good(x: number): string; bad(x: number): string; } interface B extends A { good(x: string | number): string; bad(x: number): number; // Interface 'B' incorrectly extends interface 'A'. // Types of property 'bad' are incompatible. // Type '(x: number) =&gt; number' is not assignable to type '(x: number) =&gt; string'. // Type 'number' is not assignable to type 'string'. } 但使用交叉类型时则不会出现这种情况。我们将上述代码中的接口改写成类型别名，把 extends 换成交集运算符&amp;，TS 将尽其所能把扩展和被扩展的类型组合在一起，而不会抛出编译时错误。 type A = { good(x: number): string; bad(x: number): string; }; type B = A &amp; { good(x: string | number): string; bad(x: number): number; }; // ok 4.3 多次定义时表现不同 接口多次的声明会合并。类型别名不能重复声明。 接口可以定义多次，多次的声明会合并。 interface Point { x: number; } interface Point { y: number; } const point: Point = { x: 1 }; //error Property 'y' is missing in type '{ x: number; }' but required in type 'Point'. const point: Point = { x: 1, y: 1 }; // ok 但是类型别名如果定义多次，会报错。 type Point = { x: number; //error Duplicate identifier 'A'. }; type Point = { y: number; //error Duplicate identifier 'A'. }; 到底应该用哪个？ 如果接口和类型别名都能满足的情况下，到底应该用哪个是我们关心的问题。 感觉哪个都可以，但是强烈建议大家只要能用接口实现的就优先使用接口，接口满足不了的再用类型别名。 为什么会这么建议呢？其实在 TS 的 wiki 中有说明。具体的文章地址在这里：TS wiki 以下是Preferring Interfaces Over Intersections的译文： 大多数时候，对于声明一个对象，类型别名和接口表现的很相似。 interface Foo { prop: string; } type Bar = { prop: string }; 然而，当你需要通过组合两个或者两个以上的类型实现其他类型时，可以选择使用接口来扩展类型，也可以通过交叉类型（使用&amp;创造出来的类型）来完成，这就是二者开始有区别的时候了。 接口会创建一个单一扁平对象类型来检测属性冲突，当有属性冲突时会提示，而交叉类型只是递归的进行属性合并，在某种情况下可能产生 never 类型 接口通常表现的更好，而交叉类型做为其他交叉类型的一部分时，直观上表现不出来，还是会认为是不同基本类型的组合 接口之间的继承关系会缓存，而交叉类型会被看成组合起来的一个整体 在检查一个目标交叉类型时，在检查到目标类型之前会先检查每一个组分 参考文章 TypeScript 中文手冊 TypeScript Interface vs Type 知多少 ","link":"https://wuwenbang.github.io/post/typescript-type-he-interface-de-yi-tong/"},{"title":"TypeScript 基础类型","content":" Number 类型 let count: number = 10; // ES5：var count = 10; 2. String 类型 let name: string = &quot;hello world&quot;; // ES5：var name = 'hello world'; 3. Boolean 类型 let isCheck: boolean = false; // ES5：var isCheck = false; 4. Symbol 类型 const sym = Symbol(); let obj = { [sym]: &quot;hello world&quot;, }; console.log(obj[sym]); // hello world 5. Null 和 Undefined 类型 TypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。 let u: undefined = undefined; let n: null = null; 6. Array 类型 TypeScript 里，数组类型有两种表达形式： 直接表示：type[]。 用泛型的方式表示：Array&lt;type&gt;。 let array: number[] = [1, 2, 3]; // ES5：var array = [1,2,3]; let array: Array&lt;number&gt; = [1, 2, 3]; // Array&lt;number&gt;泛型语法 // ES5：var array = [1,2,3]; 7. Tuple（元组） 类型 数组（Array）合并了相同类型的值，而元组（Tuple）合并了不同类型的值 let array: number[] = [100, 200]; let tuple: [number, string] = [100, &quot;200&quot;]; 当赋值或访问一个已知索引的元素时，会得到正确的类型： let tuple: [string, number]; tuple[0] = &quot;Jack&quot;; tuple[1] = 22; tuple[0].substr(1); //String独有方法 tuple[1].toFixed(2); //Number独有方法 元组（Tuple）类型是固定长度，固定类型的 let tuple: [string, number]; tuple = [&quot;jack&quot;]; //❌ tuple = [100, &quot;juck&quot;]; //❌ tuple = [&quot;juck&quot;, 100]; //✅ React中的useState返回的就是元组类型： // 类型定义：返回元组类型 [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;] function useState&lt;S&gt;( initialState: S | (() =&gt; S) ): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;]; // 元组：解构赋值 const [state, setState] = useState(0); 总结：数组（Array）和元组（Tuple）的差异： Array类型统一，Tuple类型可以不一。 Array长度不限，Tuple长度限定。 8. Enum（枚举）类型 使用枚举我们可以定义一些带名字的常量，以表达限定在一定范围内值。 TypeScript 支持数字的和基于字符串的枚举。 1. 数字枚举 enum Direction { NORTH, SOUTH, EAST, WEST, } let dir: Direction = Direction.NORTH; //let dir = 0 默认情况下，NORTH 的初始值为 0，其余的成员会自动+1增长。换句话说，Direction.SOUTH值为1，Direction.EAST值为2，Direction.WEST值为3。 当然我们也可以设置 NORTH 的初始值，比如： enum Direction { NORTH = 3, SOUTH, //4 EAST, //5 WEST, //6 } 2. 字符串枚举 在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 enum Direction { NORTH = &quot;NORTH&quot;, SOUTH = &quot;SOUTH&quot;, EAST = &quot;EAST&quot;, WEST = &quot;WEST&quot;, } let dir: Direction = Direction.NORTH; //let dir = 'NORTH' 比起枚举类型，我更推荐使用联合类型来表达对于一组值的约束： const Direction = &quot;NORTH&quot; | &quot;SOUTH&quot; | &quot;EAST&quot; | &quot;WEST&quot;; let dir: Direction = &quot;NORTH&quot;; 9. Object 类型 Object 类型：它是所有 Object 类的实例的类型，它由以下两个接口来定义： Object 接口定义了 Object.prototype 原型对象上的属性； // node_modules/typescript/lib/lib.es5.d.ts interface Object { constructor: Function; toString(): string; toLocaleString(): string; valueOf(): Object; hasOwnProperty(v: PropertyKey): boolean; isPrototypeOf(v: Object): boolean; propertyIsEnumerable(v: PropertyKey): boolean; } ObjectConstructor 接口定义了 Object 类的属性。 // node_modules/typescript/lib/lib.es5.d.ts interface ObjectConstructor { /** Invocation via `new` */ new (value?: any): Object; /** Invocation via function calls */ (value?: any): any; readonly prototype: Object; getPrototypeOf(o: any): any; // ··· } Object 类的所有实例都继承了 Object 接口中的所有属性。 10. Any 类型 在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型）。 let value: any = 666; value = &quot;hello&quot;; value = false; value = {}; value = []; any类型为从JavaScript到TypeScript提供了平稳的过渡方式：你可以将任意类型赋值给any类型，同时也可以对 any 类型的值执行任何操作，而无需做任何形式的静态类型检查。 let value: any; value.foo.bar; //✅ value.trim(); // ✅ value(); // ✅ new value(); // ✅ value[0][1]; // ✅ 在许多场景下，这太宽松了。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。 11. Unknown 类型 就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。 let value: unknown = 666; value = &quot;hello&quot;; value = false; value = {}; value = []; 但是你不能将unknown类型赋值给一个已经确定的类型：即unknown 类型只能被赋值给 any 类型和 unknown 类型本身。 let value: unknown; let value1: unknown = value; // ✅ let value2: any = value; // ✅ let value3: boolean = value; // ❌ let value4: number = value; // ❌ let value5: string = value; // ❌ let value6: object = value; // ❌ let value7: any[] = value; // ❌ let value8: Function = value; // ❌ 同时unknown也无法像any那样执行任意操作： let value: unknown; value.foo.bar; // ❌ value.trim(); // ❌ value(); // ❌ new value(); // ❌ value[0][1]; // ❌ 总结：any类型和unknown类型的异同： 类型 any unknown 被赋值 可以被赋予任意值 可以被赋予任意值 赋值 可以赋值给任意变量 只能赋值给 any 和 unknown 类型变量 操作 可以进行任意操作 所有操作被禁止 12. Void 类型 某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void： function doSomething(): void { console.log(&quot;do something&quot;); } 需要注意的是，声明一个 void 类型的变量没有什么作用，因为在严格模式下，它的值只能为 undefined： let unusable: void = undefined; 13. Never 类型 never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。 // function 永远不会返回 function error(message: string): never { throw new Error(message); } 又如，基础类型的交叉类型返回的也是never，应为他们之间永远不存在交集： let value = &quot;1&quot; &amp; 1; // never 在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下： type Foo = string | number; function controlFlowAnalysisWithNever(foo: Foo) { if (typeof foo === &quot;string&quot;) { // 这里 foo 被收窄为 string 类型 } else if (typeof foo === &quot;number&quot;) { // 这里 foo 被收窄为 number 类型 } else { // foo 在这里是 never const check: never = foo; } } 注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型： type Foo = string | number | boolean; 然而他忘记同时修改 controlFlowAnalysisWithNever 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保 controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。 参考文章 TypeScript 中文手册 一份不可多得的 TS 学习指南 ","link":"https://wuwenbang.github.io/post/typescript-ji-chu-lei-xing/"}]}